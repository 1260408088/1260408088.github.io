<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[hive的窗口函数]]></title>
    <url>%2F2020%2F12%2F08%2Fhive%E7%9A%84%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[这老哥的窗口函数总结的十分不错，我就拿来主义了，附上地址 http://lxw1234.com/archives/2015/04/190.htm数据准备123456789101112131415161718192021222324252627282930313233343536373839cookie1,2015-04-10 10:00:02,url2cookie1,2015-04-10 10:00:00,url1cookie1,2015-04-10 10:03:04,1url3cookie1,2015-04-10 10:50:05,url6cookie1,2015-04-10 11:00:00,url7cookie1,2015-04-10 10:10:00,url4cookie1,2015-04-10 10:50:01,url5cookie2,2015-04-10 10:00:02,url22cookie2,2015-04-10 10:00:00,url11cookie2,2015-04-10 10:03:04,1url33cookie2,2015-04-10 10:50:05,url66cookie2,2015-04-10 11:00:00,url77cookie2,2015-04-10 10:10:00,url44cookie2,2015-04-10 10:50:01,url55 CREATE EXTERNAL TABLE lxw1234 (cookieid string,createtime string, --页面访问时间url STRING --被访问页面) ROW FORMAT DELIMITED FIELDS TERMINATED BY ',' stored as textfile location '/tmp/lxw11/';hive&gt; select * from lxw1234;OKcookie1 2015-04-10 10:00:02 url2cookie1 2015-04-10 10:00:00 url1cookie1 2015-04-10 10:03:04 1url3cookie1 2015-04-10 10:50:05 url6cookie1 2015-04-10 11:00:00 url7cookie1 2015-04-10 10:10:00 url4cookie1 2015-04-10 10:50:01 url5cookie2 2015-04-10 10:00:02 url22cookie2 2015-04-10 10:00:00 url11cookie2 2015-04-10 10:03:04 1url33cookie2 2015-04-10 10:50:05 url66cookie2 2015-04-10 11:00:00 url77cookie2 2015-04-10 10:10:00 url44cookie2 2015-04-10 10:50:01 url55LAGLAG(col,n,DEFAULT) 用于统计窗口内往上第n行值第一个参数为列名，第二个参数为往上第n行（可选，默认为1），第三个参数为默认值（当往上第n行为NULL时候，取默认值，如不指定，则为NULL）1234567891011121314151617181920212223242526272829303132SELECT cookieid,createtime,url,ROW_NUMBER() OVER(PARTITION BY cookieid ORDER BY createtime) AS rn,LAG(createtime,1,'1970-01-01 00:00:00') OVER(PARTITION BY cookieid ORDER BY createtime) AS last_1_time,LAG(createtime,2) OVER(PARTITION BY cookieid ORDER BY createtime) AS last_2_time FROM lxw1234;cookieid createtime url rn last_1_time last_2_time\-------------------------------------------------------------------------------------------cookie1 2015-04-10 10:00:00 url1 1 1970-01-01 00:00:00 NULLcookie1 2015-04-10 10:00:02 url2 2 2015-04-10 10:00:00 NULLcookie1 2015-04-10 10:03:04 1url3 3 2015-04-10 10:00:02 2015-04-10 10:00:00cookie1 2015-04-10 10:10:00 url4 4 2015-04-10 10:03:04 2015-04-10 10:00:02cookie1 2015-04-10 10:50:01 url5 5 2015-04-10 10:10:00 2015-04-10 10:03:04cookie1 2015-04-10 10:50:05 url6 6 2015-04-10 10:50:01 2015-04-10 10:10:00cookie1 2015-04-10 11:00:00 url7 7 2015-04-10 10:50:05 2015-04-10 10:50:01cookie2 2015-04-10 10:00:00 url11 1 1970-01-01 00:00:00 NULLcookie2 2015-04-10 10:00:02 url22 2 2015-04-10 10:00:00 NULLcookie2 2015-04-10 10:03:04 1url33 3 2015-04-10 10:00:02 2015-04-10 10:00:00cookie2 2015-04-10 10:10:00 url44 4 2015-04-10 10:03:04 2015-04-10 10:00:02cookie2 2015-04-10 10:50:01 url55 5 2015-04-10 10:10:00 2015-04-10 10:03:04cookie2 2015-04-10 10:50:05 url66 6 2015-04-10 10:50:01 2015-04-10 10:10:00cookie2 2015-04-10 11:00:00 url77 7 2015-04-10 10:50:05 2015-04-10 10:50:01last_1_time: 指定了往上第1行的值， default 为'1970-01-01 00:00:00' ​ cookie1第一行，往上1行为NULL,因此取默认值 1970-01-01 00:00:00​ cookie1第三行，往上1行值为第二行值，2015-04-10 10:00:02​ cookie1第六行，往上1行值为第五行值，2015-04-10 10:50:01last_2_time: 指定了往上第2行的值，为指定默认值​ cookie1第一行，往上2行为NULL​ cookie1第二行，往上2行为NULL​ cookie1第四行，往上2行为第二行值，2015-04-10 10:00:02​ cookie1第七行，往上2行为第五行值，2015-04-10 10:50:01LEAD与LAG相反LEAD(col,n,DEFAULT) 用于统计窗口内往下第n行值第一个参数为列名，第二个参数为往下第n行（可选，默认为1），第三个参数为默认值（当往下第n行为NULL时候，取默认值，如不指定，则为NULL）123456789101112131415161718192021222324SELECT cookieid,createtime,url,ROW_NUMBER() OVER(PARTITION BY cookieid ORDER BY createtime) AS rn,LEAD(createtime,1,'1970-01-01 00:00:00') OVER(PARTITION BY cookieid ORDER BY createtime) AS next_1_time,LEAD(createtime,2) OVER(PARTITION BY cookieid ORDER BY createtime) AS next_2_time FROM lxw1234;cookieid createtime url rn next_1_time next_2_time \-------------------------------------------------------------------------------------------cookie1 2015-04-10 10:00:00 url1 1 2015-04-10 10:00:02 2015-04-10 10:03:04cookie1 2015-04-10 10:00:02 url2 2 2015-04-10 10:03:04 2015-04-10 10:10:00cookie1 2015-04-10 10:03:04 1url3 3 2015-04-10 10:10:00 2015-04-10 10:50:01cookie1 2015-04-10 10:10:00 url4 4 2015-04-10 10:50:01 2015-04-10 10:50:05cookie1 2015-04-10 10:50:01 url5 5 2015-04-10 10:50:05 2015-04-10 11:00:00cookie1 2015-04-10 10:50:05 url6 6 2015-04-10 11:00:00 NULLcookie1 2015-04-10 11:00:00 url7 7 1970-01-01 00:00:00 NULLcookie2 2015-04-10 10:00:00 url11 1 2015-04-10 10:00:02 2015-04-10 10:03:04cookie2 2015-04-10 10:00:02 url22 2 2015-04-10 10:03:04 2015-04-10 10:10:00cookie2 2015-04-10 10:03:04 1url33 3 2015-04-10 10:10:00 2015-04-10 10:50:01cookie2 2015-04-10 10:10:00 url44 4 2015-04-10 10:50:01 2015-04-10 10:50:05cookie2 2015-04-10 10:50:01 url55 5 2015-04-10 10:50:05 2015-04-10 11:00:00cookie2 2015-04-10 10:50:05 url66 6 2015-04-10 11:00:00 NULLcookie2 2015-04-10 11:00:00 url77 7 1970-01-01 00:00:00 NULL--逻辑与LAG一样，只不过LAG是往上，LEAD是往下。FIRST_VALUE取分组内排序后，截止到当前行，第一个值12345678910111213141516171819202122SELECT cookieid,createtime,url,ROW_NUMBER() OVER(PARTITION BY cookieid ORDER BY createtime) AS rn,FIRST_VALUE(url) OVER(PARTITION BY cookieid ORDER BY createtime) AS first1 FROM lxw1234;cookieid createtime url rn first1\---------------------------------------------------------cookie1 2015-04-10 10:00:00 url1 1 url1cookie1 2015-04-10 10:00:02 url2 2 url1cookie1 2015-04-10 10:03:04 1url3 3 url1cookie1 2015-04-10 10:10:00 url4 4 url1cookie1 2015-04-10 10:50:01 url5 5 url1cookie1 2015-04-10 10:50:05 url6 6 url1cookie1 2015-04-10 11:00:00 url7 7 url1cookie2 2015-04-10 10:00:00 url11 1 url11cookie2 2015-04-10 10:00:02 url22 2 url11cookie2 2015-04-10 10:03:04 1url33 3 url11cookie2 2015-04-10 10:10:00 url44 4 url11cookie2 2015-04-10 10:50:01 url55 5 url11cookie2 2015-04-10 10:50:05 url66 6 url11cookie2 2015-04-10 11:00:00 url77 7 url11LAST_VALUE取分组内排序后，截止到当前行，最后一个值12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091SELECT cookieid,createtime,url,ROW_NUMBER() OVER(PARTITION BY cookieid ORDER BY createtime) AS rn,LAST_VALUE(url) OVER(PARTITION BY cookieid ORDER BY createtime) AS last1 FROM lxw1234;cookieid createtime url rn last1 \-----------------------------------------------------------------cookie1 2015-04-10 10:00:00 url1 1 url1cookie1 2015-04-10 10:00:02 url2 2 url2cookie1 2015-04-10 10:03:04 1url3 3 1url3cookie1 2015-04-10 10:10:00 url4 4 url4cookie1 2015-04-10 10:50:01 url5 5 url5cookie1 2015-04-10 10:50:05 url6 6 url6cookie1 2015-04-10 11:00:00 url7 7 url7cookie2 2015-04-10 10:00:00 url11 1 url11cookie2 2015-04-10 10:00:02 url22 2 url22cookie2 2015-04-10 10:03:04 1url33 3 1url33cookie2 2015-04-10 10:10:00 url44 4 url44cookie2 2015-04-10 10:50:01 url55 5 url55cookie2 2015-04-10 10:50:05 url66 6 url66cookie2 2015-04-10 11:00:00 url77 7 url77 如果不指定ORDER BY，则默认按照记录在文件中的偏移量进行排序，会出现错误的结果 SELECT cookieid,createtime,url,FIRST_VALUE(url) OVER(PARTITION BY cookieid) AS first2 FROM lxw1234;cookieid createtime url first2\----------------------------------------------cookie1 2015-04-10 10:00:02 url2 url2cookie1 2015-04-10 10:00:00 url1 url2cookie1 2015-04-10 10:03:04 1url3 url2cookie1 2015-04-10 10:50:05 url6 url2cookie1 2015-04-10 11:00:00 url7 url2cookie1 2015-04-10 10:10:00 url4 url2cookie1 2015-04-10 10:50:01 url5 url2cookie2 2015-04-10 10:00:02 url22 url22cookie2 2015-04-10 10:00:00 url11 url22cookie2 2015-04-10 10:03:04 1url33 url22cookie2 2015-04-10 10:50:05 url66 url22cookie2 2015-04-10 11:00:00 url77 url22cookie2 2015-04-10 10:10:00 url44 url22cookie2 2015-04-10 10:50:01 url55 url22SELECT cookieid,createtime,url,LAST_VALUE(url) OVER(PARTITION BY cookieid) AS last2 FROM lxw1234;cookieid createtime url last2\----------------------------------------------cookie1 2015-04-10 10:00:02 url2 url5cookie1 2015-04-10 10:00:00 url1 url5cookie1 2015-04-10 10:03:04 1url3 url5cookie1 2015-04-10 10:50:05 url6 url5cookie1 2015-04-10 11:00:00 url7 url5cookie1 2015-04-10 10:10:00 url4 url5cookie1 2015-04-10 10:50:01 url5 url5cookie2 2015-04-10 10:00:02 url22 url55cookie2 2015-04-10 10:00:00 url11 url55cookie2 2015-04-10 10:03:04 1url33 url55cookie2 2015-04-10 10:50:05 url66 url55cookie2 2015-04-10 11:00:00 url77 url55cookie2 2015-04-10 10:10:00 url44 url55cookie2 2015-04-10 10:50:01 url55 url55 如果想要取分组内排序后最后一个值，则需要变通一下： SELECT cookieid,createtime,url,ROW_NUMBER() OVER(PARTITION BY cookieid ORDER BY createtime) AS rn,LAST_VALUE(url) OVER(PARTITION BY cookieid ORDER BY createtime) AS last1,FIRST_VALUE(url) OVER(PARTITION BY cookieid ORDER BY createtime DESC) AS last2 FROM lxw1234 ORDER BY cookieid,createtime;cookieid createtime url rn last1 last2\-------------------------------------------------------------cookie1 2015-04-10 10:00:00 url1 1 url1 url7cookie1 2015-04-10 10:00:02 url2 2 url2 url7cookie1 2015-04-10 10:03:04 1url3 3 1url3 url7cookie1 2015-04-10 10:10:00 url4 4 url4 url7cookie1 2015-04-10 10:50:01 url5 5 url5 url7cookie1 2015-04-10 10:50:05 url6 6 url6 url7cookie1 2015-04-10 11:00:00 url7 7 url7 url7cookie2 2015-04-10 10:00:00 url11 1 url11 url77cookie2 2015-04-10 10:00:02 url22 2 url22 url77cookie2 2015-04-10 10:03:04 1url33 3 1url33 url77cookie2 2015-04-10 10:10:00 url44 4 url44 url77cookie2 2015-04-10 10:50:01 url55 5 url55 url77cookie2 2015-04-10 10:50:05 url66 6 url66 url77cookie2 2015-04-10 11:00:00 url77 7 url77 url77提示：在使用分析函数的过程中，要特别注意ORDER BY子句，用的不恰当，统计出的结果就不是你所期望的。]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>hive</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot中@value注解不生效]]></title>
    <url>%2F2020%2F11%2F18%2Fspringboot%E4%B8%AD-value%E6%B3%A8%E8%A7%A3%E4%B8%8D%E7%94%9F%E6%95%88%2F</url>
    <content type="text"><![CDATA[注解修饰的变量不能是final、static。类要使用交给spring管理，使用@Component修饰所在类，不能有构造方法(我失败是因为这个)。不能new这个类，要@Autowried注入。在使用@Value，可以指定默认值，比如@Value(“${local-repository:/repository/}”) ,红色部分为默认值尾记：spring加载这个bean后要直接调用其中的一个方法，可以使用@postconstruct注解，能达到这个作用的方式还很多，留个空白，以后补充。]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>注解</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mapreducer的使用]]></title>
    <url>%2F2020%2F08%2F03%2Fmapreducer%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1.mapruduce的理念​ MapReduce是hadoop的计算框架。表现形式就是有个输入(input)和输出(output)。在运行一个mapreduce计算任务的时候，任务过程被分为两个阶段：map阶段和reduce阶段，每个阶段都是用键值对(key/value)作为输入(input)和输出(output)。2.demo​ 概念什么的东西说的再多，不如两个demo来的实在。1.计算网站访问的Top 5​ 需要计算的数据样式123456789101112131415161718192017/07/28 qq.com/a2017/07/28 qq.com/bx2017/07/28 qq.com/by2017/07/28 qq.com/by32017/07/28 qq.com/news2017/07/28 sina.com/news/socail2017/07/28 163.com/ac2017/07/28 sina.com/news/socail2017/07/28 163.com/sport2017/07/28 163.com/ac2017/07/28 sina.com/play2017/07/28 163.com/sport2017/07/28 163.com/ac2017/07/28 sina.com/movie2017/07/28 sina.com/play2017/07/28 sina.com/movie2017/07/28 163.com/sport2017/07/28 sina.com/movie.......mapreduce模式下对数据进行统计：12345678910111213141516// mapimport java.io.IOException;import org.apache.hadoop.io.IntWritable;import org.apache.hadoop.io.LongWritable;import org.apache.hadoop.io.Text;import org.apache.hadoop.mapreduce.Mapper;public class PageTopnMapper extends Mapper&lt;LongWritable, Text, Text, IntWritable&gt;&#123; @Override protected void map(LongWritable key, Text value, Mapper&lt;LongWritable, Text, Text, IntWritable&gt;.Context context) throws IOException, InterruptedException &#123; String line = value.toString(); String[] split = line.split(" "); context.write(new Text(split[1]), new IntWritable(1)); &#125;&#125;1234567891011121314151617181920212223242526272829303132333435363738# reducerimport java.io.IOException;import java.util.Map.Entry;import java.util.Set;import java.util.TreeMap;import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.io.IntWritable;import org.apache.hadoop.io.Text;import org.apache.hadoop.mapreduce.Reducer;public class PageTopnReducer extends Reducer&lt;Text, IntWritable, Text, IntWritable&gt;&#123; TreeMap&lt;PageCount, Object&gt; treeMap = new TreeMap&lt;&gt;(); @Override protected void reduce(Text key, Iterable&lt;IntWritable&gt; values, Reducer&lt;Text, IntWritable, Text, IntWritable&gt;.Context context) throws IOException, InterruptedException &#123; int count = 0; for (IntWritable value : values) &#123; count += value.get(); &#125; PageCount pageCount = new PageCount(); pageCount.set(key.toString(), count); treeMap.put(pageCount,null); &#125; @Override protected void cleanup(Context context) throws IOException, InterruptedException &#123; Configuration conf = context.getConfiguration(); int topn = conf.getInt("top.n", 5); Set&lt;Entry&lt;PageCount, Object&gt;&gt; entrySet = treeMap.entrySet(); int i= 0; for (Entry&lt;PageCount, Object&gt; entry : entrySet) &#123; context.write(new Text(entry.getKey().getPage()), new IntWritable(entry.getKey().getCount())); i++; if(i==topn) return; &#125; &#125;&#125;为了统计出top5使用了一个pagecount的类型，并且实现了Comparable的比较接口，为后续放入到treemap中方便排序做了准备12345678910111213141516171819202122232425262728293031package cn.edu360.mr.page.topn;public class PageCount implements Comparable&lt;PageCount&gt;&#123; private String page; private int count; public void set(String page, int count) &#123; this.page = page; this.count = count; &#125; public String getPage() &#123; return page; &#125; public void setPage(String page) &#123; this.page = page; &#125; public int getCount() &#123; return count; &#125; public void setCount(int count) &#123; this.count = count; &#125; @Override public int compareTo(PageCount o) &#123; // 此处数值相等了，会按照字母的顺序进行排序 return o.getCount()-this.count==0?this.page.compareTo(o.getPage()):o.getCount()-this.count; &#125;&#125;最后进行提交，因为这是demo所以只是在windows上进行单机的提交12345678910111213141516171819202122232425262728293031323334353637383940414243package cn.edu360.mr.page.topn;import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.fs.Path;import org.apache.hadoop.io.IntWritable;import org.apache.hadoop.io.Text;import org.apache.hadoop.mapreduce.Job;import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;public class JobSubmitter &#123; public static void main(String[] args) throws Exception &#123; /** * 通过加载classpath下的*-site.xml文件解析参数 */ Configuration conf = new Configuration(); conf.addResource("xx-oo.xml"); /** * 通过代码设置参数 */ //conf.setInt("top.n", 3); //conf.setInt("top.n", Integer.parseInt(args[0])); /** * 通过属性配置文件获取参数 */ /*Properties props = new Properties(); props.load(JobSubmitter.class.getClassLoader().getResourceAsStream("topn.properties")); conf.setInt("top.n", Integer.parseInt(props.getProperty("top.n")));*/ Job job = Job.getInstance(conf); job.setJarByClass(JobSubmitter.class); job.setMapperClass(PageTopnMapper.class); job.setReducerClass(PageTopnReducer.class); job.setMapOutputKeyClass(Text.class); job.setMapOutputValueClass(IntWritable.class); job.setOutputKeyClass(Text.class); job.setOutputValueClass(IntWritable.class); FileInputFormat.setInputPaths(job, new Path("F:\\mrdata\\url\\input")); FileOutputFormat.setOutputPath(job, new Path("F:\\mrdata\\url\\output")); // 必须不存在 job.waitForCompletion(true); &#125;&#125;2.自定义Partitioner​ 对电话归属地进行分块，不同的区号，生成不同的块数据样式123456789101112131415161718192021221363157985066 13726230503 00-FD-07-A4-72-B8:CMCC 120.196.100.82 i02.c.aliimg.com 24 27 2481 24681 2001363157995052 13826544101 5C-0E-8B-C7-F1-E0:CMCC 120.197.40.4 4 0 264 0 2001363157991076 13926435656 20-10-7A-28-CC-0A:CMCC 120.196.100.99 2 4 132 1512 2001363154400022 13926251106 5C-0E-8B-8B-B1-50:CMCC 120.197.40.4 4 0 240 0 2001363157993044 18211575961 94-71-AC-CD-E6-18:CMCC-EASY 120.196.100.99 iface.qiyi.com 视频网站 15 12 1527 2106 2001363157995074 84138413 5C-0E-8B-8C-E8-20:7DaysInn 120.197.40.4 122.72.52.12 20 16 4116 1432 2001363157993055 13560439658 C4-17-FE-BA-DE-D9:CMCC 120.196.100.99 18 15 1116 954 2001363157995033 15920133257 5C-0E-8B-C7-BA-20:CMCC 120.197.40.4 sug.so.360.cn 信息安全 20 20 3156 2936 2001363157983019 13719199419 68-A1-B7-03-07-B1:CMCC-EASY 120.196.100.82 4 0 240 0 2001363157984041 13660577991 5C-0E-8B-92-5C-20:CMCC-EASY 120.197.40.4 s19.cnzz.com 站点统计 24 9 6960 690 2001363157973098 15013685858 5C-0E-8B-C7-F7-90:CMCC 120.197.40.4 rank.ie.sogou.com 搜索引擎 28 27 3659 3538 2001363157986029 15989002119 E8-99-C4-4E-93-E0:CMCC-EASY 120.196.100.99 www.umeng.com 站点统计 3 3 1938 180 2001363157992093 13560439658 C4-17-FE-BA-DE-D9:CMCC 120.196.100.99 15 9 918 4938 2001363157986041 13480253104 5C-0E-8B-C7-FC-80:CMCC-EASY 120.197.40.4 3 3 180 180 2001363157984040 13602846565 5C-0E-8B-8B-B6-00:CMCC 120.197.40.4 2052.flash2-http.qq.com 综合门户 15 12 1938 2910 2001363157995093 13922314466 00-FD-07-A2-EC-BA:CMCC 120.196.100.82 img.qfc.cn 12 12 3008 3720 2001363157982040 13502468823 5C-0A-5B-6A-0B-D4:CMCC-EASY 120.196.100.99 y0.ifengimg.com 综合门户 57 102 7335 110349 2001363157986072 18320173382 84-25-DB-4F-10-1A:CMCC-EASY 120.196.100.99 input.shouji.sogou.com 搜索引擎 21 18 9531 2412 2001363157990043 13925057413 00-1F-64-E1-E6-9A:CMCC 120.196.100.55 t3.baidu.com 搜索引擎 69 63 11058 48243 2001363157988072 13760778710 00-FD-07-A4-7B-08:CMCC 120.196.100.82 2 2 120 120 2001363157985066 13726238888 00-FD-07-A4-72-B8:CMCC 120.196.100.82 i02.c.aliimg.com 24 27 2481 24681 2001363157993055 13560436666 C4-17-FE-BA-DE-D9:CMCC 120.196.100.99 18 15 1116 954 200为了方便进行统计，设计的统计类：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293import java.io.DataInput;import java.io.DataOutput;import java.io.IOException;import org.apache.hadoop.io.Writable;/** * 本案例的功能：演示自定义数据类型如何实现hadoop的序列化接口 * 1、该类一定要保留空参构造函数 * 2、write方法中输出字段二进制数据的顺序 要与 readFields方法读取数据的顺序一致 * * @author ThinkPad * */public class FlowBean implements Writable &#123; // hadoop的序列化接口 private int upFlow; private int dFlow; private String phone; private int amountFlow; public FlowBean()&#123;&#125; public FlowBean(String phone, int upFlow, int dFlow) &#123; this.phone = phone; this.upFlow = upFlow; this.dFlow = dFlow; this.amountFlow = upFlow + dFlow; &#125; public String getPhone() &#123; return phone; &#125; public void setPhone(String phone) &#123; this.phone = phone; &#125; public int getUpFlow() &#123; return upFlow; &#125; public void setUpFlow(int upFlow) &#123; this.upFlow = upFlow; &#125; public int getdFlow() &#123; return dFlow; &#125; public void setdFlow(int dFlow) &#123; this.dFlow = dFlow; &#125; public int getAmountFlow() &#123; return amountFlow; &#125; public void setAmountFlow(int amountFlow) &#123; this.amountFlow = amountFlow; &#125; /** * hadoop系统在序列化该类的对象时要调用的方法 */ @Override public void write(DataOutput out) throws IOException &#123; out.writeInt(upFlow); out.writeUTF(phone); out.writeInt(dFlow); out.writeInt(amountFlow); &#125; /** * hadoop系统在反序列化该类的对象时要调用的方法 */ @Override public void readFields(DataInput in) throws IOException &#123; this.upFlow = in.readInt(); this.phone = in.readUTF(); this.dFlow = in.readInt(); this.amountFlow = in.readInt(); &#125; @Override public String toString() &#123; return this.phone + ","+this.upFlow +","+ this.dFlow +"," + this.amountFlow; &#125; &#125;map123456789101112131415161718import java.io.IOException;import org.apache.hadoop.io.LongWritable;import org.apache.hadoop.io.Text;import org.apache.hadoop.mapreduce.Mapper;public class FlowCountMapper extends Mapper&lt;LongWritable, Text, Text, FlowBean&gt;&#123; @Override protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException &#123; String line = value.toString(); String[] fields = line.split("\t"); String phone = fields[1]; int upFlow = Integer.parseInt(fields[fields.length-3]); int dFlow = Integer.parseInt(fields[fields.length-2]); context.write(new Text(phone), new FlowBean(phone, upFlow, dFlow)); &#125;&#125;reduce12345678910111213141516171819202122import java.io.IOException;import org.apache.hadoop.io.Text;import org.apache.hadoop.mapreduce.Reducer;public class FlowCountReducer extends Reducer&lt;Text, FlowBean, Text, FlowBean&gt;&#123; /** * key：是某个手机号 * values：是这个手机号所产生的所有访问记录中的流量数据 * * &lt;135,flowBean1&gt;&lt;135,flowBean2&gt;&lt;135,flowBean3&gt;&lt;135,flowBean4&gt; */ @Override protected void reduce(Text key, Iterable&lt;FlowBean&gt; values, Reducer&lt;Text, FlowBean, Text, FlowBean&gt;.Context context) throws IOException, InterruptedException &#123; int upSum = 0; int dSum = 0; for(FlowBean value:values)&#123; upSum += value.getUpFlow(); dSum += value.getdFlow(); &#125; context.write(key, new FlowBean(key.toString(), upSum, dSum)); &#125;&#125;Partitioner的实现，根据区号进行划分不同的输出123456789101112131415161718192021222324252627import java.util.HashMap;import org.apache.hadoop.io.Text;import org.apache.hadoop.mapreduce.Partitioner;/** * 本类是提供给MapTask用的 * MapTask通过这个类的getPartition方法，来计算它所产生的每一对kv数据该分发给哪一个reduce task * @author ThinkPad * */public class ProvincePartitioner extends Partitioner&lt;Text, FlowBean&gt;&#123; static HashMap&lt;String,Integer&gt; codeMap = new HashMap&lt;&gt;(); static&#123; codeMap.put("135", 0); codeMap.put("136", 1); codeMap.put("137", 2); codeMap.put("138", 3); codeMap.put("139", 4); &#125; @Override public int getPartition(Text key, FlowBean value, int numPartitions) &#123; Integer code = codeMap.get(key.toString().substring(0, 3)); return code==null?5:code; &#125;&#125;submit1234567891011121314151617181920212223242526import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.fs.Path;import org.apache.hadoop.io.Text;import org.apache.hadoop.mapreduce.Job;import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;public class JobSubmitter &#123; public static void main(String[] args) throws Exception &#123; Configuration conf = new Configuration(); Job job = Job.getInstance(conf); job.setJarByClass(JobSubmitter.class); job.setMapperClass(FlowCountMapper.class); job.setReducerClass(FlowCountReducer.class); // 设置参数：maptask在做数据分区时，用哪个分区逻辑类 （如果不指定，它会用默认的HashPartitioner） job.setPartitionerClass(ProvincePartitioner.class); // 由于我们的ProvincePartitioner可能会产生6种分区号，所以，需要有6个reduce task来接收 job.setNumReduceTasks(6); job.setMapOutputKeyClass(Text.class); job.setMapOutputValueClass(FlowBean.class); job.setOutputKeyClass(Text.class); job.setOutputValueClass(FlowBean.class); FileInputFormat.setInputPaths(job, new Path("F:\\mrdata\\flow\\input")); FileOutputFormat.setOutputPath(job, new Path("F:\\mrdata\\flow\\province-output")); job.waitForCompletion(true); &#125;&#125;最后的输出结果：有6个文件对应不同的结果，打开悄悄]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ的几种工作模式]]></title>
    <url>%2F2020%2F07%2F16%2FRabbitMQ%E7%9A%84%E5%87%A0%E7%A7%8D%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[cspringCloud中的关于RabbitMQ的笔记，我觉得较为好，就拿来主义了，还是那句话，感谢传智播客….1.1.搜索与商品服务的问题目前我们已经完成了商品详情和搜索系统的开发。我们思考一下，是否存在问题？商品的原始数据保存在数据库中，增删改查都在数据库中完成。搜索服务数据来源是索引库，如果数据库商品发生变化，索引库数据不能及时更新。商品详情做了页面静态化，静态页面数据也不会随着数据库商品发生变化。如果我们在后台修改了商品的价格，搜索页面和商品详情页显示的依然是旧的价格，这样显然不对。该如何解决？这里有两种解决方案：方案1：每当后台对商品做增删改操作，同时要修改索引库数据及静态页面方案2：搜索服务和商品页面服务对外提供操作接口，后台在商品增删改后，调用接口以上两种方式都有同一个严重问题：就是代码耦合，后台服务中需要嵌入搜索和商品页面服务，违背了微服务的独立原则。所以，我们会通过另外一种方式来解决这个问题：消息队列1.2.消息队列（MQ）1.2.1.什么是消息队列消息队列，即MQ，Message Queue。消息队列是典型的：生产者、消费者模型。生产者不断向消息队列中生产消息，消费者不断的从队列中获取消息。因为消息的生产和消费都是异步的，而且只关心消息的发送和接收，没有业务逻辑的侵入，这样就实现了生产者和消费者的解耦。结合前面所说的问题：商品服务对商品增删改以后，无需去操作索引库或静态页面，只是发送一条消息，也不关心消息被谁接收。搜索服务和静态页面服务接收消息，分别去处理索引库和静态页面。如果以后有其它系统也依赖商品服务的数据，同样监听消息即可，商品服务无需任何代码修改。1.2.2.AMQP和JMSMQ是消息通信的模型，并不是具体实现。现在实现MQ的有两种主流方式：AMQP、JMS。两者间的区别和联系：JMS是定义了统一的接口，来对消息操作进行统一；AMQP是通过规定协议来统一数据交互的格式JMS限定了必须使用Java语言；AMQP只是协议，不规定实现方式，因此是跨语言的。JMS规定了两种消息模型；而AMQP的消息模型更加丰富1.2.3.常见MQ产品ActiveMQ：基于JMSRabbitMQ：基于AMQP协议，erlang语言开发，稳定性好RocketMQ：基于JMS，阿里巴巴产品，目前交由Apache基金会Kafka：分布式消息系统，高吞吐量1.2.4.RabbitMQRabbitMQ是基于AMQP的一款消息管理系统官网： http://www.rabbitmq.com/官方教程：http://www.rabbitmq.com/getstarted.html1.3.下载和安装1.3.1.下载官网下载地址：http://www.rabbitmq.com/download.html目前最新版本是：3.7.5我们的课程中使用的是：3.4.1版本课前资料提供了安装包：1.3.2.安装详见课前资料中的：2.五种消息模型RabbitMQ提供了6种消息模型，但是第6种其实是RPC，并不是MQ，因此不予学习。那么也就剩下5种。但是其实3、4、5这三种都属于订阅模型，只不过进行路由的方式不同。我们通过一个demo工程来了解下RabbitMQ的工作方式：导入工程：导入后：依赖：123456789101112131415161718192021222324252627282930&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.itcast.rabbitmq&lt;/groupId&gt; &lt;artifactId&gt;itcast-rabbitmq&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt;我们抽取一个建立RabbitMQ连接的工具类，方便其他程序获取连接：12345678910111213141516171819202122public class ConnectionUtil &#123; /** * 建立与RabbitMQ的连接 * @return * @throws Exception */ public static Connection getConnection() throws Exception &#123; //定义连接工厂 ConnectionFactory factory = new ConnectionFactory(); //设置服务地址 factory.setHost("192.168.56.101"); //端口 factory.setPort(5672); //设置账号信息，用户名、密码、vhost factory.setVirtualHost("/leyou"); factory.setUsername("leyou"); factory.setPassword("leyou"); // 通过工程获取连接 Connection connection = factory.newConnection(); return connection; &#125;&#125;2.1.基本消息模型官方介绍：RabbitMQ是一个消息代理：它接受和转发消息。 你可以把它想象成一个邮局：当你把邮件放在邮箱里时，你可以确定邮差先生最终会把邮件发送给你的收件人。 在这个比喻中，RabbitMQ是邮政信箱，邮局和邮递员。RabbitMQ与邮局的主要区别是它不处理纸张，而是接受，存储和转发数据消息的二进制数据块。P（producer/ publisher）：生产者，一个发送消息的用户应用程序。C（consumer）：消费者，消费和接收有类似的意思，消费者是一个主要用来等待接收消息的用户应用程序队列（红色区域）：rabbitmq内部类似于邮箱的一个概念。虽然消息流经rabbitmq和你的应用程序，但是它们只能存储在队列中。队列只受主机的内存和磁盘限制，实质上是一个大的消息缓冲区。许多生产者可以发送消息到一个队列，许多消费者可以尝试从一个队列接收数据。总之：生产者将消息发送到队列，消费者从队列中获取消息，队列是存储消息的缓冲区。我们将用Java编写两个程序;发送单个消息的生产者，以及接收消息并将其打印出来的消费者。我们将详细介绍Java API中的一些细节，这是一个消息传递的“Hello World”。我们将调用我们的消息发布者（发送者）Send和我们的消息消费者（接收者）Recv。发布者将连接到RabbitMQ，发送一条消息，然后退出。2.1.1.生产者发送消息123456789101112131415161718192021222324public class Send &#123; private final static String QUEUE_NAME = "simple_queue"; public static void main(String[] argv) throws Exception &#123; // 获取到连接以及mq通道 Connection connection = ConnectionUtil.getConnection(); // 从连接中创建通道，这是完成大部分API的地方。 Channel channel = connection.createChannel(); // 声明（创建）队列，必须声明队列才能够发送消息，我们可以把消息发送到队列中。 // 声明一个队列是幂等的 - 只有当它不存在时才会被创建 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 消息内容 String message = "Hello World!"; channel.basicPublish("", QUEUE_NAME, null, message.getBytes()); System.out.println(" [x] Sent '" + message + "'"); //关闭通道和连接 channel.close(); connection.close(); &#125;&#125;控制台：2.1.2.管理工具中查看消息进入队列页面，可以看到新建了一个队列：simple_queue点击队列名称，进入详情页，可以查看消息：在控制台查看消息并不会将消息消费，所以消息还在。2.1.3.消费者获取消息12345678910111213141516171819202122232425public class Recv &#123; private final static String QUEUE_NAME = "simple_queue"; public static void main(String[] argv) throws Exception &#123; // 获取到连接 Connection connection = ConnectionUtil.getConnection(); // 创建通道 Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 定义队列的消费者 DefaultConsumer consumer = new DefaultConsumer(channel) &#123; // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用 @Override public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties, byte[] body) throws IOException &#123; // body 即消息体 String msg = new String(body); System.out.println(" [x] received : " + msg + "!"); &#125; &#125;; // 监听队列，第二个参数：是否自动进行消息确认。 channel.basicConsume(QUEUE_NAME, true, consumer); &#125;&#125;控制台：这个时候，队列中的消息就没了：我们发现，消费者已经获取了消息，但是程序没有停止，一直在监听队列中是否有新的消息。一旦有新的消息进入队列，就会立即打印.2.1.4.消息确认机制（ACK）通过刚才的案例可以看出，消息一旦被消费者接收，队列中的消息就会被删除。那么问题来了：RabbitMQ怎么知道消息被接收了呢？如果消费者领取消息后，还没执行操作就挂掉了呢？或者抛出了异常？消息消费失败，但是RabbitMQ无从得知，这样消息就丢失了！因此，RabbitMQ有一个ACK机制。当消费者获取消息后，会向RabbitMQ发送回执ACK，告知消息已经被接收。不过这种回执ACK分两种情况：自动ACK：消息一旦被接收，消费者自动发送ACK手动ACK：消息接收后，不会发送ACK，需要手动调用大家觉得哪种更好呢？这需要看消息的重要性：如果消息不太重要，丢失也没有影响，那么自动ACK会比较方便如果消息非常重要，不容丢失。那么最好在消费完成后手动ACK，否则接收消息后就自动ACK，RabbitMQ就会把消息从队列中删除。如果此时消费者宕机，那么消息就丢失了。我们之前的测试都是自动ACK的，如果要手动ACK，需要改动我们的代码：123456789101112131415161718192021222324252627public class Recv2 &#123; private final static String QUEUE_NAME = "simple_queue"; public static void main(String[] argv) throws Exception &#123; // 获取到连接 Connection connection = ConnectionUtil.getConnection(); // 创建通道 final Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 定义队列的消费者 DefaultConsumer consumer = new DefaultConsumer(channel) &#123; // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用 @Override public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties, byte[] body) throws IOException &#123; // body 即消息体 String msg = new String(body); System.out.println(" [x] received : " + msg + "!"); // 手动进行ACK channel.basicAck(envelope.getDeliveryTag(), false); &#125; &#125;; // 监听队列，第二个参数false，手动进行ACK channel.basicConsume(QUEUE_NAME, false, consumer); &#125;&#125;注意到最后一行代码：1channel.basicConsume(QUEUE_NAME, false, consumer);如果第二个参数为true，则会自动进行ACK；如果为false，则需要手动ACK。方法的声明：2.1.4.1.自动ACK存在的问题修改消费者，添加异常，如下：生产者不做任何修改，直接运行，消息发送成功：运行消费者，程序抛出异常。但是消息依然被消费：管理界面：2.1.4.2.演示手动ACK修改消费者，把自动改成手动（去掉之前制造的异常）生产者不变，再次运行：运行消费者但是，查看管理界面，发现：停掉消费者的程序，发现：这是因为虽然我们设置了手动ACK，但是代码中并没有进行消息确认！所以消息并未被真正消费掉。当我们关掉这个消费者，消息的状态再次称为Ready修改代码手动ACK：执行：消息消费成功！2.2.work消息模型工作队列或者竞争消费者模式在第一篇教程中，我们编写了一个程序，从一个命名队列中发送并接受消息。在这里，我们将创建一个工作队列，在多个工作者之间分配耗时任务。工作队列，又称任务队列。主要思想就是避免执行资源密集型任务时，必须等待它执行完成。相反我们稍后完成任务，我们将任务封装为消息并将其发送到队列。 在后台运行的工作进程将获取任务并最终执行作业。当你运行许多工人时，任务将在他们之间共享，但是一个消息只能被一个消费者获取。这个概念在Web应用程序中特别有用，因为在短的HTTP请求窗口中无法处理复杂的任务。接下来我们来模拟这个流程：​ P：生产者：任务的发布者​ C1：消费者，领取任务并且完成任务，假设完成速度较快​ C2：消费者2：领取任务并完成任务，假设完成速度慢面试题：避免消息堆积？1） 采用workqueue，多个消费者监听同一队列。2）接收到消息以后，而是通过线程池，异步消费。2.2.1.生产者生产者与案例1中的几乎一样：123456789101112131415161718192021222324public class Send &#123; private final static String QUEUE_NAME = "test_work_queue"; public static void main(String[] argv) throws Exception &#123; // 获取到连接 Connection connection = ConnectionUtil.getConnection(); // 获取通道 Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 循环发布任务 for (int i = 0; i &lt; 50; i++) &#123; // 消息内容 String message = "task .. " + i; channel.basicPublish("", QUEUE_NAME, null, message.getBytes()); System.out.println(" [x] Sent '" + message + "'"); Thread.sleep(i * 2); &#125; // 关闭通道和连接 channel.close(); connection.close(); &#125;&#125;不过这里我们是循环发送50条消息。2.2.2.消费者12.2.3.消费者2与消费者1基本类似，就是没有设置消费耗时时间。这里是模拟有些消费者快，有些比较慢。接下来，两个消费者一同启动，然后发送50条消息：可以发现，两个消费者各自消费了25条消息，而且各不相同，这就实现了任务的分发。2.2.4.能者多劳刚才的实现有问题吗？消费者1比消费者2的效率要低，一次任务的耗时较长然而两人最终消费的消息数量是一样的消费者2大量时间处于空闲状态，消费者1一直忙碌现在的状态属于是把任务平均分配，正确的做法应该是消费越快的人，消费的越多。怎么实现呢？我们可以使用basicQos方法和prefetchCount = 1设置。 这告诉RabbitMQ一次不要向工作人员发送多于一条消息。 或者换句话说，不要向工作人员发送新消息，直到它处理并确认了前一个消息。 相反，它会将其分派给不是仍然忙碌的下一个工作人员。再次测试：2.3.订阅模型分类在之前的模式中，我们创建了一个工作队列。 工作队列背后的假设是：每个任务只被传递给一个工作人员。 在这一部分，我们将做一些完全不同的事情 - 我们将会传递一个信息给多个消费者。 这种模式被称为“发布/订阅”。订阅模型示意图：解读：1、1个生产者，多个消费者2、每一个消费者都有自己的一个队列3、生产者没有将消息直接发送到队列，而是发送到了交换机4、每个队列都要绑定到交换机5、生产者发送的消息，经过交换机到达队列，实现一个消息被多个消费者获取的目的X（Exchanges）：交换机一方面：接收生产者发送的消息。另一方面：知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。Exchange类型有以下几种：​ Fanout：广播，将消息交给所有绑定到交换机的队列​ Direct：定向，把消息交给符合指定routing key 的队列​ Topic：通配符，把消息交给符合routing pattern（路由模式） 的队列我们这里先学习​ Fanout：即广播模式Exchange（交换机）只负责转发消息，不具备存储消息的能力，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！2.4.订阅模型-FanoutFanout，也称为广播。流程图：在广播模式下，消息发送流程是这样的：1） 可以有多个消费者2） 每个消费者有自己的queue（队列）3） 每个队列都要绑定到Exchange（交换机）4） 生产者发送的消息，只能发送到交换机，交换机来决定要发给哪个队列，生产者无法决定。5） 交换机把消息发送给绑定过的所有队列6） 队列的消费者都能拿到消息。实现一条消息被多个消费者消费2.4.1.生产者两个变化：1） 声明Exchange，不再声明Queue2） 发送消息到Exchange，不再发送到Queue1234567891011121314151617181920212223public class Send &#123; private final static String EXCHANGE_NAME = "fanout_exchange_test"; public static void main(String[] argv) throws Exception &#123; // 获取到连接 Connection connection = ConnectionUtil.getConnection(); // 获取通道 Channel channel = connection.createChannel(); // 声明exchange，指定类型为fanout channel.exchangeDeclare(EXCHANGE_NAME, "fanout"); // 消息内容 String message = "Hello everyone"; // 发布消息到Exchange channel.basicPublish(EXCHANGE_NAME, "", null, message.getBytes()); System.out.println(" [生产者] Sent '" + message + "'"); channel.close(); connection.close(); &#125;&#125;2.4.2.消费者112345678910111213141516171819202122232425262728293031public class Recv &#123; private final static String QUEUE_NAME = "fanout_exchange_queue_1"; private final static String EXCHANGE_NAME = "fanout_exchange_test"; public static void main(String[] argv) throws Exception &#123; // 获取到连接 Connection connection = ConnectionUtil.getConnection(); // 获取通道 Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 绑定队列到交换机 channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, ""); // 定义队列的消费者 DefaultConsumer consumer = new DefaultConsumer(channel) &#123; // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用 @Override public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties, byte[] body) throws IOException &#123; // body 即消息体 String msg = new String(body); System.out.println(" [消费者1] received : " + msg + "!"); &#125; &#125;; // 监听队列，自动返回完成 channel.basicConsume(QUEUE_NAME, true, consumer); &#125;&#125;要注意代码中：队列需要和交换机绑定2.4.3.消费者212345678910111213141516171819202122232425262728293031public class Recv2 &#123; private final static String QUEUE_NAME = "fanout_exchange_queue_2"; private final static String EXCHANGE_NAME = "fanout_exchange_test"; public static void main(String[] argv) throws Exception &#123; // 获取到连接 Connection connection = ConnectionUtil.getConnection(); // 获取通道 Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 绑定队列到交换机 channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, ""); // 定义队列的消费者 DefaultConsumer consumer = new DefaultConsumer(channel) &#123; // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用 @Override public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties, byte[] body) throws IOException &#123; // body 即消息体 String msg = new String(body); System.out.println(" [消费者2] received : " + msg + "!"); &#125; &#125;; // 监听队列，手动返回完成 channel.basicConsume(QUEUE_NAME, true, consumer); &#125;&#125;2.4.4.测试我们运行两个消费者，然后发送1条消息：2.5.订阅模型-Direct有选择性的接收消息在订阅模式中，生产者发布消息，所有消费者都可以获取所有消息。在路由模式中，我们将添加一个功能 - 我们将只能订阅一部分消息。 例如，我们只能将重要的错误消息引导到日志文件（以节省磁盘空间），同时仍然能够在控制台上打印所有日志消息。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。在Direct模型下，队列与交换机的绑定，不能是任意绑定了，而是要指定一个RoutingKey（路由key）消息的发送方在向Exchange发送消息时，也必须指定消息的routing key。P：生产者，向Exchange发送消息，发送消息时，会指定一个routing key。X：Exchange（交换机），接收生产者的消息，然后把消息递交给 与routing key完全匹配的队列C1：消费者，其所在队列指定了需要routing key 为 error 的消息C2：消费者，其所在队列指定了需要routing key 为 info、error、warning 的消息2.5.1.生产者此处我们模拟商品的增删改，发送消息的RoutingKey分别是：insert、update、delete1234567891011121314151617181920public class Send &#123; private final static String EXCHANGE_NAME = "direct_exchange_test"; public static void main(String[] argv) throws Exception &#123; // 获取到连接 Connection connection = ConnectionUtil.getConnection(); // 获取通道 Channel channel = connection.createChannel(); // 声明exchange，指定类型为direct channel.exchangeDeclare(EXCHANGE_NAME, "direct"); // 消息内容 String message = "商品新增了， id = 1001"; // 发送消息，并且指定routing key 为：insert ,代表新增商品 channel.basicPublish(EXCHANGE_NAME, "insert", null, message.getBytes()); System.out.println(" [商品服务：] Sent '" + message + "'"); channel.close(); connection.close(); &#125;&#125;2.5.2.消费者1我们此处假设消费者1只接收两种类型的消息：更新商品和删除商品。12345678910111213141516171819202122232425262728293031public class Recv &#123; private final static String QUEUE_NAME = "direct_exchange_queue_1"; private final static String EXCHANGE_NAME = "direct_exchange_test"; public static void main(String[] argv) throws Exception &#123; // 获取到连接 Connection connection = ConnectionUtil.getConnection(); // 获取通道 Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 绑定队列到交换机，同时指定需要订阅的routing key。假设此处需要update和delete消息 channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, "update"); channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, "delete"); // 定义队列的消费者 DefaultConsumer consumer = new DefaultConsumer(channel) &#123; // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用 @Override public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties, byte[] body) throws IOException &#123; // body 即消息体 String msg = new String(body); System.out.println(" [消费者1] received : " + msg + "!"); &#125; &#125;; // 监听队列，自动ACK channel.basicConsume(QUEUE_NAME, true, consumer); &#125;&#125;2.5.3.消费者2我们此处假设消费者2接收所有类型的消息：新增商品，更新商品和删除商品。1234567891011121314151617181920212223242526272829303132public class Recv2 &#123; private final static String QUEUE_NAME = "direct_exchange_queue_2"; private final static String EXCHANGE_NAME = "direct_exchange_test"; public static void main(String[] argv) throws Exception &#123; // 获取到连接 Connection connection = ConnectionUtil.getConnection(); // 获取通道 Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 绑定队列到交换机，同时指定需要订阅的routing key。订阅 insert、update、delete channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, "insert"); channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, "update"); channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, "delete"); // 定义队列的消费者 DefaultConsumer consumer = new DefaultConsumer(channel) &#123; // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用 @Override public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties, byte[] body) throws IOException &#123; // body 即消息体 String msg = new String(body); System.out.println(" [消费者2] received : " + msg + "!"); &#125; &#125;; // 监听队列，自动ACK channel.basicConsume(QUEUE_NAME, true, consumer); &#125;&#125;2.5.4.测试我们分别发送增、删、改的RoutingKey，发现结果：（一共是发了三个消息update、insert、delete这没都写出来，就显示一个insert，来说明具体问题）2.6.订阅模型-TopicTopic类型的Exchange与Direct相比，都是可以根据RoutingKey把消息路由到不同的队列。只不过Topic类型Exchange可以让队列在绑定Routing key 的时候使用通配符！Routingkey 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如： item.insert通配符规则：​ #：匹配一个或多个词​ *：匹配不多不少恰好1个词举例：​ audit.#：能够匹配audit.irs.corporate 或者 audit.irs​ audit.*：只能匹配audit.irs在这个例子中，我们将发送所有描述动物的消息。消息将使用由三个字（两个点）组成的routing key发送。路由关键字中的第一个单词将描述速度，第二个颜色和第三个种类：“..”。我们创建了三个绑定：Q1绑定了绑定键“* .orange.”，Q2绑定了“.*.rabbit”和“lazy.＃”。Q1匹配所有的橙色动物。Q2匹配关于兔子以及懒惰动物的消息。练习，生产者发送如下消息，会进入那个队列：quick.orange.rabbit à Q1 Q2lazy.orange.elephant à Q1 Q2quick.orange.fox à Q1lazy.pink.rabbit à Q2quick.brown.fox à 不匹配任意队列，被丢弃quick.orange.male.rabbit àorange à2.6.1.生产者使用topic类型的Exchange，发送消息的routing key有3种： item.isnert、item.update、item.delete：1234567891011121314151617181920public class Send &#123; private final static String EXCHANGE_NAME = "topic_exchange_test"; public static void main(String[] argv) throws Exception &#123; // 获取到连接 Connection connection = ConnectionUtil.getConnection(); // 获取通道 Channel channel = connection.createChannel(); // 声明exchange，指定类型为topic channel.exchangeDeclare(EXCHANGE_NAME, "topic"); // 消息内容 String message = "新增商品 : id = 1001"; // 发送消息，并且指定routing key 为：insert ,代表新增商品 channel.basicPublish(EXCHANGE_NAME, "item.insert", null, message.getBytes()); System.out.println(" [商品服务：] Sent '" + message + "'"); channel.close(); connection.close(); &#125;&#125;2.6.2.消费者1我们此处假设消费者1只接收两种类型的消息：更新商品和删除商品12345678910111213141516171819202122232425262728293031public class Recv &#123; private final static String QUEUE_NAME = "topic_exchange_queue_1"; private final static String EXCHANGE_NAME = "topic_exchange_test"; public static void main(String[] argv) throws Exception &#123; // 获取到连接 Connection connection = ConnectionUtil.getConnection(); // 获取通道 Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 绑定队列到交换机，同时指定需要订阅的routing key。需要 update、delete channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, "item.update"); channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, "item.delete"); // 定义队列的消费者 DefaultConsumer consumer = new DefaultConsumer(channel) &#123; // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用 @Override public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties, byte[] body) throws IOException &#123; // body 即消息体 String msg = new String(body); System.out.println(" [消费者1] received : " + msg + "!"); &#125; &#125;; // 监听队列，自动ACK channel.basicConsume(QUEUE_NAME, true, consumer); &#125;&#125;2.6.3.消费者2我们此处假设消费者2接收所有类型的消息：新增商品，更新商品和删除商品。123456789101112131415161718192021222324252627282930313233/** * 消费者2 */public class Recv2 &#123; private final static String QUEUE_NAME = "topic_exchange_queue_2"; private final static String EXCHANGE_NAME = "topic_exchange_test"; public static void main(String[] argv) throws Exception &#123; // 获取到连接 Connection connection = ConnectionUtil.getConnection(); // 获取通道 Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 绑定队列到交换机，同时指定需要订阅的routing key。订阅 insert、update、delete channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, "item.*"); // 定义队列的消费者 DefaultConsumer consumer = new DefaultConsumer(channel) &#123; // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用 @Override public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties, byte[] body) throws IOException &#123; // body 即消息体 String msg = new String(body); System.out.println(" [消费者2] received : " + msg + "!"); &#125; &#125;; // 监听队列，自动ACK channel.basicConsume(QUEUE_NAME, true, consumer); &#125;&#125;2.7.持久化如何避免消息丢失？1） 消费者的ACK机制。可以防止消费者丢失消息。2） 但是，如果在消费者消费之前，MQ就宕机了，消息就没了。是可以将消息进行持久化呢？要将消息持久化，前提是：队列、Exchange都持久化2.7.1.交换机持久化2.7.2.队列持久化2.7.3.消息持久化3.Spring AMQP3.1.简介Sprin有很多不同的项目，其中就有对AMQP的支持：Spring AMQP的页面：http://spring.io/projects/spring-amqp注意这里一段描述：​ Spring-amqp是对AMQP协议的抽象实现，而spring-rabbit 是对协议的具体实现，也是目前的唯一实现。底层使用的就是RabbitMQ。2.2.依赖和配置添加AMQP的启动器：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt;在application.yml中添加RabbitMQ地址：123456spring: rabbitmq: host: 192.168.56.101 username: leyou password: leyou virtual-host: /leyou2.3.监听者在SpringAmqp中，对消息的消费者进行了封装和抽象，一个普通的JavaBean中的普通方法，只要通过简单的注解，就可以成为一个消费者。123456789101112131415@Componentpublic class Listener &#123; @RabbitListener(bindings = @QueueBinding( value = @Queue(value = "spring.test.queue", durable = "true"), exchange = @Exchange( value = "spring.test.exchange", ignoreDeclarationExceptions = "true", type = ExchangeTypes.TOPIC ), key = &#123;"#.#"&#125;)) public void listen(String msg)&#123; System.out.println("接收到消息：" + msg); &#125;&#125;@Componet：类上的注解，注册到Spring容器@RabbitListener：方法上的注解，声明这个方法是一个消费者方法，需要指定下面的属性：bindings：指定绑定关系，可以有多个。值是@QueueBinding的数组。@QueueBinding包含下面属性：value：这个消费者关联的队列。值是@Queue，代表一个队列exchange：队列所绑定的交换机，值是@Exchange类型key：队列和交换机绑定的RoutingKey类似listen这样的方法在一个类中可以写多个，就代表多个消费者。2.4.AmqpTemplateSpring最擅长的事情就是封装，把他人的框架进行封装和整合。Spring为AMQP提供了统一的消息处理模板：AmqpTemplate，非常方便的发送消息，其发送方法：红框圈起来的是比较常用的3个方法，分别是：指定交换机、RoutingKey和消息体指定消息指定RoutingKey和消息，会向默认的交换机发送消息2.5.测试代码123456789101112131415@RunWith(SpringRunner.class)@SpringBootTest(classes = Application.class)public class MqDemo &#123; @Autowired private AmqpTemplate amqpTemplate; @Test public void testSend() throws InterruptedException &#123; String msg = "hello, Spring boot amqp"; this.amqpTemplate.convertAndSend("spring.test.exchange","a.b", msg); // 等待10秒后再结束 Thread.sleep(10000); &#125;&#125;运行后查看日志：3.项目改造接下来，我们就改造项目，实现搜索服务、商品静态页的数据同步。3.1.思路分析发送方：商品微服务什么时候发？当商品服务对商品进行写操作：增、删、改的时候，需要发送一条消息，通知其它服务。发送什么内容？对商品的增删改时其它服务可能需要新的商品数据，但是如果消息内容中包含全部商品信息，数据量太大，而且并不是每个服务都需要全部的信息。因此我们只发送商品id，其它服务可以根据id查询自己需要的信息。接收方：搜索微服务、静态页微服务接收消息后如何处理？搜索微服务：增/改：添加新的数据到索引库删：删除索引库数据静态页微服务：增：创建新的静态页删：删除原来的静态页改：创建新的静态页并删除原来的3.2.商品服务发送消息我们先在商品微服务leyou-item-service中实现发送消息。3.2.1.引入依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt;3.2.2.配置文件我们在application.yml中添加一些有关RabbitMQ的配置：123456789spring: rabbitmq: host: 192.168.56.101 username: leyou password: leyou virtual-host: /leyou template: exchange: leyou.item.exchange publisher-confirms: truetemplate：有关AmqpTemplate的配置retry：失败重试enabled：开启失败重试initial-interval：第一次重试的间隔时长max-interval：最长重试间隔，超过这个间隔将不再重试multiplier：下次重试间隔的倍数，此处是2即下次重试间隔是上次的2倍exchange：缺省的交换机名称，此处配置后，发送消息如果不指定交换机就会使用这个publisher-confirms：生产者确认机制，确保消息会正确发送，如果发送失败会有错误回执，从而触发重试3.2.3.改造GoodsService在GoodsService中封装一个发送消息到mq的方法：12345678private void sendMessage(Long id, String type)&#123; // 发送消息 try &#123; this.amqpTemplate.convertAndSend("item." + type, id); &#125; catch (Exception e) &#123; logger.error("&#123;&#125;商品消息发送异常，商品id：&#123;&#125;", type, id, e); &#125;&#125;这里没有指定交换机，因此默认发送到了配置中的：leyou.item.exchange注意：这里要把所有异常都try起来，不能让消息的发送影响到正常的业务逻辑然后在新增的时候调用：修改的时候调用：3.3.搜索服务接收消息搜索服务接收到消息后要做的事情：增：添加新的数据到索引库删：删除索引库数据改：修改索引库数据因为索引库的新增和修改方法是合二为一的，因此我们可以将这两类消息一同处理，删除另外处理。3.3.1.引入依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt;3.3.2.添加配置123456spring: rabbitmq: host: 192.168.56.101 username: leyou password: leyou virtual-host: /leyou这里只是接收消息而不发送，所以不用配置template相关内容。3.3.3.编写监听器代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Componentpublic class GoodsListener &#123; @Autowired private SearchService searchService; /** * 处理insert和update的消息 * * @param id * @throws Exception */ // *此处声明以后，会直接在rabbitMQ中创建对应的交换机与队列* @RabbitListener(bindings = @QueueBinding( value = @Queue(value = "leyou.create.index.queue", durable = "true"), exchange = @Exchange( value = "leyou.item.exchange", ignoreDeclarationExceptions = "true", type = ExchangeTypes.TOPIC), key = &#123;"item.insert", "item.update"&#125;)) public void listenCreate(Long id) throws Exception &#123; if (id == null) &#123; return; &#125; // 创建或更新索引 this.searchService.createIndex(id); &#125; /** * 处理delete的消息 * * @param id */ @RabbitListener(bindings = @QueueBinding( value = @Queue(value = "leyou.delete.index.queue", durable = "true"), exchange = @Exchange( value = "leyou.item.exchange", ignoreDeclarationExceptions = "true", type = ExchangeTypes.TOPIC), key = "item.delete")) public void listenDelete(Long id) &#123; if (id == null) &#123; return; &#125; // 删除索引 this.searchService.deleteIndex(id); &#125;&#125;3.3.4.编写创建和删除索引方法这里因为要创建和删除索引，我们需要在SearchService中拓展两个方法，创建和删除索引：12345678910111213public void createIndex(Long id) throws IOException &#123; Spu spu = this.goodsClient.querySpuById(id); // 构建商品 Goods goods = this.buildGoods(spu); // 保存数据到索引库 this.goodsRepository.save(goods);&#125;public void deleteIndex(Long id) &#123; this.goodsRepository.deleteById(id);&#125;创建索引的方法可以从之前导入数据的测试类中拷贝和改造。3.4.静态页服务接收消息商品静态页服务接收到消息后的处理：增：创建新的静态页删：删除原来的静态页改：创建新的静态页并删除原来的不过，我们编写的创建静态页的方法也具备覆盖以前页面的功能，因此：增和改的消息可以放在一个方法中处理，删除消息放在另一个方法处理。3.4.1.引入依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt;3.4.2.添加配置123456spring: rabbitmq: host: 192.168.56.101 username: leyou password: leyou virtual-host: /leyou这里只是接收消息而不发送，所以不用配置template相关内容。3.4.3.编写监听器代码：123456789101112131415161718192021222324252627282930313233343536@Componentpublic class GoodsListener &#123; @Autowired private GoodsHtmlService goodsHtmlService; @RabbitListener(bindings = @QueueBinding( value = @Queue(value = "leyou.create.web.queue", durable = "true"), exchange = @Exchange( value = "leyou.item.exchange", ignoreDeclarationExceptions = "true", type = ExchangeTypes.TOPIC), key = &#123;"item.insert", "item.update"&#125;)) public void listenCreate(Long id) throws Exception &#123; if (id == null) &#123; return; &#125; // 创建页面 goodsHtmlService.createHtml(id); &#125; @RabbitListener(bindings = @QueueBinding( value = @Queue(value = "leyou.delete.web.queue", durable = "true"), exchange = @Exchange( value = "leyou.item.exchange", ignoreDeclarationExceptions = "true", type = ExchangeTypes.TOPIC), key = "item.delete")) public void listenDelete(Long id) &#123; if (id == null) &#123; return; &#125; // 创建页面 goodsHtmlService.deleteHtml(id); &#125;&#125;3.4.4.添加删除页面方法1234public void deleteHtml(Long id) &#123; File file = new File("C:\\project\\nginx-1.14.0\\html\\item\\", id + ".html"); file.deleteOnExit();&#125;3.5.测试3.5.1.查看RabbitMQ控制台重新启动项目，并且登录RabbitMQ管理界面：http://192.168.56.101:15672可以看到，交换机已经创建出来了：队列也已经创建完毕：并且队列都已经绑定到交换机：]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mapreduce与yarn集群]]></title>
    <url>%2F2020%2F07%2F12%2Fmapreduce%E4%B8%8Eyarn%E9%9B%86%E7%BE%A4%2F</url>
    <content type="text"><![CDATA[​ 统计HDFS的/wordcount/input/a.txt文件中的每个单词出现的次数——wordcount。明白了一点：可以在任何地方运行程序，访问HDFS上的文件并进行统计运算，并且可以把统计的结果写回HDFS的结果文件中；但是，进一步思考：如果文件又多又大，用上面那个程序有什么弊端？慢！因为只有一台机器在进行运算处理！如何变得更快？核心思想：让我们的运算程序并行在多台机器上执行！这就引出要说的重点…..mapreduce程序应该是在很多机器上并行启动，而且先执行map task，当众多的maptask都处理完自己的数据后，还需要启动众多的reduce task，这个过程如果用用户自己手动调度不太现实，需要一个自动化的调度平台——hadoop中就为运行mapreduce之类的分布式运算程序开发了一个自动化调度平台——YARNyarn集群的配置yarn集群中有两个角色：主节点：Resource Manager 1台从节点：Node Manager N台Resource Manager一般安装在一台专门的机器上Node Manager应该与HDFS中的data node重叠在一起需要修改yarn-site.xml配置文件，hadoop安装目录下的etc下123456789配置文件的修改&lt;property&gt; &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt; &lt;value&gt;hdp-01&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt;&lt;/property&gt;123456789yarn集群的内存与cpu的修改&lt;property&gt; &lt;name&gt;yarn.nodemanager.resource.memory-mb&lt;/name&gt; &lt;value&gt;2048&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;yarn.nodemanager.resource.cpu-vcores&lt;/name&gt; &lt;value&gt;2&lt;/value&gt;&lt;/property&gt;然后将配置文件复制到其他的几个机器上，使用scp命令1scp yarn-site.xml hdf-02:$PWD // 复制文件到hdf-02的当前目录然后就可以批量的启动yarn的集群，命令如下1234启动：sbin/start-yarn.sh停止：sbin/stop-yarn.sh需要注意，要在hdf-01上启动。]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springCloud配置文件解释]]></title>
    <url>%2F2020%2F07%2F04%2FspringCloud%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A7%A3%E9%87%8A%2F</url>
    <content type="text"><![CDATA[1234instance: prefer-ip-address: true # 就可以将IP注册到Eureka Server上，而如果不配置就是机器的主机名 ip-address: 127.0.0.1 # 虽然prefer-ip-address 会自动获取ip注册到eureka中，自己再设置一下比较保险 instance-id: $&#123;spring.application.name&#125;:$&#123;server.port&#125;对instance-id的一些解释，默认情况下不添加instance-id 会显示 ：1$&#123;spring.cloud.client.ipAddress&#125;:$&#123;spring.application.name&#125;:$&#123;spring.application.instance_id:$&#123;server.port&#125;&#125;1$&#123;spring.application.name&#125;:$&#123;server.port&#125;配置上以后，可以适当的删减显示// TODO]]></content>
      <categories>
        <category>配置文件</category>
      </categories>
      <tags>
        <tag>配置文件</tag>
        <tag>springcloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[localthread的使用]]></title>
    <url>%2F2020%2F07%2F03%2Flocalthread%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[​ 在学习springCloud项目的时候，购物车模块中拿取用户信息的时候，使用拦截器从tonke中获得了用户的信息，放入到了localthread中，在本次的请求中（也就是在这个线程当中，随时从localthread中拿到的用户对象都是这个用户的信息）。详细的用法参照廖雪峰老师的文章。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@EnableConfigurationProperties(JwtProperties.class)public class LoginInterceptor extends HandlerInterceptorAdapter &#123; @Autowired private JwtProperties props; //定义一个线程域，存放登录的对象（通常是这么使用） private static final ThreadLocal&lt;UserInfo&gt; t1 = new ThreadLocal&lt;&gt;(); public LoginInterceptor() &#123; super(); &#125; public LoginInterceptor(JwtProperties props) &#123; this.props = props; &#125; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; //查询Token String token = CookieUtils.getCookieValue(request, props.getCookieName()); if (StringUtils.isBlank(token)) &#123; //用户未登录,返回401，拦截 response.setStatus(HttpStatus.UNAUTHORIZED.value()); return false; &#125; //用户已登录，获取用户信息 try &#123; UserInfo userInfo = JwtUtils.getUserInfo(props.getPublicKey(), token); //放入线程域中 t1.set(userInfo); return true; &#125; catch (Exception e) &#123; //抛出异常，未登录 response.setStatus(HttpStatus.UNAUTHORIZED.value()); return false; &#125; &#125; // 这个方法在respone信息传回以后执行，需要将当前线程线程域中的东西删除，以备接收下一个线程或他用户 @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; //过滤器完成后，从线程域中删除用户信息 t1.remove(); &#125; /** * 获取登陆用户（直接在需要的地方调用） * @return */ public static UserInfo getLoginUser() &#123; return t1.get(); &#125;&#125;目前也就想到这，后面想到了，再补充吧！]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[@ControllerAdvice注解的使用场景]]></title>
    <url>%2F2020%2F06%2F20%2FControllerAdvice%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%2F</url>
    <content type="text"><![CDATA[实际上，这是一个非常有用的注解，顾名思义，这是一个增强的 Controller。使用这个 Controller ，可以实现三个方面的功能：全局异常处理全局数据绑定全局数据预处理全局异常处理使用 @ControllerAdvice 实现全局异常处理，只需要定义类，添加该注解即可定义方式如下：12345678910@ControllerAdvicepublic class MyGlobalExceptionHandler &#123; @ExceptionHandler(Exception.class) public ModelAndView customException(Exception e) &#123; ModelAndView mv = new ModelAndView(); mv.addObject("message", e.getMessage()); mv.setViewName("myerror"); return mv; &#125;&#125;在该类中，可以定义多个方法，不同的方法处理不同的异常，例如专门处理空指针的方法、专门处理数组越界的方法…，也可以直接向上面代码一样，在一个方法中处理所有的异常信息。@ExceptionHandler 注解用来指明异常的处理类型，即如果这里指定为 NullpointerException，则数组越界异常就不会进到这个方法中来。全局数据绑定全局数据绑定功能可以用来做一些初始化的数据操作，我们可以将一些公共的数据定义在添加了 @ControllerAdvice 注解的类中，这样，在每一个 Controller 的接口中，就都能够访问导致这些数据。使用步骤，首先定义全局数据，如下：12345678910@ControllerAdvicepublic class MyGlobalExceptionHandler &#123; @ModelAttribute(name = "md") public Map&lt;String,Object&gt; mydata() &#123; HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put("age", 99); map.put("gender", "男"); return map; &#125;&#125;使用 @ModelAttribute 注解标记该方法的返回数据是一个全局数据，默认情况下，这个全局数据的 key 就是返回的变量名，value 就是方法返回值，当然开发者可以通过 @ModelAttribute 注解的 name 属性去重新指定 key。定义完成后，在任何一个Controller 的接口中，都可以获取到这里定义的数据：12345678910@RestControllerpublic class HelloController &#123; @GetMapping("/hello") public String hello(Model model) &#123; Map&lt;String, Object&gt; map = model.asMap(); System.out.println(map); int i = 1 / 0; return "hello controller advice"; &#125;&#125;全局数据预处理这个我觉得应该少有人用的吧，太怪了！考虑我有两个实体类，Book 和 Author，分别定义如下：12345678910public class Book &#123; private String name; private Long price; //getter/setter&#125;public class Author &#123; private String name; private Integer age; //getter/setter&#125;此时，如果我定义一个数据添加接口，如下：12345@PostMapping("/book")public void addBook(Book book, Author author) &#123; System.out.println(book); System.out.println(author);&#125;这个时候，添加操作就会有问题，因为两个实体类都有一个 name 属性，从前端传递时 ，无法区分。此时，通过 @ControllerAdvice 的全局数据预处理可以解决这个问题解决步骤如下:1.给接口中的变量取别名12345@PostMapping("/book")public void addBook(@ModelAttribute("b") Book book, @ModelAttribute("a") Author author) &#123; System.out.println(book); System.out.println(author);&#125;2.进行请求数据预处理在 @ControllerAdvice 标记的类中添加如下代码:12345678@InitBinder("b")public void b(WebDataBinder binder) &#123; binder.setFieldDefaultPrefix("b.");&#125;@InitBinder("a")public void a(WebDataBinder binder) &#123; binder.setFieldDefaultPrefix("a.");&#125;@InitBinder(“b”) 注解表示该方法用来处理和Book和相关的参数,在方法中,给参数添加一个 b 前缀,即请求参数要有b前缀.3.发送请求请求发送时,通过给不同对象的参数添加不同的前缀,可以实现参数的区分.参考了 博客园-江南一点雨 中这篇文章，也可以说是照搬过来了….]]></content>
      <categories>
        <category>spring</category>
        <category>注解</category>
      </categories>
      <tags>
        <tag>注解</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot下全局异常处理]]></title>
    <url>%2F2020%2F06%2F20%2Fspringboot%E4%B8%8B%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[想了一堆的废话，写了又删，就是一个破技术了，没那么多的废话，只写点干货得了。统一的异常处理，能少些点冗余得代码，本质上还是AOP在起作用。首先自定义异常继承于RuntimeException,代码中使用了lombok12345678// 自定义异常类型@Getterpublic class LyException extends RuntimeException&#123; private ExceptionEnum exceptionEnum; public LyException(ExceptionEnum exceptionEnum)&#123; this.exceptionEnum=exceptionEnum; &#125;&#125;统一异常处理12345678@Slf4j@ControllerAdvice // 注解的作用还挺多的，异常处理仅仅是一个，有时间再记一下public class BasicExceptionHandler &#123; @ExceptionHandler(LyException.class) // 绑定这个异常 public ResponseEntity&lt;ExceptionResult&gt; handleException(LyException e)&#123; return ResponseEntity.status(e.getExceptionEnum().value()).body(new ExceptionResult(e.getExceptionEnum())); // 返回给前端JSON格式数据，方便的写法 &#125;&#125;@ExceptionHandler 异常捕获的具有就近原则，程序中报NumberFormatException的时候，注解中分别修饰NumberFormatException 、Exception 当然优先进入NumberFormatException的方法中。异常处理方法体中封装的对象，更方便错误信息表示：1234567891011@Datapublic class ExceptionResult &#123; private int status; private String message; private long timestamp; public ExceptionResult(ExceptionEnum em)&#123; this.status=em.value(); this.message=em.message(); this.timestamp=System.currentTimeMillis(); &#125;&#125;异常信息的枚举类12345678910111213141516@NoArgsConstructor // LOMBOK的构造参数注解@AllArgsConstructorpublic enum ExceptionEnum &#123; DELETE_SPEC_GROUP_FAILED(500, "商品规格组删除失败"), UPDATE_SPEC_GROUP_FAILED(500, "商品规格组更新失败"), ; int value; String message; public int value()&#123; return this.value; &#125; public String message()&#123; return this.message; &#125;&#125;使用中，依赖添加好以后，直接可以再service中抛出,而不用手工捕获的异常12345678910111213141516171819202122232425262728293031323334@Servicepublic class CategoryServiceImpl implements CategoryService &#123; @Autowired private CategoryMapper categoryMapper; @Override public List&lt;Category&gt; queryCategoryByPid(Long pid) &#123; Category category = new Category(); category.setParentId(pid); List&lt;Category&gt; categoryList = categoryMapper.select(category); if (CollectionUtils.isEmpty(categoryList)) &#123; throw new LyException(ExceptionEnum.CATEGORY_NOT_FOUND); &#125; return categoryList; &#125; @Override public List&lt;Category&gt; queryCategoryByIds(List&lt;Long&gt; ids) &#123; return categoryMapper.selectByIdList(ids); &#125; @Override public List&lt;Category&gt; queryAllByCid3(Long id) &#123; Category c3 = categoryMapper.selectByPrimaryKey(id); Category c2 = categoryMapper.selectByPrimaryKey(c3.getParentId()); Category c1 = categoryMapper.selectByPrimaryKey(c2.getParentId()); List&lt;Category&gt; list = Arrays.asList(c1, c2, c3); if (CollectionUtils.isEmpty(list)) &#123; throw new LyException(ExceptionEnum.CATEGORY_NOT_FOUND); &#125; return list; &#125;&#125;补充：异常处理也可以这种形式12345678910111213// 放入ModelAndView中@ControllerAdvice class GlobalExceptionHandler &#123; public static final String DEFAULT_ERROR_VIEW = "error"; @ExceptionHandler(value = Exception.class) public ModelAndView defaultErrorHandler(HttpServletRequest req, Exception e) throws Exception &#123; ModelAndView mav = new ModelAndView(); mav.addObject("exception", e); mav.addObject("url", req.getRequestURL()); mav.setViewName(DEFAULT_ERROR_VIEW); return mav; &#125; &#125;亦可，其实本质上都是一样的，只为清楚明了一点12345678910111213@ControllerAdvicepublic class GlobalExceptionHandler &#123;@ExceptionHandler(value = MyException.class)@ResponseBodypublic ErrorInfo&lt;String&gt; jsonErrorHandler(HttpServletRequest req, MyException e) throws Exception &#123; ErrorInfo&lt;String&gt; r = new ErrorInfo&lt;&gt;(); r.setMessage(e.getMessage()); r.setCode(ErrorInfo.ERROR); r.setData("Some Data"); r.setUrl(req.getRequestURL().toString()); return r; &#125;&#125;]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HibernateValidator的使用]]></title>
    <url>%2F2020%2F06%2F19%2FHibernateValidator%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[​ 表单校验一般在前端一次后端一次，后端也无非是对传入的参数再做一次校验，近来发现了一个注解形式的后端表单校验工具Hibernate Validator先来了解一下其中部分注解的意思：Constraint详细信息@Valid被注释的元素是一个对象，需要检查此对象的所有字段值@Null被注释的元素必须为 null@NotNull被注释的元素必须不为 null@AssertTrue被注释的元素必须为 true@AssertFalse被注释的元素必须为 false@Min(value)被注释的元素必须是一个数字，其值必须大于等于指定的最小值@Max(value)被注释的元素必须是一个数字，其值必须小于等于指定的最大值@DecimalMin(value)被注释的元素必须是一个数字，其值必须大于等于指定的最小值@DecimalMax(value)被注释的元素必须是一个数字，其值必须小于等于指定的最大值@Size(max, min)被注释的元素的大小必须在指定的范围内@Digits (integer, fraction)被注释的元素必须是一个数字，其值必须在可接受的范围内@Past被注释的元素必须是一个过去的日期@Future被注释的元素必须是一个将来的日期@Pattern(value)被注释的元素必须符合指定的正则表达式@Email被注释的元素必须是电子邮箱地址@Length被注释的字符串的大小必须在指定的范围内@NotEmpty被注释的字符串的必须非空@Range被注释的元素必须在合适的范围内@NotBlank被注释的字符串的必须非空@URL(protocol=,host=, port=,regexp=, flags=)被注释的字符串必须是一个有效的url@CreditCardNumber被注释的字符串必须通过Luhn校验算法，银行卡，信用卡等号码一般都用Luhn计算合法性项目中依赖不能少：1234&lt;dependency&gt; &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;&lt;/dependency&gt;有了依赖才能够使用这个工具不是！12345678910111213141516171819202122@Table(name = "tb_user")public class User &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Length(min = 4, max = 30, message = "用户名只能在4~30位之间") private String username;// 用户名 @JsonIgnore // 在实体类向前台返回数据时用来忽略不想传递给前台的属性或接口 @Length(min = 4, max = 30, message = "用户名只能在4~30位之间") private String password;// 密码 @Pattern(regexp = "^1[35678]\\d&#123;9&#125;$", message = "手机号格式不正确") private String phone;// 电话 private Date created;// 创建时间 @JsonIgnore private String salt;// 密码的盐值&#125;在controller中只需要给User添加 @Valid注解即可。如图：其他注解，需要的时候再自行了解……]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>校验</tag>
        <tag>表单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java8新特性]]></title>
    <url>%2F2020%2F05%2F28%2Fjava8%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[​ java8的新特性lambda表达式出来好久了，虽然了解过但是从来没有正式用到工作中。这么好的东西，不拿到工作中装装逼，这不是白瞎了吗？本次只关注如何使用，要探究所以然的话，要等下次废话少说开整！！！！！！最先看到这个lambda表达式，是开启线程中用到的。java8以前的开启方式：1234567Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println("test"); &#125; &#125;);t1.start();java8中使用lambda表达式，简洁了许多：1234 Thread t2 = new Thread(() -&gt; &#123; System.out.println("这是一个新的线程"); &#125;);t2.start();1.Stream的各式使用1234// 生成10个随机数public static void main(String[] args) &#123; Stream.generate(Math::random).limit(10).forEach(System.out::println); &#125;12// 计算从0到9的和Integer reduce = Stream.iterate(0, s -&gt; s + 1).limit(10).reduce(0, (b, c) -&gt; (b + c));12// 输出0-9的10个数字Stream.iterate(0, s -&gt; s + 1).limit(10).forEach(System.out::println);12345// 对数组中的某一个属性排序 new("guo",17,false) 升序List&lt;User&gt; list = collect(); list.stream().sorted(Comparator.comparing(User::getAge)).forEach(user -&gt; System.out.println(user.getName()));// 降序list.stream().sorted(Comparator.comparing(User::getAge).reversed()).forEach(user -&gt; System.out.println(user.getName()));12// 排序只出现岁数最大的 用到了limitlist.stream().sorted(Comparator.comparing(User::getAge).reversed()).limit(1).forEach(user -&gt; System.out.println(user.getName()));12// 使用max求出最大值User user = list.stream().max(Comparator.comparing(User::getAge)).get(); System.out.println(user.getAge());12// 使用filter，获得年龄大于15岁的list.stream().filter(user -&gt; user.getAge()&gt;15).forEach(user -&gt; System.out.println(user.getName()));2.collect的各种收集12// 将list中的姓名，取出来放入一个list中list.stream().map(user -&gt; user.getName()).collect(Collectors.toList()).forEach(s -&gt; System.out.println(s));12// 将list中的姓名取出放入一个set中Set&lt;String&gt; collect = list.stream().map(user -&gt; user.getName()).collect(Collectors.toSet());12// 将list中的user的name取出来，组成一个map name为key，value为userMap&lt;String, User&gt; map = collect().stream().collect(Collectors.toMap(User::getName, Function.identity()));12// 将list中的user的name为key，age为valueMap&lt;String, Integer&gt; collect = list.stream().collect(toMap(User::getName, User::getAge));3.字符串的拼接123456// 将user中的name都拼接到一块String s = list.stream().map(user -&gt; user.getName()).reduce((name1, name2) -&gt; (name1+name2)).get();// 亦可以这么写（上面看着较为简洁，都lambda了，当然是怎么简洁怎么来了）String s = list.stream().map(user -&gt; user.getName()).reduce((name1, name2) -&gt; &#123; return name1 + name2; &#125;).get();4.分组操作12// 简单的分组操作，根据name进行分组的操作（name为key）Map&lt;String, List&lt;User&gt;&gt; collect = list.stream().collect(groupingBy(User::getName));123456// 升级版本的分组（多字段的分组）Map&lt;String, List&lt;User&gt;&gt; collect = list.stream().collect(groupingBy(user -&gt; feachGroup(user)));// 需要添加一个方法进行多字段的处理 private static String feachGroup(User user)&#123; return user.getName()+user.getAge();&#125;12// 根据name进行分组数量的统计Map&lt;String, Long&gt; collect = list.stream().collect(groupingBy(User::getName, counting()));5.map中foreach循环12Map&lt;String, User&gt; map = collect().stream().collect(Collectors.toMap(User::getName, Function.identity())); map.forEach((name,user)-&gt; System.out.println(name+user.getAge()));6.去重复12// list中的user对象去重复，需要重写user对象的equals与hashCode方法(方法在下面)list.stream().distinct().forEach(user-&gt; System.out.println(user.getName()));12345678910111213141516171819@Overridepublic boolean equals(Object obj) &#123; if (obj == null) &#123; return false; &#125; final User user = (User) obj; if (this == user) &#123; return true; &#125; else &#123; return (this.name.equals(user.getName()) &amp;&amp; this.isTrue == user.isTrue() &amp;&amp; this.age == user.getAge()); &#125;&#125;@Overridepublic int hashCode() &#123; int hashno = 7; hashno = 13 * hashno + (name == null ? 0 : name.hashCode()); return hashno;&#125;7.根据Boolean的状态进行分组1Map&lt;Boolean, List&lt;User&gt;&gt; collect = list.stream().collect(partitioningBy(User::isTrue));8.map的缓存读取之前将数据放入到map中，要判断存在与否然后才能决定放值还是取值，现在可以换一种方式了123456789101112Map&lt;String, String&gt; cathchmap = new HashMap&lt;&gt;();cathchmap.put("king","16");cathchmap.put("sala","16");cathchmap.put("loulou","16");/***********未测试，应该可以的**************/private void computeabsent(Map&lt;String, String&gt; cathchmap)&#123; cathchmap.computeIfAbsent("ning",this::redfromDb);&#125;private String redfromDb(String s) &#123; return "14";&#125;9.并行流有机会接着补充]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>新特新</tag>
        <tag>lambda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[联合主键下的mapper文件对数据库的批量更新]]></title>
    <url>%2F2020%2F05%2F11%2F%E8%81%94%E5%90%88%E4%B8%BB%E9%94%AE%E4%B8%8B%E7%9A%84mapper%E6%96%87%E4%BB%B6%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%89%B9%E9%87%8F%E6%9B%B4%E6%96%B0%2F</url>
    <content type="text"><![CDATA[​ 工作中使用到了联合主键，业务需求要在一系列的操作以后进行更新的操作，传统形式下的批量更新就有点不好用了。工作中的业务当然不能拿出来说明了，随便建立一张表，说明一下问题。表结构如下：内部数据如下：主要任务是要吧表中的 AMOUNT 字段修改批量修改，那一套的请求、分层、数据库、和mapper生成就省略了。随处都可以找到的。先上mapper批量更新的语句：1234567891011121314151617&lt;update id="updateByBatch" parameterType="java.util.List"&gt; update dcwt_test set AMOUNT = CASE &lt;foreach collection="list" item="item" index="index"&gt; // 此处看一下应该能理解的 when PARTID=#&#123;item.partid&#125; AND BRESQ=#&#123;item.bresq&#125; then #&#123;item.amount&#125; &lt;/foreach&gt; END where &lt;foreach collection="list" item="item" index="index"&gt; // 主要就是字符串拼接 OR (PARTID=#&#123;item.partid&#125; AND BRESQ=#&#123;item.bresq&#125;) &lt;if test="index!=list.size-1"&gt; // 还真没想到这玩意还能这么写的 OR &lt;/if&gt; &lt;/foreach&gt;&lt;/update&gt;更新结果：]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>工作中的问题</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springCloud项目3]]></title>
    <url>%2F2020%2F04%2F08%2FspringCloud%E9%A1%B9%E7%9B%AE3%2F</url>
    <content type="text"><![CDATA[0.学习目标会配置Hystix熔断会使用Feign进行远程调用能独立搭建Zuul网关能编写Zuul的拦截器1.Hystix1.1.简介Hystix，即熔断器。主页：https://github.com/Netflix/Hystrix/Hystix是Netflix开源的一个延迟和容错库，用于隔离访问远程服务、第三方库，防止出现级联失败。1.2.熔断器的工作机制：正常工作的情况下，客户端请求调用服务API接口：当有服务出现异常时，直接进行失败回滚，服务降级处理：当服务繁忙时，如果服务出现异常，不是粗暴的直接报错，而是返回一个友好的提示，虽然拒绝了用户的访问，但是会返回一个结果。这就好比去买鱼，平常超市买鱼会额外赠送杀鱼的服务。等到逢年过节，超时繁忙时，可能就不提供杀鱼服务了，这就是服务的降级。系统特别繁忙时，一些次要服务暂时中断，优先保证主要服务的畅通，一切资源优先让给主要服务来使用，在双十一、618时，京东天猫都会采用这样的策略。1.3.动手实践1.3.1.引入依赖首先在user-consumer中引入Hystix依赖：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;&lt;/dependency&gt;1.3.2.开启熔断1.3.2.改造消费者我们改造user-consumer，添加一个用来访问的user服务的DAO，并且声明一个失败时的回滚处理函数：1234567891011121314151617181920212223242526@Componentpublic class UserDao &#123; @Autowired private RestTemplate restTemplate; private static final Logger logger = LoggerFactory.getLogger(UserDao.class); @HystrixCommand(fallbackMethod = "queryUserByIdFallback") public User queryUserById(Long id)&#123; long begin = System.currentTimeMillis(); String url = "http://user-service/user/" + id; User user = this.restTemplate.getForObject(url, User.class); long end = System.currentTimeMillis(); // 记录访问用时： logger.info("访问用时：&#123;&#125;", end - begin); return user; &#125; public User queryUserByIdFallback(Long id)&#123; User user = new User(); user.setId(id); user.setName("用户信息查询出现异常！"); return user; &#125;&#125;@HystrixCommand(fallbackMethod=&quot;queryUserByIdFallback&quot;)：声明一个失败回滚处理函数queryUserByIdFallback，当queryUserById执行超时（默认是1000毫秒），就会执行fallback函数，返回错误提示。为了方便查看熔断的触发时机，我们记录请求访问时间。在原来的业务逻辑中调用这个DAO：123456789101112131415@Servicepublic class UserService &#123; @Autowired private UserDao userDao; public List&lt;User&gt; queryUserByIds(List&lt;Long&gt; ids) &#123; List&lt;User&gt; users = new ArrayList&lt;&gt;(); ids.forEach(id -&gt; &#123; // 我们测试多次查询， users.add(this.userDao.queryUserById(id)); &#125;); return users; &#125;&#125;1.3.3.改造服务提供者改造服务提供者，随机休眠一段时间，以触发熔断：123456789101112@Servicepublic class UserService &#123; @Autowired private UserMapper userMapper; public User queryById(Long id) throws InterruptedException &#123; // 为了演示超时现象，我们在这里然线程休眠,时间随机 0~2000毫秒 Thread.sleep(new Random().nextInt(2000)); return this.userMapper.selectByPrimaryKey(id); &#125;&#125;1.3.4.启动测试然后运行并查看日志：id为9、10、11的访问时间分别是：id为12的访问时间：因此，只有12是正常访问，其它都会触发熔断，我们来查看结果：1.3.5.优化虽然熔断实现了，但是我们的重试机制似乎没有生效，是这样吗？其实这里是因为我们的Ribbon超时时间设置的是1000ms:![1525666632542](1525666632542.png)而Hystix的超时时间默认也是1000ms，因此重试机制没有被触发，而是先触发了熔断。所以，Ribbon的超时时间一定要小于Hystix的超时时间。我们可以通过hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds来设置Hystrix超时时间。1234567hystrix: command: default: execution: isolation: thread: timeoutInMillisecond: 6000 # 设置hystrix的超时时间为6000ms2.Feign在前面的学习中，我们使用了Ribbon的负载均衡功能，大大简化了远程调用时的代码：12String baseUrl = "http://user-service/user/";User user = this.restTemplate.getForObject(baseUrl + id, User.class)如果就学到这里，你可能以后需要编写类似的大量重复代码，格式基本相同，无非参数不一样。有没有更优雅的方式，来对这些代码再次优化呢？这就是我们接下来要学的Feign的功能了。2.1.简介有道词典的英文解释：![1525662976679](1525662976679.png)为什么叫伪装？Feign可以把Rest的请求进行隐藏，伪装成类似SpringMVC的Controller一样。你不用再自己拼接url，拼接参数等等操作，一切都交给Feign去做。项目主页：https://github.com/OpenFeign/feign2.2.快速入门2.2.1.导入依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt;2.2.2.Feign的客户端123456@FeignClient("user-service")public interface UserFeignClient &#123; @GetMapping("/user/&#123;id&#125;") User queryUserById(@PathVariable("id") Long id);&#125;首先这是一个接口，Feign会通过动态代理，帮我们生成实现类。这点跟mybatis的mapper很像@FeignClient，声明这是一个Feign客户端，类似@Mapper注解。同时通过value属性指定服务名称接口中的定义方法，完全采用SpringMVC的注解，Feign会根据注解帮我们生成URL，并访问获取结果改造原来的调用逻辑，不再调用UserDao：123456789101112131415@Servicepublic class UserService &#123; @Autowired private UserFeignClient userFeignClient; public List&lt;User&gt; queryUserByIds(List&lt;Long&gt; ids) &#123; List&lt;User&gt; users = new ArrayList&lt;&gt;(); ids.forEach(id -&gt; &#123; // 我们测试多次查询， users.add(this.userFeignClient.queryUserById(id)); &#125;); return users; &#125;&#125;2.2.3.开启Feign功能我们在启动类上，添加注解，开启Feign功能123456789@SpringBootApplication@EnableDiscoveryClient@EnableHystrix@EnableFeignClients // 开启Feign功能public class UserConsumerDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(UserConsumerDemoApplication.class, args); &#125;&#125;你会发现RestTemplate的注册被我删除了。Feign中已经自动集成了Ribbon负载均衡，因此我们不需要自己定义RestTemplate了2.2.4.启动测试：访问接口：正常获取到了结果。2.3.负载均衡Feign中本身已经集成了Ribbon依赖和自动配置：![1525672070679](1525672070679.png)因此我们不需要额外引入依赖，也不需要再注册RestTemplate对象。另外，我们可以像上节课中讲的那样去配置Ribbon，可以通过ribbon.xx来进行全局配置。也可以通过服务名.ribbon.xx来对指定服务配置：1234567user-service: ribbon: ConnectTimeout: 250 # 连接超时时间(ms) ReadTimeout: 1000 # 通信超时时间(ms) OkToRetryOnAllOperations: true # 是否对所有操作重试 MaxAutoRetriesNextServer: 1 # 同一服务不同实例的重试次数 MaxAutoRetries: 1 # 同一实例的重试次数2.4.Hystix支持Feign默认也有对Hystix的集成：![1525672466192](1525672466192.png)只不过，默认情况下是关闭的。我们需要通过下面的参数来开启：123feign: hystrix: enabled: true # 开启Feign的熔断功能但是，Feign中的Fallback配置不像Ribbon中那样简单了。1）首先，我们要定义一个类，实现刚才编写的UserFeignClient，作为fallback的处理类12345678910@Componentpublic class UserFeignClientFallback implements UserFeignClient &#123; @Override public User queryUserById(Long id) &#123; User user = new User(); user.setId(id); user.setName("用户查询出现异常！"); return user; &#125;&#125;2）然后在UserFeignClient中，指定刚才编写的实现类123456@FeignClient(value = "user-service", fallback = UserFeignClientFallback.class)public interface UserFeignClient &#123; @GetMapping("/user/&#123;id&#125;") User queryUserById(@PathVariable("id") Long id);&#125;3）重启测试：我们关闭user-service服务，然后在页面访问：2.5.请求压缩(了解)Spring Cloud Feign 支持对请求和响应进行GZIP压缩，以减少通信过程中的性能损耗。通过下面的参数即可开启请求与响应的压缩功能：123456feign: compression: request: enabled: true # 开启请求压缩 response: enabled: true # 开启响应压缩同时，我们也可以对请求的数据类型，以及触发压缩的大小下限进行设置：123456feign: compression: request: enabled: true # 开启请求压缩 mime-types: text/html,application/xml,application/json # 设置压缩的数据类型 min-request-size: 2048 # 设置触发压缩的大小下限注：上面的数据类型、压缩大小下限均为默认值。2.6.日志级别(了解)前面讲过，通过logging.level.xx=debug来设置日志级别。然而这个对Fegin客户端而言不会产生效果。因为@FeignClient注解修改的客户端在被代理时，都会创建一个新的Fegin.Logger实例。我们需要额外指定这个日志的级别才可以。1）设置com.leyou包下的日志级别都为debug123logging: level: com.leyou: debug2）编写配置类，定义日志级别1234567@Configurationpublic class FeignConfig &#123; @Bean Logger.Level feignLoggerLevel()&#123; return Logger.Level.FULL; &#125;&#125;这里指定的Level级别是FULL，Feign支持4种级别：![1525674373507](1525674373507.png)NONE：不记录任何日志信息，这是默认值。BASIC：仅记录请求的方法，URL以及响应状态码和执行时间HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据。3）在FeignClient中指定配置类：12345@FeignClient(value = "user-service", fallback = UserFeignClientFallback.class, configuration = FeignConfig.class)public interface UserFeignClient &#123; @GetMapping("/user/&#123;id&#125;") User queryUserById(@PathVariable("id") Long id);&#125;4）重启项目，即可看到每次访问的日志：3.Zuul网关通过前面的学习，使用Spring Cloud实现微服务的架构基本成型，大致是这样的：我们使用Spring Cloud Netflix中的Eureka实现了服务注册中心以及服务注册与发现；而服务间通过Ribbon或Feign实现服务的消费以及均衡负载；通过Spring Cloud Config实现了应用多环境的外部化配置以及版本管理。为了使得服务集群更为健壮，使用Hystrix的融断机制来避免在微服务架构中个别服务出现异常时引起的故障蔓延。在该架构中，我们的服务集群包含：内部服务Service A和Service B，他们都会注册与订阅服务至Eureka Server，而Open Service是一个对外的服务，通过均衡负载公开至服务调用方。我们把焦点聚集在对外服务这块，直接暴露我们的服务地址，这样的实现是否合理，或者是否有更好的实现方式呢？先来说说这样架构需要做的一些事儿以及存在的不足：首先，破坏了服务无状态特点。为了保证对外服务的安全性，我们需要实现对服务访问的权限控制，而开放服务的权限控制机制将会贯穿并污染整个开放服务的业务逻辑，这会带来的最直接问题是，破坏了服务集群中REST API无状态的特点。从具体开发和测试的角度来说，在工作中除了要考虑实际的业务逻辑之外，还需要额外考虑对接口访问的控制处理。其次，无法直接复用既有接口。当我们需要对一个即有的集群内访问接口，实现外部服务访问时，我们不得不通过在原有接口上增加校验逻辑，或增加一个代理调用来实现权限控制，无法直接复用原有的接口。面对类似上面的问题，我们要如何解决呢？答案是：服务网关！为了解决上面这些问题，我们需要将权限控制这样的东西从我们的服务单元中抽离出去，而最适合这些逻辑的地方就是处于对外访问最前端的地方，我们需要一个更强大一些的均衡负载器的 服务网关。服务网关是微服务架构中一个不可或缺的部分。通过服务网关统一向外系统提供REST API的过程中，除了具备服务路由、均衡负载功能之外，它还具备了权限控制等功能。Spring Cloud Netflix中的Zuul就担任了这样的一个角色，为微服务架构提供了前门保护的作用，同时将权限控制这些较重的非业务逻辑内容迁移到服务路由层面，使得服务集群主体能够具备更高的可复用性和可测试性。3.1.简介官网：https://github.com/Netflix/zuul![1525675037152](1525675037152.png)Zuul：维基百科：电影《捉鬼敢死队》中的怪兽，Zuul，在纽约引发了巨大骚乱。事实上，在微服务架构中，Zuul就是守门的大Boss！一夫当关，万夫莫开！3.2.Zuul加入后的架构不管是来自于客户端（PC或移动端）的请求，还是服务内部调用。一切对服务的请求都会经过Zuul这个网关，然后再由网关来实现 鉴权、动态路由等等操作。Zuul就是我们服务的统一入口。3.3.快速入门3.3.1.新建工程填写基本信息：添加Zuul依赖：3.3.2.编写启动类通过@EnableZuulProxy注解开启Zuul的功能：12345678@SpringBootApplication@EnableZuulProxy // 开启Zuul的网关功能public class ZuulDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ZuulDemoApplication.class, args); &#125;&#125;3.3.3.编写配置12345server: port: 10010 #服务端口spring: application: name: api-gateway #指定服务名3.3.4.编写路由规则我们需要用Zuul来代理user-service服务，先看一下控制面板中的服务状态：ip为：127.0.0.1端口为：8081映射规则：12345zuul: routes: user-service: # 这里是路由id，随意写 path: /user-service/** # 这里是映射路径 url: http://127.0.0.1:8081 # 映射路径对应的实际url地址我们将符合path 规则的一切请求，都代理到 url参数指定的地址本例中，我们将 /user-service/**开头的请求，代理到http://127.0.0.1:80813.3.5.启动测试：访问的路径中需要加上配置规则的映射路径，我们访问：http://127.0.0.1:8081/user-service/user/10![1525677046705](1525677046705.png)3.4.面向服务的路由在刚才的路由规则中，我们把路径对应的服务地址写死了！如果同一服务有多个实例的话，这样做显然就不合理了。我们应该根据服务的名称，去Eureka注册中心查找 服务对应的所有实例列表，然后进行动态路由才对！3.4.1.添加Eureka客户端依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;3.4.2.开启Eureka客户端发现功能123456789@SpringBootApplication@EnableZuulProxy // 开启Zuul的网关功能@EnableDiscoveryClientpublic class ZuulDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ZuulDemoApplication.class, args); &#125;&#125;3.4.3.添加Eureka配置，获取服务信息12345678eureka: client: registry-fetch-interval-seconds: 5 # 获取服务列表的周期：5s service-url: defaultZone: http://127.0.0.1:10086/eureka instance: prefer-ip-address: true ip-address: 127.0.0.13.4.4.修改映射配置，通过服务名称获取因为已经有了Eureka客户端，我们可以从Eureka获取服务的地址信息，因此映射时无需指定IP地址，而是通过服务名称来访问，而且Zuul已经集成了Ribbon的负载均衡功能。12345zuul: routes: user-service: # 这里是路由id，随意写 path: /user-service/** # 这里是映射路径 serviceId: user-service # 指定服务名称3.4.5.启动测试再次启动，这次Zuul进行代理时，会利用Ribbon进行负载均衡访问：![1525677821212](1525677821212.png)日志中可以看到使用了负载均衡器：3.5.简化的路由配置在刚才的配置中，我们的规则是这样的：zuul.routes.&lt;route&gt;.path=/xxx/**： 来指定映射路径。&lt;route&gt;是自定义的路由名zuul.routes.&lt;route&gt;.serviceId=/user-service：来指定服务名。而大多数情况下，我们的&lt;route&gt;路由名称往往和 服务名会写成一样的。因此Zuul就提供了一种简化的配置语法：zuul.routes.&lt;serviceId&gt;=&lt;path&gt;比方说上面我们关于user-service的配置可以简化为一条：123zuul: routes: user-service: /user-service/** # 这里是映射路径省去了对服务名称的配置。3.6.默认的路由规则在使用Zuul的过程中，上面讲述的规则已经大大的简化了配置项。但是当服务较多时，配置也是比较繁琐的。因此Zuul就指定了默认的路由规则：默认情况下，一切服务的映射路径就是服务名本身。例如服务名为：user-service，则默认的映射路径就是：/user-service/**也就是说，刚才的映射规则我们完全不配置也是OK的，不信就试试看。3.7.路由前缀配置示例：123456zuul: prefix: /api # 添加路由前缀 routes: user-service: # 这里是路由id，随意写 path: /user-service/** # 这里是映射路径 service-id: user-service # 指定服务名称我们通过zuul.prefix=/api来指定了路由的前缀，这样在发起请求时，路径就要以/api开头。路径/api/user-service/user/1将会被代理到/user-service/user/13.8.过滤器Zuul作为网关的其中一个重要功能，就是实现请求的鉴权。而这个动作我们往往是通过Zuul提供的过滤器来实现的。3.8.1.ZuulFilterZuulFilter是过滤器的顶级父类。在这里我们看一下其中定义的4个最重要的方法：12345678910public abstract ZuulFilter implements IZuulFilter&#123; abstract public String filterType(); abstract public int filterOrder(); boolean shouldFilter();// 来自IZuulFilter Object run() throws ZuulException;// IZuulFilter&#125;shouldFilter：返回一个Boolean值，判断该过滤器是否需要执行。返回true执行，返回false不执行。run：过滤器的具体业务逻辑。filterType：返回字符串，代表过滤器的类型。包含以下4种：pre：请求在被路由之前执行routing：在路由请求时调用post：在routing和errror过滤器之后调用error：处理请求时发生错误调用filterOrder：通过返回的int值来定义过滤器的执行顺序，数字越小优先级越高。3.8.2.过滤器执行生命周期：这张是Zuul官网提供的请求生命周期图，清晰的表现了一个请求在各个过滤器的执行顺序。![1525681866862](1525681866862.png)正常流程：请求到达首先会经过pre类型过滤器，而后到达routing类型，进行路由，请求就到达真正的服务提供者，执行请求，返回结果后，会到达post过滤器。而后返回响应。异常流程：整个过程中，pre或者routing过滤器出现异常，都会直接进入error过滤器，再error处理完毕后，会将请求交给POST过滤器，最后返回给用户。如果是error过滤器自己出现异常，最终也会进入POST过滤器，而后返回。如果是POST过滤器出现异常，会跳转到error过滤器，但是与pre和routing不同的时，请求不会再到达POST过滤器了。所有内置过滤器列表：![1525682427811](1525682427811.png)3.8.3.使用场景场景非常多：请求鉴权：一般放在pre类型，如果发现没有访问权限，直接就拦截了异常处理：一般会在error类型和post类型过滤器中结合来处理。服务调用时长统计：pre和post结合使用。3.9.自定义过滤器接下来我们来自定义一个过滤器，模拟一个登录的校验。基本逻辑：如果请求中有access-token参数，则认为请求有效，放行。3.9.1.定义过滤器类12345678910111213141516171819202122232425262728293031323334353637383940@Componentpublic class LoginFilter extends ZuulFilter&#123; @Override public String filterType() &#123; // 登录校验，肯定是在前置拦截 return "pre"; &#125; @Override public int filterOrder() &#123; // 顺序设置为1 return 1; &#125; @Override public boolean shouldFilter() &#123; // 返回true，代表过滤器生效。 return true; &#125; @Override public Object run() throws ZuulException &#123; // 登录校验逻辑。 // 1）获取Zuul提供的请求上下文对象 RequestContext ctx = RequestContext.getCurrentContext(); // 2) 从上下文中获取request对象 HttpServletRequest req = ctx.getRequest(); // 3) 从请求中获取token String token = req.getParameter("access-token"); // 4) 判断 if(token == null || "".equals(token.trim()))&#123; // 没有token，登录校验失败，拦截 ctx.setSendZuulResponse(false); // 返回401状态码。也可以考虑重定向到登录页。 ctx.setResponseStatusCode(HttpStatus.UNAUTHORIZED.value()); &#125; // 校验通过，可以考虑把用户信息放入上下文，继续向后执行 return null; &#125;&#125;3.9.2.测试没有token参数时，访问失败：![1525683285697](1525683285697.png)添加token参数后：![1525683354113](1525683354113.png)3.10.负载均衡和熔断Zuul中默认就已经集成了Ribbon负载均衡和Hystix熔断机制。但是所有的超时策略都是走的默认值，比如熔断超时时间只有1S，很容易就触发了。因此建议我们手动进行配置：123456789101112131415zuul: retryable: trueribbon: ConnectTimeout: 250 # 连接超时时间(ms) ReadTimeout: 2000 # 通信超时时间(ms) OkToRetryOnAllOperations: true # 是否对所有操作重试 MaxAutoRetriesNextServer: 2 # 同一服务不同实例的重试次数 MaxAutoRetries: 1 # 同一实例的重试次数hystrix: command: default: execution: isolation: thread: timeoutInMillisecond: 6000 # 熔断超时时长：6000ms]]></content>
      <categories>
        <category>springCloud实战</category>
      </categories>
      <tags>
        <tag>springCloud</tag>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springCloud项目2]]></title>
    <url>%2F2020%2F04%2F08%2FspringCloud%E9%A1%B9%E7%9B%AE2%2F</url>
    <content type="text"><![CDATA[0.学习目标了解系统架构的演变了解RPC与Http的区别掌握HttpClient的简单使用知道什么是SpringCloud独立搭建Eureka注册中心独立配置Robbin负载均衡-Xms128m -Xmx128m1.系统架构演变随着互联网的发展，网站应用的规模不断扩大。需求的激增，带来的是技术上的压力。系统架构也因此也不断的演进、升级、迭代。从单一应用，到垂直拆分，到分布式服务，到SOA，以及现在火热的微服务架构，还有在Google带领下来势汹涌的Service Mesh。我们到底是该乘坐微服务的船只驶向远方，还是偏安一隅得过且过？其实生活不止眼前的苟且，还有诗和远方。所以我们今天就回顾历史，看一看系统架构演变的历程；把握现在，学习现在最火的技术架构；展望未来，争取成为一名优秀的Java工程师。1.1. 集中式架构当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是影响项目开发的关键。存在的问题：代码耦合，开发维护困难无法针对不同模块进行针对性优化无法水平扩展单点容错率低，并发能力差1.2.垂直拆分当访问量逐渐增大，单一应用无法满足需求，此时为了应对更高的并发和业务需求，我们根据业务功能对系统进行拆分：优点：系统拆分实现了流量分担，解决了并发问题可以针对不同模块进行优化方便水平扩展，负载均衡，容错率提高缺点：系统间相互独立，会有很多重复开发工作，影响开发效率1.3.分布式服务当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式调用是关键。优点：将基础服务进行了抽取，系统间相互调用，提高了代码复用和开发效率缺点：系统间耦合度变高，调用关系错综复杂，难以维护1.4.服务治理（SOA）当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键以前出现了什么问题？服务越来越多，需要管理每个服务的地址调用关系错综复杂，难以理清依赖关系服务过多，服务状态难以管理，无法根据服务情况动态管理服务治理要做什么？服务注册中心，实现服务自动注册和发现，无需人为记录服务地址服务自动订阅，服务列表自动推送，服务调用透明化，无需关心依赖关系动态监控服务状态监控报告，人为控制服务状态缺点：服务间会有依赖关系，一旦某个环节出错会影响较大服务关系复杂，运维、测试部署困难，不符合DevOps思想1.5.微服务前面说的SOA，英文翻译过来是面向服务。微服务，似乎也是服务，都是对系统进行拆分。因此两者非常容易混淆，但其实缺有一些差别：微服务的特点：单一职责：微服务中每一个服务都对应唯一的业务能力，做到单一职责微：微服务的服务拆分粒度很小，例如一个用户管理就可以作为一个服务。每个服务虽小，但“五脏俱全”。面向服务：面向服务是说每个服务都要对外暴露服务接口API。并不关心服务的技术实现，做到与平台和语言无关，也不限定用什么技术实现，只要提供Rest的接口即可。自治：自治是说服务间互相独立，互不干扰团队独立：每个服务都是一个独立的开发团队，人数不能过多。技术独立：因为是面向服务，提供Rest接口，使用什么技术没有别人干涉前后端分离：采用前后端分离开发，提供统一Rest接口，后端不用再为PC、移动段开发不同接口数据库分离：每个服务都使用自己的数据源部署独立，服务间虽然有调用，但要做到服务重启不影响其它服务。有利于持续集成和持续交付。每个服务都是独立的组件，可复用，可替换，降低耦合，易维护微服务结构图：2.远程调用方式无论是微服务还是SOA，都面临着服务间的远程调用。那么服务间的远程调用方式有哪些呢？常见的远程调用方式有以下几种：RPC：Remote Produce Call远程过程调用，类似的还有RMI。自定义数据格式，基于原生TCP通信，速度快，效率高。早期的webservice，现在热门的dubbo，都是RPC的典型Http：http其实是一种网络传输协议，基于TCP，规定了数据传输的格式。现在客户端浏览器与服务端通信基本都是采用Http协议。也可以用来进行远程服务调用。缺点是消息封装臃肿。现在热门的Rest风格，就可以通过http协议来实现。2.1.认识RPCRPC，即 Remote Procedure Call（远程过程调用），是一个计算机通信协议。 该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。说得通俗一点就是：A计算机提供一个服务，B计算机可以像调用本地服务那样调用A计算机的服务。通过上面的概念，我们可以知道，实现RPC主要是做到两点：实现远程调用其他计算机的服务要实现远程调用，肯定是通过网络传输数据。A程序提供服务，B程序通过网络将请求参数传递给A，A本地执行后得到结果，再将结果返回给B程序。这里需要关注的有两点：1）采用何种网络通讯协议？现在比较流行的RPC框架，都会采用TCP作为底层传输协议2）数据传输的格式怎样？两个程序进行通讯，必须约定好数据传输格式。就好比两个人聊天，要用同一种语言，否则无法沟通。所以，我们必须定义好请求和响应的格式。另外，数据在网路中传输需要进行序列化，所以还需要约定统一的序列化的方式。像调用本地服务一样调用远程服务如果仅仅是远程调用，还不算是RPC，因为RPC强调的是过程调用，调用的过程对用户而言是应该是透明的，用户不应该关心调用的细节，可以像调用本地服务一样调用远程服务。所以RPC一定要对调用的过程进行封装RPC调用流程图：想要了解详细的RPC实现，给大家推荐一篇文章：自己动手实现RPC2.2.认识HttpHttp协议：超文本传输协议，是一种应用层协议。规定了网络传输的请求格式、响应格式、资源定位和操作的方式等。但是底层采用什么网络传输协议，并没有规定，不过现在都是采用TCP协议作为底层传输协议。说到这里，大家可能觉得，Http与RPC的远程调用非常像，都是按照某种规定好的数据格式进行网络通信，有请求，有响应。没错，在这点来看，两者非常相似，但是还是有一些细微差别。RPC并没有规定数据传输格式，这个格式可以任意指定，不同的RPC协议，数据格式不一定相同。Http中还定义了资源定位的路径，RPC中并不需要最重要的一点：RPC需要满足像调用本地服务一样调用远程服务，也就是对调用过程在API层面进行封装。Http协议没有这样的要求，因此请求、响应等细节需要我们自己去实现。优点：RPC方式更加透明，对用户更方便。Http方式更灵活，没有规定API和语言，跨语言、跨平台缺点：RPC方式需要在API层面进行封装，限制了开发的语言环境。例如我们通过浏览器访问网站，就是通过Http协议。只不过浏览器把请求封装，发起请求以及接收响应，解析响应的事情都帮我们做了。如果是不通过浏览器，那么这些事情都需要自己去完成。2.3.如何选择？既然两种方式都可以实现远程调用，我们该如何选择呢？速度来看，RPC要比http更快，虽然底层都是TCP，但是http协议的信息往往比较臃肿，不过可以采用gzip压缩。难度来看，RPC实现较为复杂，http相对比较简单灵活性来看，http更胜一筹，因为它不关心实现细节，跨平台、跨语言。因此，两者都有不同的使用场景：如果对效率要求更高，并且开发过程使用统一的技术栈，那么用RPC还是不错的。如果需要更加灵活，跨语言、跨平台，显然http更合适那么我们该怎么选择呢？微服务，更加强调的是独立、自治、灵活。而RPC方式的限制较多，因此微服务框架中，一般都会采用基于Http的Rest风格服务。3.Http客户端工具既然微服务选择了Http，那么我们就需要考虑自己来实现对请求和响应的处理。不过开源世界已经有很多的http客户端工具，能够帮助我们做这些事情，例如：HttpClientOKHttpURLConnection接下来，我们就一起了解一款比较流行的客户端工具：HttpClient3.1.HttpClient3.1.1.介绍HttpClient是Apache公司的产品，是Http Components下的一个组件。官网地址：http://hc.apache.org/index.html特点：基于标准、纯净的Java语言。实现了Http1.0和Http1.1以可扩展的面向对象的结构实现了Http全部的方法（GET, POST, PUT, DELETE, HEAD, OPTIONS, and TRACE）支持HTTPS协议。通过Http代理建立透明的连接。自动处理Set-Cookie中的Cookie。3.1.2.使用我们导入课前资料提供的demo工程：《http-demo》发起get请求：123456@Testpublic void testGet() throws IOException &#123; HttpGet request = new HttpGet("http://www.baidu.com"); String response = this.httpClient.execute(request, new BasicResponseHandler()); System.out.println(response);&#125;发起Post请求：12345678@Testpublic void testPost() throws IOException &#123; HttpPost request = new HttpPost("http://www.oschina.net/"); request.setHeader("User-Agent", "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36"); String response = this.httpClient.execute(request, new BasicResponseHandler()); System.out.println(response);&#125;尝试访问昨天编写的接口：http://localhost/hello这个接口返回一个User对象123456@Testpublic void testGetPojo() throws IOException &#123; HttpGet request = new HttpGet("http://localhost/hello"); String response = this.httpClient.execute(request, new BasicResponseHandler()); System.out.println(response);&#125;我们实际得到的是一个json字符串：123456789101112&#123; "id": 8, "userName": "liuyan", "password": "123456", "name": "柳岩", "age": 21, "sex": 2, "birthday": "1995-08-07T16:00:00.000+0000", "created": "2014-09-20T03:41:15.000+0000", "updated": "2014-09-20T03:41:15.000+0000", "note": "柳岩同学在传智播客学表演"&#125;如果想要得到对象，我们还需要手动进行Json反序列化，这一点比较麻烦。3.1.3.Json转换工具HttpClient请求数据后是json字符串，需要我们自己把Json字符串反序列化为对象，我们会使用JacksonJson工具来实现。JacksonJson是SpringMVC内置的json处理工具，其中有一个ObjectMapper类，可以方便的实现对json的处理：对象转json12345678910111213// json处理工具 private ObjectMapper mapper = new ObjectMapper(); @Test public void testJson() throws JsonProcessingException &#123; User user = new User(); user.setId(8L); user.setAge(21); user.setName("柳岩"); user.setUserName("liuyan"); // 序列化 String json = mapper.writeValueAsString(user); System.out.println("json = " + json); &#125;结果：json转普通对象12345678910111213141516// json处理工具private ObjectMapper mapper = new ObjectMapper();@Testpublic void testJson() throws IOException &#123; User user = new User(); user.setId(8L); user.setAge(21); user.setName("柳岩"); user.setUserName("liuyan"); // 序列化 String json = mapper.writeValueAsString(user); // 反序列化，接收两个参数：json数据，反序列化的目标类字节码 User result = mapper.readValue(json, User.class); System.out.println("result = " + result);&#125;结果：json转集合json转集合比较麻烦，因为你无法同时把集合的class和元素的class同时传递到一个参数。因此Jackson做了一个类型工厂，用来解决这个问题：12345678910111213141516171819// json处理工具private ObjectMapper mapper = new ObjectMapper();@Testpublic void testJson() throws IOException &#123; User user = new User(); user.setId(8L); user.setAge(21); user.setName("柳岩"); user.setUserName("liuyan"); // 序列化,得到对象集合的json字符串 String json = mapper.writeValueAsString(Arrays.asList(user, user)); // 反序列化，接收两个参数：json数据，反序列化的目标类字节码 List&lt;User&gt; users = mapper.readValue(json, mapper.getTypeFactory().constructCollectionType(List.class, User.class)); for (User u : users) &#123; System.out.println("u = " + u); &#125;&#125;结果：json转任意复杂类型当对象泛型关系复杂时，类型工厂也不好使了。这个时候Jackson提供了TypeReference来接收类型泛型，然后底层通过反射来获取泛型上的具体类型。实现数据转换。12345678910111213141516171819// json处理工具private ObjectMapper mapper = new ObjectMapper();@Testpublic void testJson() throws IOException &#123; User user = new User(); user.setId(8L); user.setAge(21); user.setName("柳岩"); user.setUserName("liuyan"); // 序列化,得到对象集合的json字符串 String json = mapper.writeValueAsString(Arrays.asList(user, user)); // 反序列化，接收两个参数：json数据，反序列化的目标类字节码 List&lt;User&gt; users = mapper.readValue(json, new TypeReference&lt;List&lt;User&gt;&gt;()&#123;&#125;); for (User u : users) &#123; System.out.println("u = " + u); &#125;&#125;结果：3.3.Spring的RestTemplateSpring提供了一个RestTemplate模板工具类，对基于Http的客户端进行了封装，并且实现了对象与json的序列化和反序列化，非常方便。RestTemplate并没有限定Http的客户端类型，而是进行了抽象，目前常用的3种都有支持：HttpClientOkHttpJDK原生的URLConnection（默认的）首先在项目中注册一个RestTemplate对象，可以在启动类位置注册：12345678910111213@SpringBootApplicationpublic class HttpDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(HttpDemoApplication.class, args); &#125; @Bean public RestTemplate restTemplate() &#123; // 默认的RestTemplate，底层是走JDK的URLConnection方式。 return new RestTemplate(); &#125;&#125;在测试类中直接@Autowired注入：12345678910111213@RunWith(SpringRunner.class)@SpringBootTest(classes = HttpDemoApplication.class)public class HttpDemoApplicationTests &#123; @Autowired private RestTemplate restTemplate; @Test public void httpGet() &#123; User user = this.restTemplate.getForObject("http://localhost/hello", User.class); System.out.println(user); &#125;&#125;通过RestTemplate的getForObject()方法，传递url地址及实体类的字节码，RestTemplate会自动发起请求，接收响应，并且帮我们对响应结果进行反序列化。学习完了Http客户端工具，接下来就可以正式学习微服务了。4.初始SpringCloud微服务是一种架构方式，最终肯定需要技术架构去实施。微服务的实现方式很多，但是最火的莫过于Spring Cloud了。为什么？后台硬：作为Spring家族的一员，有整个Spring全家桶靠山，背景十分强大。技术强：Spring作为Java领域的前辈，可以说是功力深厚。有强力的技术团队支撑，一般人还真比不了群众基础好：可以说大多数程序员的成长都伴随着Spring框架，试问：现在有几家公司开发不用Spring？SpringCloud与Spring的各个框架无缝整合，对大家来说一切都是熟悉的配方，熟悉的味道。使用方便：相信大家都体会到了SpringBoot给我们开发带来的便利，而SpringCloud完全支持SpringBoot的开发，用很少的配置就能完成微服务框架的搭建4.1.简介SpringCloud是Spring旗下的项目之一，官网地址：http://projects.spring.io/spring-cloud/Spring最擅长的就是集成，把世界上最好的框架拿过来，集成到自己的项目中。SpringCloud也是一样，它将现在非常流行的一些技术整合到一起，实现了诸如：配置管理，服务发现，智能路由，负载均衡，熔断器，控制总线，集群状态等等功能。其主要涉及的组件包括：netflixEureka：注册中心Zuul：服务网关Ribbon：负载均衡Feign：服务调用Hystix：熔断器以上只是其中一部分，架构图：4.2.版本SpringCloud的版本命名比较特殊，因为它不是一个组件，而是许多组件的集合，它的命名是以A到Z的为首字母的一些单词组成：我们在项目中，会是以Finchley的版本。其中包含的组件，也都有各自的版本，如下表：ComponentEdgware.SR3Finchley.RC1Finchley.BUILD-SNAPSHOTspring-cloud-aws1.2.2.RELEASE2.0.0.RC12.0.0.BUILD-SNAPSHOTspring-cloud-bus1.3.2.RELEASE2.0.0.RC12.0.0.BUILD-SNAPSHOTspring-cloud-cli1.4.1.RELEASE2.0.0.RC12.0.0.BUILD-SNAPSHOTspring-cloud-commons1.3.3.RELEASE2.0.0.RC12.0.0.BUILD-SNAPSHOTspring-cloud-contract1.2.4.RELEASE2.0.0.RC12.0.0.BUILD-SNAPSHOTspring-cloud-config1.4.3.RELEASE2.0.0.RC12.0.0.BUILD-SNAPSHOTspring-cloud-netflix1.4.4.RELEASE2.0.0.RC12.0.0.BUILD-SNAPSHOTspring-cloud-security1.2.2.RELEASE2.0.0.RC12.0.0.BUILD-SNAPSHOTspring-cloud-cloudfoundry1.1.1.RELEASE2.0.0.RC12.0.0.BUILD-SNAPSHOTspring-cloud-consul1.3.3.RELEASE2.0.0.RC12.0.0.BUILD-SNAPSHOTspring-cloud-sleuth1.3.3.RELEASE2.0.0.RC12.0.0.BUILD-SNAPSHOTspring-cloud-streamDitmars.SR3Elmhurst.RELEASEElmhurst.BUILD-SNAPSHOTspring-cloud-zookeeper1.2.1.RELEASE2.0.0.RC12.0.0.BUILD-SNAPSHOTspring-boot1.5.10.RELEASE2.0.1.RELEASE2.0.0.BUILD-SNAPSHOTspring-cloud-task1.2.2.RELEASE2.0.0.RC12.0.0.RELEASEspring-cloud-vault1.1.0.RELEASE2.0.0.RC12.0.0.BUILD-SNAPSHOTspring-cloud-gateway1.0.1.RELEASE2.0.0.RC12.0.0.BUILD-SNAPSHOTspring-cloud-openfeign2.0.0.RC12.0.0.BUILD-SNAPSHOT接下来，我们就一一学习SpringCloud中的重要组件。5.微服务场景模拟首先，我们需要模拟一个服务调用的场景。方便后面学习微服务架构5.1.服务提供者我们新建一个项目，对外提供查询用户的服务。5.1.1.Spring脚手架创建工程借助于Spring提供的快速搭建工具：填写项目信息：添加web依赖：添加mybatis依赖：填写项目位置：生成的项目结构：依赖也已经全部自动引入：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.demo&lt;/groupId&gt; &lt;artifactId&gt;user-service-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;user-service-demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt;当然，因为要使用通用mapper，所以我们需要手动加一条依赖：12345&lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt;&lt;/dependency&gt;非常快捷啊！5.1.2.编写代码添加一个对外查询的接口：123456789101112@RestController@RequestMapping("user")public class UserController &#123; @Autowired private UserService userService; @GetMapping("/&#123;id&#125;") public User queryById(@PathVariable("id") Long id) &#123; return this.userService.queryById(id); &#125;&#125;Service：12345678910@Servicepublic class UserService &#123; @Autowired private UserMapper userMapper; public User queryById(Long id) &#123; return this.userMapper.selectByPrimaryKey(id); &#125;&#125;mapper:123@Mapperpublic interface UserMapper extends tk.mybatis.mapper.common.Mapper&lt;User&gt;&#123;&#125;实体类：1234567891011121314151617181920212223242526272829303132333435363738@Table(name = "tb_user")public class User implements Serializable &#123; private static final long serialVersionUID = 1L; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; // 用户名 private String userName; // 密码 private String password; // 姓名 private String name; // 年龄 private Integer age; // 性别，1男性，2女性 private Integer sex; // 出生日期 private Date birthday; // 创建时间 private Date created; // 更新时间 private Date updated; // 备注 private String note; // 。。。省略getters和setters&#125;属性文件,这里我们采用了yaml语法，而不是properties：123456789101112server: port: 8081spring: datasource: url: jdbc:mysql://localhost:3306/mydb01 username: root password: 123 hikari: maximum-pool-size: 20 minimum-idle: 10mybatis: type-aliases-package: com.leyou.userservice.pojo项目结构：5.1.3.启动并测试：启动项目，访问接口：http://localhost:8081/user/75.2.服务调用者5.2.1.创建工程与上面类似，这里不再赘述，需要注意的是，我们调用user-service的功能，因此不需要mybatis相关依赖了。pom：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.demo&lt;/groupId&gt; &lt;artifactId&gt;user-consumer-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;user-consumer-demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 添加OkHttp支持 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt; &lt;artifactId&gt;okhttp&lt;/artifactId&gt; &lt;version&gt;3.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt;5.2.2.编写代码首先在启动类中注册RestTemplate：12345678910111213@SpringBootApplicationpublic class UserConsumerDemoApplication &#123; @Bean public RestTemplate restTemplate() &#123; // 这次我们使用了OkHttp客户端,只需要注入工厂即可 return new RestTemplate(new OkHttp3ClientHttpRequestFactory()); &#125; public static void main(String[] args) &#123; SpringApplication.run(UserConsumerDemoApplication.class, args); &#125;&#125;然后编写UserDao，注意，这里不是调用mapper查数据库，而是通过RestTemplate远程查询user-service-demo中的接口：1234567891011@Componentpublic class UserDao &#123; @Autowired private RestTemplate restTemplate; public User queryUserById(Long id)&#123; String url = "http://localhost:8081/user/" + id; return this.restTemplate.getForObject(url, User.class); &#125;&#125;然后编写user-service，循环查询UserDAO信息：123456789101112131415@Servicepublic class UserService &#123; @Autowired private UserDao userDao; public List&lt;User&gt; querUserByIds(List&lt;Long&gt; ids)&#123; List&lt;User&gt; users = new ArrayList&lt;&gt;(); for (Long id : ids) &#123; User user = this.userDao.queryUserById(id); users.add(user); &#125; return users; &#125;&#125;编写controller：123456789101112@RestController@RequestMapping("consume")public class ConsumerController &#123; @Autowired private UserService userService; @GetMapping public List&lt;User&gt; consume(@RequestParam("ids") List&lt;Long&gt; ids) &#123; return this.userService.queryUserByIds(ids); &#125;&#125;5.2.3.启动测试：因为我们没有配置端口，那么默认就是8080，我们访问：http://localhost:8080/consume?ids=6,7,8一个简单的远程服务调用案例就实现了。5.3.有没有问题？简单回顾一下，刚才我们写了什么：use-service-demo：一个提供根据id查询用户的微服务consumer-demo：一个服务调用者，通过RestTemplate远程调用user-service-demo流程如下：存在什么问题？在consumer中，我们把url地址硬编码到了代码中，不方便后期维护consumer需要记忆user-service的地址，如果出现变更，可能得不到通知，地址将失效consumer不清楚user-service的状态，服务宕机也不知道user-service只有1台服务，不具备高可用性即便user-service形成集群，consumer还需自己实现负载均衡其实上面说的问题，概括一下就是分布式服务必然要面临的问题：服务管理如何自动注册和发现如何实现状态监管如何实现动态路由服务如何实现负载均衡服务如何解决容灾问题服务如何实现统一配置以上的问题，我们都将在SpringCloud中得到答案。6.Eureka注册中心6.1.认识Eureka首先我们来解决第一问题，服务的管理。问题分析在刚才的案例中，user-service对外提供服务，需要对外暴露自己的地址。而consumer（调用者）需要记录服务提供者的地址。将来地址出现变更，还需要及时更新。这在服务较少的时候并不觉得有什么，但是在现在日益复杂的互联网环境，一个项目肯定会拆分出十几，甚至数十个微服务。此时如果还人为管理地址，不仅开发困难，将来测试、发布上线都会非常麻烦，这与DevOps的思想是背道而驰的。网约车这就好比是 网约车出现以前，人们出门叫车只能叫出租车。一些私家车想做出租却没有资格，被称为黑车。而很多人想要约车，但是无奈出租车太少，不方便。私家车很多却不敢拦，而且满大街的车，谁知道哪个才是愿意载人的。一个想要，一个愿意给，就是缺少引子，缺乏管理啊。此时滴滴这样的网约车平台出现了，所有想载客的私家车全部到滴滴注册，记录你的车型（服务类型），身份信息（联系方式）。这样提供服务的私家车，在滴滴那里都能找到，一目了然。此时要叫车的人，只需要打开APP，输入你的目的地，选择车型（服务类型），滴滴自动安排一个符合需求的车到你面前，为你服务，完美！Eureka做什么？Eureka就好比是滴滴，负责管理、记录服务提供者的信息。服务调用者无需自己寻找服务，而是把自己的需求告诉Eureka，然后Eureka会把符合你需求的服务告诉你。同时，服务提供方与Eureka之间通过“心跳”机制进行监控，当某个服务提供方出现问题，Eureka自然会把它从服务列表中剔除。这就实现了服务的自动注册、发现、状态监控。6.2.原理图基本架构：Eureka：就是服务注册中心（可以是一个集群），对外暴露自己的地址提供者：启动后向Eureka注册自己信息（地址，提供什么服务）消费者：向Eureka订阅服务，Eureka会将对应服务的所有提供者地址列表发送给消费者，并且定期更新心跳(续约)：提供者定期通过http方式向Eureka刷新自己的状态6.3.入门案例6.3.1.编写EurekaServer接下来我们创建一个项目，启动一个EurekaServer：依然使用spring提供的快速搭建工具：选择依赖：完整的Pom文件：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.demo&lt;/groupId&gt; &lt;artifactId&gt;eureka-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;eureka-demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;!-- SpringCloud版本，是最新的F系列 --&gt; &lt;spring-cloud.version&gt;Finchley.RC1&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- Eureka服务端 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- SpringCloud依赖，一定要放到dependencyManagement中，起到管理版本的作用即可 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt;&lt;/project&gt;编写启动类：12345678@SpringBootApplication@EnableEurekaServer // 声明这个应用是一个EurekaServerpublic class EurekaDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaDemoApplication.class, args); &#125;&#125;编写配置：1234567891011server: port: 10086 # 端口spring: application: name: eureka-server # 应用名称，会在Eureka中显示eureka: client: register-with-eureka: false # 是否注册自己的信息到EurekaServer，默认是true fetch-registry: false # 是否拉取其它服务的信息，默认是true service-url: # EurekaServer的地址，现在是自己的地址，如果是集群，需要加上其它Server的地址。 defaultZone: http://127.0.0.1:$&#123;server.port&#125;/eureka启动服务，并访问：http://127.0.0.1:10086/eureka6.3.2.将user-service注册到Eureka注册服务，就是在服务上添加Eureka的客户端依赖，客户端代码会自动把服务注册到EurekaServer中。我们在user-service-demo中添加Eureka客户端依赖：先添加SpringCloud依赖：1234567891011121314151617181920212223&lt;!-- SpringCloud的依赖 --&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Finchley.RC1&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;!-- Spring的仓库地址 --&gt;&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt;&lt;/repositories&gt;然后是Eureka客户端：12345&lt;!-- Eureka客户端 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;在启动类上开启Eureka客户端功能通过添加@EnableDiscoveryClient来开启Eureka客户端功能1234567@SpringBootApplication@EnableDiscoveryClient // 开启EurekaClient功能public class UserServiceDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(UserServiceDemoApplication.class, args); &#125;&#125;编写配置123456789101112131415161718192021server: port: 8081spring: datasource: url: jdbc:mysql://localhost:3306/mydb01 username: root password: 123 hikari: maximum-pool-size: 20 minimum-idle: 10 application: name: user-service # 应用名称mybatis: type-aliases-package: com.leyou.userservice.pojoeureka: client: service-url: # EurekaServer地址 defaultZone: http://127.0.0.1:10086/eureka instance: prefer-ip-address: true # 当调用getHostname获取实例的hostname时，返回ip而不是host名称 ip-address: 127.0.0.1 # 指定自己的ip信息，不指定的话会自己寻找注意：这里我们添加了spring.application.name属性来指定应用名称，将来会作为应用的id使用。不用指定register-with-eureka和fetch-registry，因为默认是true重启项目，访问Eureka监控页面查看我们发现user-service服务已经注册成功了6.3.3.消费者从Eureka获取服务接下来我们修改consumer-demo，尝试从EurekaServer获取服务。方法与消费者类似，只需要在项目中添加EurekaClient依赖，就可以通过服务名称来获取信息了！1）添加依赖：先添加SpringCloud依赖：1234567891011121314151617181920212223&lt;!-- SpringCloud的依赖 --&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Finchley.RC1&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;!-- Spring的仓库地址 --&gt;&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt;&lt;/repositories&gt;然后是Eureka客户端：12345&lt;!-- Eureka客户端 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;2）在启动类开启Eureka客户端1234567891011@SpringBootApplication@EnableDiscoveryClient // 开启Eureka客户端public class UserConsumerDemoApplication &#123; @Bean public RestTemplate restTemplate() &#123; return new RestTemplate(new OkHttp3ClientHttpRequestFactory()); &#125; public static void main(String[] args) &#123; SpringApplication.run(UserConsumerDemoApplication.class, args); &#125;&#125;3）修改配置：123456789101112server: port: 8080spring: application: name: consumer # 应用名称eureka: client: service-url: # EurekaServer地址 defaultZone: http://127.0.0.1:10086/eureka instance: prefer-ip-address: true # 当其它服务获取地址时提供ip而不是hostname ip-address: 127.0.0.1 # 指定自己的ip信息，不指定的话会自己寻找4）修改代码，用DiscoveryClient类的方法，根据服务名称，获取服务实例：12345678910111213141516171819202122232425262728293031@Servicepublic class UserService &#123; @Autowired private RestTemplate restTemplate; @Autowired private DiscoveryClient discoveryClient;// Eureka客户端，可以获取到服务实例信息 public List&lt;User&gt; queryUserByIds(List&lt;Long&gt; ids) &#123; List&lt;User&gt; users = new ArrayList&lt;&gt;(); // String baseUrl = "http://localhost:8081/user/"; // 根据服务名称，获取服务实例 List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances("user-service"); // 因为只有一个UserService,因此我们直接get(0)获取 ServiceInstance instance = instances.get(0); // 获取ip和端口信息 String baseUrl = "http://"+instance.getHost() + ":" + instance.getPort()+"/user/"; ids.forEach(id -&gt; &#123; // 我们测试多次查询， users.add(this.restTemplate.getForObject(baseUrl + id, User.class)); // 每次间隔500毫秒 try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); return users; &#125;&#125;5）Debug跟踪运行：生成的URL：访问结果：6.4.Eureka详解接下来我们详细讲解Eureka的原理及配置。6.4.1.基础架构Eureka架构中的三个核心角色：服务注册中心Eureka的服务端应用，提供服务注册和发现功能，就是刚刚我们建立的eureka-demo服务提供者提供服务的应用，可以是SpringBoot应用，也可以是其它任意技术实现，只要对外提供的是Rest风格服务即可。本例中就是我们实现的user-service-demo服务消费者消费应用从注册中心获取服务列表，从而得知每个服务方的信息，知道去哪里调用服务方。本例中就是我们实现的consumer-demo6.4.2.高可用的Eureka ServerEureka Server即服务的注册中心，在刚才的案例中，我们只有一个EurekaServer，事实上EurekaServer也可以是一个集群，形成高可用的Eureka中心。服务同步多个Eureka Server之间也会互相注册为服务，当服务提供者注册到Eureka Server集群中的某个节点时，该节点会把服务的信息同步给集群中的每个节点，从而实现数据同步。因此，无论客户端访问到Eureka Server集群中的任意一个节点，都可以获取到完整的服务列表信息。动手搭建高可用的EurekaServer我们假设要搭建两条EurekaServer的集群，端口分别为：10086和100871）我们修改原来的EurekaServer配置：123456789server: port: 10086 # 端口spring: application: name: eureka-server # 应用名称，会在Eureka中显示eureka: client: service-url: # 配置其他Eureka服务的地址，而不是自己，比如10087 defaultZone: http://127.0.0.1:10087/eureka所谓的高可用注册中心，其实就是把EurekaServer自己也作为一个服务进行注册，这样多个EurekaServer之间就能互相发现对方，从而形成集群。因此我们做了以下修改：删除了register-with-eureka=false和fetch-registry=false两个配置。因为默认值是true，这样就会吧自己注册到注册中心了。把service-url的值改成了另外一台EurekaServer的地址，而不是自己2）另外一台配置恰好相反：123456789server: port: 10087 # 端口spring: application: name: eureka-server # 应用名称，会在Eureka中显示eureka: client: service-url: # 配置其他Eureka服务的地址，而不是自己，比如10087 defaultZone: http://127.0.0.1:10086/eureka注意：idea中一个应用不能启动两次，我们需要重新配置一个启动器：然后启动即可。3）启动测试：4）客户端注册服务到集群因为EurekaServer不止一个，因此注册服务的时候，service-url参数需要变化：1234eureka: client: service-url: # EurekaServer地址,多个地址以','隔开 defaultZone: http://127.0.0.1:10086/eureka,http://127.0.0.1:10087/eureka6.4.3.服务提供者服务提供者要向EurekaServer注册服务，并且完成服务续约等工作。服务注册服务提供者在启动时，会检测配置属性中的：eureka.client.register-with-erueka=true参数是否正确，事实上默认就是true。如果值确实为true，则会向EurekaServer发起一个Rest请求，并携带自己的元数据信息，Eureka Server会把这些信息保存到一个双层Map结构中。第一层Map的Key就是服务名称，第二层Map的key是服务的实例id。服务续约在注册服务完成以后，服务提供者会维持一个心跳（定时向EurekaServer发起Rest请求），告诉EurekaServer：“我还活着”。这个我们称为服务的续约（renew）；有两个重要参数可以修改服务续约的行为：1234eureka: instance: lease-expiration-duration-in-seconds: 90 lease-renewal-interval-in-seconds: 30lease-renewal-interval-in-seconds：服务续约(renew)的间隔，默认为30秒lease-expiration-duration-in-seconds：服务失效时间，默认值90秒也就是说，默认情况下每个30秒服务会向注册中心发送一次心跳，证明自己还活着。如果超过90秒没有发送心跳，EurekaServer就会认为该服务宕机，会从服务列表中移除，这两个值在生产环境不要修改，默认即可。但是在开发时，这个值有点太长了，经常我们关掉一个服务，会发现Eureka依然认为服务在活着。所以我们在开发阶段可以适当调小。1234eureka: instance: lease-expiration-duration-in-seconds: 10 # 10秒即过期 lease-renewal-interval-in-seconds: 5 # 5秒一次心跳实例id先来看一下服务状态信息：在Eureka监控页面，查看服务注册信息：在status一列中，显示以下信息：UP(1)：代表现在是启动了1个示例，没有集群DESKTOP-2MVEC12:user-service:8081：是示例的名称（instance-id），默认格式是：${hostname} + ${spring.application.name} + ${server.port}instance-id是区分同一服务的不同实例的唯一标准，因此不能重复。我们可以通过instance-id属性来修改它的构成：123eureka: instance: instance-id: $&#123;spring.application.name&#125;:$&#123;server.port&#125;重启服务再试试看：6.4.4.服务消费者获取服务列表当服务消费者启动是，会检测eureka.client.fetch-registry=true参数的值，如果为true，则会从Eureka Server服务的列表只读备份，然后缓存在本地。并且每隔30秒会重新获取并更新数据。我们可以通过下面的参数来修改：123eureka: client: registry-fetch-interval-seconds: 5生产环境中，我们不需要修改这个值。但是为了开发环境下，能够快速得到服务的最新状态，我们可以将其设置小一点。6.4.5.失效剔除和自我保护失效剔除有些时候，我们的服务提供方并不一定会正常下线，可能因为内存溢出、网络故障等原因导致服务无法正常工作。Eureka Server需要将这样的服务剔除出服务列表。因此它会开启一个定时任务，每隔60秒对所有失效的服务（超过90秒未响应）进行剔除。可以通过eureka.server.eviction-interval-timer-in-ms参数对其进行修改，单位是毫秒，生成环境不要修改。这个会对我们开发带来极大的不变，你对服务重启，隔了60秒Eureka才反应过来。开发阶段可以适当调整，比如10S自我保护我们关停一个服务，就会在Eureka面板看到一条警告：这是触发了Eureka的自我保护机制。当一个服务未按时进行心跳续约时，Eureka会统计最近15分钟心跳失败的服务实例的比例是否超过了85%。在生产环境下，因为网络延迟等原因，心跳失败实例的比例很有可能超标，但是此时就把服务剔除列表并不妥当，因为服务可能没有宕机。Eureka就会把当前实例的注册信息保护起来，不予剔除。生产环境下这很有效，保证了大多数服务依然可用。但是这给我们的开发带来了麻烦， 因此开发阶段我们都会关闭自我保护模式：1234eureka: server: enable-self-preservation: false # 关闭自我保护模式（缺省为打开） eviction-interval-timer-in-ms: 1000 # 扫描失效服务的间隔时间（缺省为60*1000ms）7.负载均衡Robbin在刚才的案例中，我们启动了一个user-service，然后通过DiscoveryClient来获取服务实例信息，然后获取ip和端口来访问。但是实际环境中，我们往往会开启很多个user-service的集群。此时我们获取的服务列表中就会有多个，到底该访问哪一个呢？一般这种情况下我们就需要编写负载均衡算法，在多个实例列表中进行选择。不过Eureka中已经帮我们集成了负载均衡组件：Ribbon，简单修改代码即可使用。什么是Ribbon：接下来，我们就来使用Ribbon实现负载均衡。7.1.启动两个服务实例首先我们启动两个user-service实例，一个8081，一个8082。Eureka监控面板：7.2.开启负载均衡因为Eureka中已经集成了Ribbon，所以我们无需引入新的依赖。直接修改代码：在RestTemplate的配置方法上添加@LoadBalanced注解：12345@Bean@LoadBalancedpublic RestTemplate restTemplate() &#123; return new RestTemplate(new OkHttp3ClientHttpRequestFactory());&#125;修改调用方式，不再手动获取ip和端口，而是直接通过服务名称调用：1234567891011121314151617181920212223242526@Servicepublic class UserService &#123; @Autowired private RestTemplate restTemplate; @Autowired private DiscoveryClient discoveryClient; public List&lt;User&gt; queryUserByIds(List&lt;Long&gt; ids) &#123; List&lt;User&gt; users = new ArrayList&lt;&gt;(); // 地址直接写服务名称即可 String baseUrl = "http://user-service/user/"; ids.forEach(id -&gt; &#123; // 我们测试多次查询， users.add(this.restTemplate.getForObject(baseUrl + id, User.class)); // 每次间隔500毫秒 try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); return users; &#125;&#125;访问页面，查看结果：完美！7.3.源码跟踪为什么我们只输入了service名称就可以访问了呢？之前还要获取ip和端口。显然有人帮我们根据service名称，获取到了服务实例的ip和端口。它就是LoadBalancerInterceptor我们进行源码跟踪：继续跟入execute方法：发现获取了8082端口的服务再跟下一次，发现获取的是8081：7.4.负载均衡策略Ribbon默认的负载均衡策略是简单的轮询，我们可以测试一下：编写测试类，在刚才的源码中我们看到拦截中是使用RibbonLoadBalanceClient来进行负载均衡的，其中有一个choose方法，是这样介绍的：现在这个就是负载均衡获取实例的方法。我们对注入这个类的对象，然后对其测试：123456789101112131415@RunWith(SpringRunner.class)@SpringBootTest(classes = UserConsumerDemoApplication.class)public class LoadBalanceTest &#123; @Autowired RibbonLoadBalancerClient client; @Test public void test()&#123; for (int i = 0; i &lt; 100; i++) &#123; ServiceInstance instance = this.client.choose("user-service"); System.out.println(instance.getHost() + ":" + instance.getPort()); &#125; &#125;&#125;结果：符合了我们的预期推测，确实是轮询方式。我们是否可以修改负载均衡的策略呢？继续跟踪源码，发现这么一段代码：我们看看这个rule是谁：这里的rule默认值是一个RoundRobinRule，看类的介绍：这不就是轮询的意思嘛。我们注意到，这个类其实是实现了接口IRule的，查看一下：定义负载均衡的规则接口。它有以下实现：SpringBoot也帮我们提供了修改负载均衡规则的配置入口：123user-service: ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule格式是：{服务名称}.ribbon.NFLoadBalancerRuleClassName，值就是IRule的实现类。再次测试，发现结果变成了随机：7.5.重试机制Eureka的服务治理强调了CAP原则中的AP，即可用性和可靠性。它与Zookeeper这一类强调CP（一致性，可靠性）的服务治理框架最大的区别在于：Eureka为了实现更高的服务可用性，牺牲了一定的一致性，极端情况下它宁愿接收故障实例也不愿丢掉健康实例，正如我们上面所说的自我保护机制。但是，此时如果我们调用了这些不正常的服务，调用就会失败，从而导致其它服务不能正常工作！这显然不是我们愿意看到的。我们现在关闭一个user-service实例：因为服务剔除的延迟，consumer并不会立即得到最新的服务列表，此时再次访问你会得到错误提示：但是此时，8081服务其实是正常的。因此Spring Cloud 整合了Spring Retry 来增强RestTemplate的重试能力，当一次服务调用失败后，不会立即抛出一次，而是再次重试另一个服务。只需要简单配置即可实现Ribbon的重试：123456789101112spring: cloud: loadbalancer: retry: enabled: true # 开启Spring Cloud的重试功能user-service: ribbon: ConnectTimeout: 250 # Ribbon的连接超时时间 ReadTimeout: 1000 # Ribbon的数据读取超时时间 OkToRetryOnAllOperations: true # 是否对所有操作都进行重试 MaxAutoRetriesNextServer: 1 # 切换实例的重试次数 MaxAutoRetries: 1 # 对当前实例的重试次数根据如上配置，当访问到某个服务超时后，它会再次尝试访问下一个服务实例，如果不行就再换一个实例，如果不行，则返回失败。切换次数取决于MaxAutoRetriesNextServer参数的值引入spring-retry依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.retry&lt;/groupId&gt; &lt;artifactId&gt;spring-retry&lt;/artifactId&gt;&lt;/dependency&gt;我们重启user-consumer-demo，测试，发现即使user-service2宕机，也能通过另一台服务实例获取到结果！]]></content>
      <categories>
        <category>springCloud实战</category>
      </categories>
      <tags>
        <tag>springCloud</tag>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springCloud项目1]]></title>
    <url>%2F2020%2F03%2F30%2FspringCloud%E9%A1%B9%E7%9B%AE1%2F</url>
    <content type="text"><![CDATA[此系列为系统学习springCloud的笔记，自认为总结的没有原本培训视频的笔记好，就拿来主义的挂上，也仅供自己来看，如果你也有兴趣，我会在下载的模块加上这套教程的地址，供你学习与参考。如果有能力的话还是要支持一下这所培训公司，感谢黑马、感谢传智播客！0.学习目标了解SpringBoot的作用掌握java配置的方式了解SpringBoot自动配置原理掌握SpringBoot的基本使用了解Thymeleaf的基本使用1. 了解SpringBoot在这一部分，我们主要了解以下3个问题：什么是SpringBoot为什么要学习SpringBootSpringBoot的特点1.1.什么是SpringBootSpringBoot是Spring项目中的一个子工程，与我们所熟知的Spring-framework 同属于spring的产品:我们可以看到下面的一段介绍：Takes an opinionated view of building production-ready Spring applications. Spring Boot favors convention over configuration and is designed to get you up and running as quickly as possible.翻译一下：用一些固定的方式来构建生产级别的spring应用。Spring Boot 推崇约定大于配置的方式以便于你能够尽可能快速的启动并运行程序。其实人们把Spring Boot 称为搭建程序的脚手架。其最主要作用就是帮我们快速的构建庞大的spring项目，并且尽可能的减少一切xml配置，做到开箱即用，迅速上手，让我们关注与业务而非配置。1.2.为什么要学习SpringBootjava一直被人诟病的一点就是臃肿、麻烦。当我们还在辛苦的搭建项目时，可能Python程序员已经把功能写好了，究其原因注意是两点：复杂的配置，项目各种配置其实是开发时的损耗， 因为在思考 Spring 特性配置和解决业务问题之间需要进行思维切换，所以写配置挤占了写应用程序逻辑的时间。一个是混乱的依赖管理。项目的依赖管理也是件吃力不讨好的事情。决定项目里要用哪些库就已经够让人头痛的了，你还要知道这些库的哪个版本和其他库不会有冲突，这难题实在太棘手。并且，依赖管理也是一种损耗，添加依赖不是写应用程序代码。一旦选错了依赖的版本，随之而来的不兼容问题毫无疑问会是生产力杀手。而SpringBoot让这一切成为过去！Spring Boot 简化了基于Spring的应用开发，只需要“run”就能创建一个独立的、生产级别的Spring应用。Spring Boot为Spring平台及第三方库提供开箱即用的设置（提供默认设置，存放默认配置的包就是启动器），这样我们就可以简单的开始。多数Spring Boot应用只需要很少的Spring配置。我们可以使用SpringBoot创建java应用，并使用java –jar 启动它，就能得到一个生产级别的web工程。1.3.SpringBoot的特点Spring Boot 主要目标是：为所有 Spring 的开发者提供一个非常快速的、广泛接受的入门体验开箱即用（启动器starter-其实就是SpringBoot提供的一个jar包），但通过自己设置参数（.properties），即可快速摆脱这种方式。提供了一些大型项目中常见的非功能性特性，如内嵌服务器、安全、指标，健康检测、外部化配置等绝对没有代码生成，也无需 XML 配置。更多细节，大家可以到官网查看。2.快速入门接下来，我们就来利用SpringBoot搭建一个web工程，体会一下SpringBoot的魅力所在！2.1.创建工程我们先新建一个空的工程：工程名为demo：新建一个model：使用maven来构建：然后填写项目坐标：目录结构：项目结构：2.2.添加依赖看到这里很多同学会有疑惑，前面说传统开发的问题之一就是依赖管理混乱，怎么这里我们还需要管理依赖呢？难道SpringBoot不帮我们管理吗？别着急，现在我们的项目与SpringBoot还没有什么关联。SpringBoot提供了一个名为spring-boot-starter-parent的工程，里面已经对各种常用依赖（并非全部）的版本进行了管理，我们的项目需要以这个项目为父工程，这样我们就不用操心依赖的版本问题了，需要什么依赖，直接引入坐标即可！2.2.1.添加父工程坐标12345&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.0.RELEASE&lt;/version&gt;&lt;/parent&gt;2.2.2.添加web启动器为了让SpringBoot帮我们完成各种自动配置，我们必须引入SpringBoot提供的自动配置依赖，我们称为启动器。因为我们是web项目，这里我们引入web启动器：123456&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;需要注意的是，我们并没有在这里指定版本信息。因为SpringBoot的父工程已经对版本进行了管理了。这个时候，我们会发现项目中多出了大量的依赖：这些都是SpringBoot根据spring-boot-starter-web这个依赖自动引入的，而且所有的版本都已经管理好，不会出现冲突。2.2.3.管理jdk版本默认情况下，maven工程的jdk版本是1.5，而我们开发使用的是1.8，因此这里我们需要修改jdk版本，只需要简单的添加以下属性即可：123&lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt;&lt;/properties&gt;2.2.4.完整pom123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.demo&lt;/groupId&gt; &lt;artifactId&gt;springboot-demo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.0.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt;2.3.启动类Spring Boot项目通过main函数即可启动，我们需要创建一个启动类：然后编写main函数：123456@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125;2.4.编写controller接下来，我们就可以像以前那样开发SpringMVC的项目了！我们编写一个controller：代码：12345678@RestControllerpublic class HelloController &#123; @GetMapping("hello") public String hello()&#123; return "hello, spring boot!"; &#125;&#125;2.5.启动测试接下来，我们运行main函数，查看控制台：并且可以看到监听的端口信息：1）监听的端口是80802）SpringMVC的映射路径是：/3）/hello路径已经映射到了HelloController中的hello()方法打开页面访问：http://localhost:8080/hello测试成功了！3.Java配置在入门案例中，我们没有任何的配置，就可以实现一个SpringMVC的项目了，快速、高效！但是有同学会有疑问，如果没有任何的xml，那么我们如果要配置一个Bean该怎么办？比如我们要配置一个数据库连接池，以前会这么玩：1234567&lt;!-- 配置连接池 --&gt;&lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt;&lt;/bean&gt;现在该怎么做呢？3.1.回顾历史事实上，在Spring3.0开始，Spring官方就已经开始推荐使用java配置来代替传统的xml配置了，我们不妨来回顾一下Spring的历史：Spring1.0时代在此时因为jdk1.5刚刚出来，注解开发并未盛行，因此一切Spring配置都是xml格式，想象一下所有的bean都用xml配置，细思极恐啊，心疼那个时候的程序员2秒Spring2.0时代Spring引入了注解开发，但是因为并不完善，因此并未完全替代xml，此时的程序员往往是把xml与注解进行结合，貌似我们之前都是这种方式。Spring3.0及以后3.0以后Spring的注解已经非常完善了，因此Spring推荐大家使用完全的java配置来代替以前的xml，不过似乎在国内并未推广盛行。然后当SpringBoot来临，人们才慢慢认识到java配置的优雅。有句古话说的好：拥抱变化，拥抱未来。所以我们也应该顺应时代潮流，做时尚的弄潮儿，一起来学习下java配置的玩法。3.2.尝试java配置java配置主要靠java类和一些注解，比较常用的注解有：@Configuration：声明一个类作为配置类，代替xml文件@Bean：声明在方法上，将方法的返回值加入Bean容器，代替&lt;bean&gt;标签@value：属性注入@PropertySource：指定外部属性文件，我们接下来用java配置来尝试实现连接池配置：首先引入Druid连接池依赖：12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.6&lt;/version&gt;&lt;/dependency&gt;创建一个jdbc.properties文件，编写jdbc属性：1234jdbc.driverClassName=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://127.0.0.1:3306/leyoujdbc.username=rootjdbc.password=123然后编写代码：1234567891011121314151617181920212223@Configuration@PropertySource("classpath:jdbc.properties")public class JdbcConfig &#123; @Value("$&#123;jdbc.url&#125;") String url; @Value("$&#123;jdbc.driverClassName&#125;") String driverClassName; @Value("$&#123;jdbc.username&#125;") String username; @Value("$&#123;jdbc.password&#125;") String password; @Bean public DataSource dataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setUrl(url); dataSource.setDriverClassName(driverClassName); dataSource.setUsername(username); dataSource.setPassword(password); return dataSource; &#125;&#125;解读：@Configuration：声明我们JdbcConfig是一个配置类@PropertySource：指定属性文件的路径是:classpath:jdbc.properties通过@Value为属性注入值通过@Bean将 dataSource()方法声明为一个注册Bean的方法，Spring会自动调用该方法，将方法的返回值加入Spring容器中。然后我们就可以在任意位置通过@Autowired注入DataSource了！我们在HelloController中测试：1234567891011@RestControllerpublic class HelloController &#123; @Autowired private DataSource dataSource; @GetMapping("hello") public String hello() &#123; return "hello, spring boot!" + dataSource; &#125;&#125;然后Debug运行并查看：属性注入成功了！3.3.SpringBoot的属性注入在上面的案例中，我们实验了java配置方式。不过属性注入使用的是@Value注解。这种方式虽然可行，但是不够强大，因为它只能注入基本类型值。在SpringBoot中，提供了一种新的属性注入方式，支持各种java基本数据类型及复杂类型的注入。1）我们新建一个类，用来进行属性注入：123456789@ConfigurationProperties(prefix = "jdbc")public class JdbcProperties &#123; private String url; private String driverClassName; private String username; private String password; // ... 略 // getters 和 setters&#125;在类上通过@ConfigurationProperties注解声明当前类为属性读取类prefix=&quot;jdbc&quot;读取属性文件中，前缀为jdbc的值。在类上定义各个属性，名称必须与属性文件中jdbc.后面部分一致需要注意的是，这里我们并没有指定属性文件的地址，所以我们需要把jdbc.properties名称改为application.properties，这是SpringBoot默认读取的属性文件名：2）在JdbcConfig中使用这个属性：1234567891011121314@Configuration@EnableConfigurationProperties(JdbcProperties.class)public class JdbcConfig &#123; @Bean public DataSource dataSource(JdbcProperties jdbc) &#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setUrl(jdbc.getUrl()); dataSource.setDriverClassName(jdbc.getDriverClassName()); dataSource.setUsername(jdbc.getUsername()); dataSource.setPassword(jdbc.getPassword()); return dataSource; &#125;&#125;通过@EnableConfigurationProperties(JdbcProperties.class)来声明要使用JdbcProperties这个类的对象然后你可以通过以下方式注入JdbcProperties：@Autowired注入12@Autowiredprivate JdbcProperties prop;构造函数注入1234private JdbcProperties prop;public JdbcConfig(Jdbcproperties prop)&#123; this.prop = prop;&#125;声明有@Bean的方法参数注入1234@Beanpublic Datasource dataSource(JdbcProperties prop)&#123; // ...&#125;本例中，我们采用第三种方式。3）测试结果：大家会觉得这种方式似乎更麻烦了，事实上这种方式有更强大的功能，也是SpringBoot推荐的注入方式。两者对比关系：优势：Relaxed binding：松散绑定不严格要求属性文件中的属性名与成员变量名一致。支持驼峰，中划线，下划线等等转换，甚至支持对象引导。比如：user.friend.name：代表的是user对象中的friend属性中的name属性，显然friend也是对象。@value注解就难以完成这样的注入方式。meta-data support：元数据支持，帮助IDE生成属性提示（写开源框架会用到）。3.4、更优雅的注入事实上，如果一段属性只有一个Bean需要使用，我们无需将其注入到一个类（JdbcProperties）中。而是直接在需要的地方声明即可：1234567891011@Configurationpublic class JdbcConfig &#123; @Bean // 声明要注入的属性前缀，SpringBoot会自动把相关属性通过set方法注入到DataSource中 @ConfigurationProperties(prefix = "jdbc") public DataSource dataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); return dataSource; &#125;&#125;我们直接把@ConfigurationProperties(prefix = &quot;jdbc&quot;)声明在需要使用的@Bean的方法上，然后SpringBoot就会自动调用这个Bean（此处是DataSource）的set方法，然后完成注入。使用的前提是：该类必须有对应属性的set方法！我们将jdbc的url改成：/heima，再次测试：4.自动配置原理使用SpringBoot之后，一个整合了SpringMVC的WEB工程开发，变的无比简单，那些繁杂的配置都消失不见了，这是如何做到的？一切魔力的开始，都是从我们的main函数来的，所以我们再次来看下启动类：我们发现特别的地方有两个：注解：@SpringBootApplicationrun方法：SpringApplication.run()我们分别来研究这两个部分。4.1.了解@SpringBootApplication点击进入，查看源码：这里重点的注解有3个：@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan4.1.1.@SpringBootConfiguration我们继续点击查看源码：通过这段我们可以看出，在这个注解上面，又有一个@Configuration注解。通过上面的注释阅读我们知道：这个注解的作用就是声明当前类是一个配置类，然后Spring会自动扫描到添加了@Configuration的类，并且读取其中的配置信息。而@SpringBootConfiguration是来声明当前类是SpringBoot应用的配置类，项目中只能有一个。所以一般我们无需自己添加。4.1.2.@EnableAutoConfiguration关于这个注解，官网上有一段说明：The second class-level annotation is @EnableAutoConfiguration. This annotationtells Spring Boot to “guess” how you want to configure Spring, based on the jardependencies that you have added. Since spring-boot-starter-web added Tomcatand Spring MVC, the auto-configuration assumes that you are developing a webapplication and sets up Spring accordingly.简单翻译以下：第二级的注解@EnableAutoConfiguration，告诉SpringBoot基于你所添加的依赖，去“猜测”你想要如何配置Spring。比如我们引入了spring-boot-starter-web，而这个启动器中帮我们添加了tomcat、SpringMVC的依赖。此时自动配置就知道你是要开发一个web应用，所以就帮你完成了web及SpringMVC的默认配置了！总结，SpringBoot内部对大量的第三方库或Spring内部库进行了默认配置，这些配置是否生效，取决于我们是否引入了对应库所需的依赖，如果有那么默认配置就会生效。所以，我们使用SpringBoot构建一个项目，只需要引入所需框架的依赖，配置就可以交给SpringBoot处理了。除非你不希望使用SpringBoot的默认配置，它也提供了自定义配置的入口。4.1.3.@ComponentScan我们跟进源码：并没有看到什么特殊的地方。我们查看注释：大概的意思：配置组件扫描的指令。提供了类似与&lt;context:component-scan&gt;标签的作用通过basePackageClasses或者basePackages属性来指定要扫描的包。如果没有指定这些属性，那么将从声明这个注解的类所在的包开始，扫描包及子包而我们的@SpringBootApplication注解声明的类就是main函数所在的启动类，因此扫描的包是该类所在包及其子包。因此，一般启动类会放在一个比较前的包目录中。4.2.默认配置原理4.2.1默认配置类通过刚才的学习，我们知道@EnableAutoConfiguration会开启SpringBoot的自动配置，并且根据你引入的依赖来生效对应的默认配置。那么问题来了：这些默认配置是在哪里定义的呢？为何依赖引入就会触发配置呢？其实在我们的项目中，已经引入了一个依赖：spring-boot-autoconfigure，其中定义了大量自动配置类：还有：非常多，几乎涵盖了现在主流的开源框架，例如：redisjmsamqpjdbcjacksonmongodbjpasolrelasticsearch… 等等我们来看一个我们熟悉的，例如SpringMVC，查看mvc 的自动配置类：打开WebMvcAutoConfiguration：我们看到这个类上的4个注解：@Configuration：声明这个类是一个配置类@ConditionalOnWebApplication(type = Type.SERVLET)ConditionalOn，翻译就是在某个条件下，此处就是满足项目的类是是Type.SERVLET类型，也就是一个普通web工程，显然我们就是@ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class })这里的条件是OnClass，也就是满足以下类存在：Servlet、DispatcherServlet、WebMvcConfigurer，其中Servlet只要引入了tomcat依赖自然会有，后两个需要引入SpringMVC才会有。这里就是判断你是否引入了相关依赖，引入依赖后该条件成立，当前类的配置才会生效！@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)这个条件与上面不同，OnMissingBean，是说环境中没有指定的Bean这个才生效。其实这就是自定义配置的入口，也就是说，如果我们自己配置了一个WebMVCConfigurationSupport的类，那么这个默认配置就会失效！接着，我们查看该类中定义了什么：视图解析器：处理器适配器（HandlerAdapter）：还有很多，这里就不一一截图了。4.2.2.默认配置属性另外，这些默认配置的属性来自哪里呢？我们看到，这里通过@EnableAutoConfiguration注解引入了两个属性：WebMvcProperties和ResourceProperties。这不正是SpringBoot的属性注入玩法嘛。我们查看这两个属性类：找到了内部资源视图解析器的prefix和suffix属性。ResourceProperties中主要定义了静态资源（.js,.html,.css等)的路径：如果我们要覆盖这些默认属性，只需要在application.properties中定义与其前缀prefix和字段名一致的属性即可。4.3.总结SpringBoot为我们提供了默认配置，而默认配置生效的条件一般有两个：你引入了相关依赖你自己没有配置1）启动器所以，我们如果不想配置，只需要引入依赖即可，而依赖版本我们也不用操心，因为只要引入了SpringBoot提供的stater（启动器），就会自动管理依赖及版本了。因此，玩SpringBoot的第一件事情，就是找启动器，SpringBoot提供了大量的默认启动器，参考课前资料中提供的《SpringBoot启动器.txt》2）全局配置另外，SpringBoot的默认配置，都会读取默认属性，而这些属性可以通过自定义application.properties文件来进行覆盖。这样虽然使用的还是默认配置，但是配置中的值改成了我们自定义的。因此，玩SpringBoot的第二件事情，就是通过application.properties来覆盖默认属性值，形成自定义配置。我们需要知道SpringBoot的默认属性key，非常多，参考课前资料提供的：《SpringBoot全局属性.md》5.SpringBoot实践接下来，我们来看看如何用SpringBoot来玩转以前的SSM,我们沿用之前讲解SSM用到的数据库tb_user和实体类User5.1.整合SpringMVC虽然默认配置已经可以使用SpringMVC了，不过我们有时候需要进行自定义配置。5.1.1.修改端口查看SpringBoot的全局属性可知，端口通过以下方式配置：12# 映射端口server.port=80重启服务后测试：5.1.2.访问静态资源现在，我们的项目是一个jar工程，那么就没有webapp，我们的静态资源该放哪里呢？回顾我们上面看的源码，有一个叫做ResourceProperties的类，里面就定义了静态资源的默认查找路径：默认的静态资源路径为：classpath:/META-INF/resources/classpath:/resources/classpath:/static/classpath:/public只要静态资源放在这些目录中任何一个，SpringMVC都会帮我们处理。我们习惯会把静态资源放在classpath:/static/目录下。我们创建目录，并且添加一些静态资源：重启项目后测试：5.1.3.添加拦截器拦截器也是我们经常需要使用的，在SpringBoot中该如何配置呢？拦截器不是一个普通属性，而是一个类，所以就要用到java配置方式了。在SpringBoot官方文档中有这么一段说明：If you want to keep Spring Boot MVC features and you want to add additional MVC configuration (interceptors, formatters, view controllers, and other features), you can add your own @Configuration class of type WebMvcConfigurer but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter, or ExceptionHandlerExceptionResolver, you can declare a WebMvcRegistrationsAdapter instance to provide such components.If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc.翻译：如果你想要保持Spring Boot 的一些默认MVC特征，同时又想自定义一些MVC配置（包括：拦截器，格式化器, 视图控制器、消息转换器 等等），你应该让一个类实现WebMvcConfigurer，并且添加@Configuration注解，但是千万不要加@EnableWebMvc注解。如果你想要自定义HandlerMapping、HandlerAdapter、ExceptionResolver等组件，你可以创建一个WebMvcRegistrationsAdapter实例 来提供以上组件。如果你想要完全自定义SpringMVC，不保留SpringBoot提供的一切特征，你可以自己定义类并且添加@Configuration注解和@EnableWebMvc注解总结：通过实现WebMvcConfigurer并添加@Configuration注解来实现自定义部分SpringMvc配置。首先我们定义一个拦截器：12345678910111213141516171819public class LoginInterceptor implements HandlerInterceptor &#123; private Logger logger = LoggerFactory.getLogger(LoginInterceptor.class); @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) &#123; logger.debug("preHandle method is now running!"); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) &#123; logger.debug("postHandle method is now running!"); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123; logger.debug("afterCompletion method is now running!"); &#125;&#125;然后，我们定义配置类，注册拦截器：123456789101112131415161718192021@Configurationpublic class MvcConfig implements WebMvcConfigurer&#123; /** * 通过@Bean注解，将我们定义的拦截器注册到Spring容器 * @return */ @Bean public LoginInterceptor loginInterceptor()&#123; return new LoginInterceptor(); &#125; /** * 重写接口中的addInterceptors方法，添加自定义拦截器 * @param registry */ @Override public void addInterceptors(InterceptorRegistry registry) &#123; // 通过registry来注册拦截器，通过addPathPatterns来添加拦截路径 registry.addInterceptor(this.loginInterceptor()).addPathPatterns("/**"); &#125;&#125;结构如下：接下来运行并查看日志：你会发现日志中什么都没有，因为我们记录的log级别是debug，默认是显示info以上，我们需要进行配置。SpringBoot通过logging.level.*=debug来配置日志级别，*填写包名12# 设置com.leyou包的日志级别为debuglogging.level.com.leyou=debug再次运行查看：1232018-05-05 17:50:01.811 DEBUG 4548 --- [p-nio-80-exec-1] com.leyou.interceptor.LoginInterceptor : preHandle method is now running!2018-05-05 17:50:01.854 DEBUG 4548 --- [p-nio-80-exec-1] com.leyou.interceptor.LoginInterceptor : postHandle method is now running!2018-05-05 17:50:01.854 DEBUG 4548 --- [p-nio-80-exec-1] com.leyou.interceptor.LoginInterceptor : afterCompletion method is now running!5.2.整合jdbc和事务spring中的jdbc连接和事务是配置中的重要一环，在SpringBoot中该如何处理呢？答案是不需要处理，我们只要找到SpringBoot提供的启动器即可：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;当然，不要忘了数据库驱动，SpringBoot并不知道我们用的什么数据库，这里我们选择MySQL：1234&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;至于事务，SpringBoot中通过注解来控制。就是我们熟知的@Transactional123456789101112131415@Servicepublic class UserService &#123; @Autowired private UserMapper userMapper; public User queryById(Long id)&#123; return this.userMapper.selectByPrimaryKey(id); &#125; @Transactional public void deleteById(Long id)&#123; this.userMapper.deleteByPrimaryKey(id); &#125;&#125;5.3.整合连接池其实，在刚才引入jdbc启动器的时候，SpringBoot已经自动帮我们引入了一个连接池：HikariCP应该是目前速度最快的连接池了，我们看看它与c3p0的对比：因此，我们只需要指定连接池参数即可：12345678910# 连接四大参数spring.datasource.url=jdbc:mysql://localhost:3306/heimaspring.datasource.username=rootspring.datasource.password=123# 可省略，SpringBoot自动推断spring.datasource.driverClassName=com.mysql.jdbc.Driverspring.datasource.hikari.idle-timeout=60000spring.datasource.hikari.maximum-pool-size=30spring.datasource.hikari.minimum-idle=10当然，如果你更喜欢Druid连接池，也可以使用Druid官方提供的启动器：123456&lt;!-- Druid连接池 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.6&lt;/version&gt;&lt;/dependency&gt;而连接信息的配置与上面是类似的，只不过在连接池特有属性上，方式略有不同：12345678910#初始化连接数spring.datasource.druid.initial-size=1#最小空闲连接spring.datasource.druid.min-idle=1#最大活动连接spring.datasource.druid.max-active=20#获取连接时测试是否可用spring.datasource.druid.test-on-borrow=true#监控页面启动spring.datasource.druid.stat-view-servlet.allow=true5.4.整合mybatis5.4.1.mybatisSpringBoot官方并没有提供Mybatis的启动器，不过Mybatis官网自己实现了：123456&lt;!--mybatis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt;配置，基本没有需要配置的：1234# mybatis 别名扫描mybatis.type-aliases-package=com.heima.pojo# mapper.xml文件位置,如果没有映射文件，请注释掉mybatis.mapper-locations=classpath:mappers/*.xml需要注意，这里没有配置mapper接口扫描包，因此我们需要给每一个Mapper接口添加@Mapper注解，才能被识别。123@Mapperpublic interface UserMapper &#123;&#125;5.4.2.通用mapper通用Mapper的作者也为自己的插件编写了启动器，我们直接引入即可：123456&lt;!-- 通用mapper --&gt;&lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt;&lt;/dependency&gt;不需要做任何配置就可以使用了。123@Mapperpublic interface UserMapper extends tk.mybatis.mapper.common.Mapper&lt;User&gt;&#123;&#125;5.5.启动测试将controller进行简单改造：123456789101112@RestControllerpublic class HelloController &#123; @Autowired private UserService userService; @GetMapping("/hello") public User hello() &#123; User user = this.userService.queryById(8L); return user; &#125;&#125;我们启动项目，查看：6.Thymeleaf快速入门SpringBoot并不推荐使用jsp，但是支持一些模板引擎技术：以前大家用的比较多的是Freemarker，但是我们今天的主角是Thymeleaf！6.1.为什么是Thymeleaf？简单说， Thymeleaf 是一个跟 Velocity、FreeMarker 类似的模板引擎，它可以完全替代 JSP 。相较与其他的模板引擎，它有如下三个极吸引人的特点：动静结合：Thymeleaf 在有网络和无网络的环境下皆可运行，即它可以让美工在浏览器查看页面的静态效果，也可以让程序员在服务器查看带数据的动态页面效果。这是由于它支持 html 原型，然后在 html 标签里增加额外的属性来达到模板+数据的展示方式。浏览器解释 html 时会忽略未定义的标签属性，所以 thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示。开箱即用：它提供标准和spring标准两种方言，可以直接套用模板实现JSTL、 OGNL表达式效果，避免每天套模板、该jstl、改标签的困扰。同时开发人员也可以扩展和创建自定义的方言。多方言支持：Thymeleaf 提供spring标准方言和一个与 SpringMVC 完美集成的可选模块，可以快速的实现表单绑定、属性编辑器、国际化等功能。与SpringBoot完美整合，SpringBoot提供了Thymeleaf的默认配置，并且为Thymeleaf设置了视图解析器，我们可以像以前操作jsp一样来操作Thymeleaf。代码几乎没有任何区别，就是在模板语法上有区别。接下来，我们就通过入门案例来体会Thymeleaf的魅力：6.2.编写接口编写一个controller，返回一些用户数据，放入模型中，等会在页面渲染123456789@GetMapping("/all")public String all(ModelMap model) &#123; // 查询用户 List&lt;User&gt; users = this.userService.queryAll(); // 放入模型 model.addAttribute("users", users); // 返回模板名称（就是classpath:/templates/目录下的html文件名） return "users";&#125;6.3.引入启动器直接引入启动器：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt;SpringBoot会自动为Thymeleaf注册一个视图解析器：与解析JSP的InternalViewResolver类似，Thymeleaf也会根据前缀和后缀来确定模板文件的位置：默认前缀：classpath:/templates/默认后缀：.html所以如果我们返回视图：users，会指向到 classpath:/templates/users.html一般我们无需进行修改，默认即可。6.4.静态页面根据上面的文档介绍，模板默认放在classpath下的templates文件夹，我们新建一个html文件放入其中：编写html模板，渲染模型中的数据：注意，把html 的名称空间，改成：xmlns:th=&quot;http://www.thymeleaf.org&quot; 会有语法提示12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;首页&lt;/title&gt; &lt;style type="text/css"&gt; table &#123;border-collapse: collapse; font-size: 14px; width: 80%; margin: auto&#125; table, th, td &#123;border: 1px solid darkslategray;padding: 10px&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div style="text-align: center"&gt; &lt;span style="color: darkslategray; font-size: 30px"&gt;欢迎光临！&lt;/span&gt; &lt;hr/&gt; &lt;table class="list"&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;用户名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;生日&lt;/th&gt; &lt;th&gt;备注&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each="user : $&#123;users&#125;"&gt; &lt;td th:text="$&#123;user.id&#125;"&gt;1&lt;/td&gt; &lt;td th:text="$&#123;user.name&#125;"&gt;张三&lt;/td&gt; &lt;td th:text="$&#123;user.userName&#125;"&gt;zhangsan&lt;/td&gt; &lt;td th:text="$&#123;user.age&#125;"&gt;20&lt;/td&gt; &lt;td th:text="$&#123;user.sex&#125; == 1 ? '男': '女'"&gt;男&lt;/td&gt; &lt;td th:text="$&#123;#dates.format(user.birthday, 'yyyy-MM-dd')&#125;"&gt;1980-02-30&lt;/td&gt; &lt;td th:text="$&#123;user.note&#125;"&gt;1&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;我们看到这里使用了以下语法：${} ：这个类似与el表达式，但其实是ognl的语法，比el表达式更加强大th-指令：th-是利用了Html5中的自定义属性来实现的。如果不支持H5，可以用data-th-来代替th:each：类似于c:foreach 遍历集合，但是语法更加简洁th:text：声明标签中的文本例如&lt;td th-text=&#39;${user.id}&#39;&gt;1&lt;/td&gt;，如果user.id有值，会覆盖默认的1如果没有值，则会显示td中默认的1。这正是thymeleaf能够动静结合的原因，模板解析失败不影响页面的显示效果，因为会显示默认值！6.5.测试接下来，我们打开页面测试一下：6.6.模板缓存Thymeleaf会在第一次对模板解析之后进行缓存，极大的提高了并发处理能力。但是这给我们开发带来了不便，修改页面后并不会立刻看到效果，我们开发阶段可以关掉缓存使用：12# 开发阶段关闭thymeleaf的模板缓存spring.thymeleaf.cache=false注意：​ 在Idea中，我们需要在修改页面后按快捷键：Ctrl + Shift + F9 对项目进行rebuild才可以。​ eclipse中没有测试过。我们可以修改页面，测试一下。]]></content>
      <categories>
        <category>springCloud实战</category>
      </categories>
      <tags>
        <tag>springCloud</tag>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义的配置文件的读取]]></title>
    <url>%2F2020%2F03%2F16%2F%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%8F%96%2F</url>
    <content type="text"><![CDATA[​ 自定义的配置文件读取，其实就是如何自己读取配置文件罢了，之间没有自己读过都是靠着框架来读取的，最近看到了就稍微的补充一下。首先配置文件的形式是properties的格式，考虑到会有多个线程访问这个配置文件，所以使用双重校验锁的单例模式来获取配置文件123456789101112131415161718public class PropertyHolderLazy &#123; private static Properties prop = null; public static Properties getProps() throws Exception &#123; if (prop == null) &#123; synchronized (PropertyHolderLazy.class) &#123; if (prop == null) &#123; prop = new Properties(); // getResourceAsStream的目录因该为src的目录prop.load(PropertyHolderLazy.class.getClassLoader().getResourceAsStream("collect.properties")); &#125; &#125; &#125; return prop; &#125;&#125;123// 获取配置参数Properties props = PropertyHolderLazy.getProps();props.getProperty("LOG_LEGAL_PREFIX"); // 建议使用一个变量的类，来进行获取部分的配置文件：12345LOG_SOURCE_DIR=d:/logs/accesslog/LOG_TOUPLOAD_DIR=d:/logs/toupload/LOG_BACKUP_BASE_DIR=d:/logs/backup/LOG_BACKUP_TIMEOUT=24LOG_LEGAL_PREFIX=access.log.​ 上面这种是配置文件的全部的读取，下面这种是部分读取到类中，作为一个对象类的属性参数来使用的。不过这次的文件格式是yml格式的。​ 如下，这是配置参数中的部分的内容123456789101112ly: jwt: pubKeyPath: /Users/bystander/id_rsa.pub # 公钥地址 cookieName: LY_TOKEN # cookie的名称 filter: allowPaths: - /api/auth - /api/search - /api/user/register - /api/user/check - /api/user/code - /api/item123456789101112131415161718192021@ConfigurationProperties(prefix = "ly.jwt")@Data@Slf4j // lombok中的注解，等同 rivate final Logger logger = LoggerFactory.getLogger(当前类名.class);// 写上后可直接使用log.info();等等日志打印的方式public class JwtProperties &#123; private String pubKeyPath; private PublicKey publicKey; // 此属性不在配置文件中，不存在默认不读取， private String cookieName; @PostConstruct ① public void init() &#123; try &#123; //获取公钥 publicKey = RsaUtils.getPublicKey(pubKeyPath); &#125; catch (Exception e) &#123; log.error("初始化公钥失败", e); throw new RuntimeException(); &#125; &#125;&#125;同类型配置字段，读取为数组，还是上面的配置文件12345@Data@ConfigurationProperties(prefix = "ly.filter")public class FilterProperties &#123; private List&lt;String&gt; allowPaths;&#125;@ConfigurationProperties注解较@Value注解支持复杂类型封装注解。@ConfigurationProperties能够批量注入配置文件的属性。@Value只能一个个指定@ConfigurationProperties支持松散绑定。@ConfigurationProperties(prefix = “person”)，只需要指定一个前缀，就能绑定有这个前缀的所有属性值。注①123456@PostConstruct是java5的时候引入的注解，指的是在项目启动的时候执行这个方法，也可以理解为在spring容器启动的时候执行，可作为一些数据的常规化加载，比如数据字典之类的。被@PostConstruct修饰的方法会在服务器加载Servle的时候运行，并且只会被服务器执行一次。PostConstruct在构造函数之后执行 加载顺序为：服务器加载Servlet -&gt; servlet 构造函数的加载 -&gt; postConstruct -&gt;init（init是在service 中的初始化方法. 创建service 时发生的事件.） -&gt;Service-&gt;destory-&gt;predestory-&gt;服务器卸载serlvet那么问题：spring中Constructor、@Autowired、@PostConstruct的顺序Constructor &gt;&gt; @Autowired &gt;&gt; @PostConstruct]]></content>
      <categories>
        <category>工具</category>
        <category>配置文件</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>配置文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hadoop客户端的使用]]></title>
    <url>%2F2020%2F03%2F13%2Fhadoop%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[​ 使用java代码，将本地文件传递到hdfs中。需要自己放入依赖的jar包，这是一些实例代码，作为参考使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183package com.king.bigdata;import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.fs.FileSystem;import org.apache.hadoop.fs.Path;import java.net.URI;public class HdfsClientDemo &#123; public static void main(String[] args) throws Exception &#123; /** * Configuration参数对象的机制： * 构造时，会加载jar包中的默认配置 xx-default.xml * 再加载 用户配置xx-site.xml ，覆盖掉默认参数 * 构造完成之后，还可以conf.set("p","v")，会再次覆盖用户配置文件中的参数值 */ // new Configuration()会从项目的classpath中加载core-default.xml hdfs-default.xml core-site.xml hdfs-site.xml等文件 Configuration conf = new Configuration(); // 指定本客户端上传文件到hdfs时需要保存的副本数为：2 conf.set("dfs.replication", "2"); // 指定本客户端上传文件到hdfs时切块的规格大小：64M conf.set("dfs.blocksize", "64m"); // 构造一个访问指定HDFS系统的客户端对象: 参数1:——HDFS系统的URI，参数2：——客户端要特别指定的参数，参数3：客户端的身份（用户名） FileSystem fs = FileSystem.get(new URI("hdfs://hdf-01:9000/"), conf, "root"); // 上传一个文件到HDFS中 fs.copyFromLocalFile(new Path("D:/jdk-8u241-linux-x64.tar.gz"), new Path("/aaa/")); fs.close(); &#125; FileSystem fs = null; @Before public void init() throws Exception&#123; Configuration conf = new Configuration(); conf.set("dfs.replication", "2"); conf.set("dfs.blocksize", "64m"); fs = FileSystem.get(new URI("hdfs://hdf-01:9000/"), conf, "root"); &#125; /** * 从HDFS中下载文件到客户端本地磁盘 * @throws IOException * @throws IllegalArgumentException */ @Test public void testGet() throws IllegalArgumentException, IOException&#123; fs.copyToLocalFile(new Path("/hdp20-05.txt"), new Path("f:/")); fs.close(); &#125; /** * 在hdfs内部移动文件\修改名称 */ @Test public void testRename() throws Exception&#123; fs.rename(new Path("/install.log"), new Path("/aaa/in.log")); fs.close(); &#125; /** * 在hdfs中创建文件夹 */ @Test public void testMkdir() throws Exception&#123; fs.mkdirs(new Path("/xx/yy/zz")); // 如果使用命令行添加多个文件夹 fs.close(); &#125; /** * 在hdfs中删除文件或文件夹 */ @Test public void testRm() throws Exception&#123; fs.delete(new Path("/aaa"), true); fs.close(); &#125; /** * 查询hdfs指定目录下的文件信息 */ @Test public void testLs() throws Exception&#123; // 只查询文件的信息,不返回文件夹的信息 RemoteIterator&lt;LocatedFileStatus&gt; iter = fs.listFiles(new Path("/"), true); while(iter.hasNext())&#123; LocatedFileStatus status = iter.next(); System.out.println("文件全路径："+status.getPath()); System.out.println("块大小："+status.getBlockSize()); System.out.println("文件长度："+status.getLen()); System.out.println("副本数量："+status.getReplication()); System.out.println("块信息："+Arrays.toString(status.getBlockLocations())); System.out.println("--------------------------------"); &#125; fs.close(); &#125; /** * 查询hdfs指定目录下的文件和文件夹信息(无递归) */ @Test public void testLs2() throws Exception&#123; FileStatus[] listStatus = fs.listStatus(new Path("/")); for(FileStatus status:listStatus)&#123; System.out.println("文件全路径："+status.getPath()); System.out.println(status.isDirectory()?"这是文件夹":"这是文件"); System.out.println("块大小："+status.getBlockSize()); System.out.println("文件长度："+status.getLen()); System.out.println("副本数量："+status.getReplication()); System.out.println("--------------------------------"); &#125; fs.close(); &#125; /** * 读取hdfs中的文件的内容 * * @throws IOException * @throws IllegalArgumentException */ @Test public void testReadData() throws IllegalArgumentException, IOException &#123; FSDataInputStream in = fs.open(new Path("/test.txt")); BufferedReader br = new BufferedReader(new InputStreamReader(in, "utf-8")); String line = null; while ((line = br.readLine()) != null) &#123; System.out.println(line); &#125; br.close(); in.close(); fs.close(); &#125; /** * 读取hdfs中文件的指定偏移量范围的内容 * * * 作业题：用本例中的知识，实现读取一个文本文件中的指定BLOCK块中的所有数据 * * @throws IOException * @throws IllegalArgumentException */ @Test public void testRandomReadData() throws IllegalArgumentException, IOException &#123; FSDataInputStream in = fs.open(new Path("/xx.dat")); // 将读取的起始位置进行指定 in.seek(12); // 读16个字节 byte[] buf = new byte[16]; in.read(buf); System.out.println(new String(buf)); in.close(); fs.close(); &#125; /** * 往hdfs中的文件写内容 * * @throws IOException * @throws IllegalArgumentException */ @Test public void testWriteData() throws IllegalArgumentException, IOException &#123; FSDataOutputStream out = fs.create(new Path("/zz.jpg"), false); // D:\images\006l0mbogy1fhehjb6ikoj30ku0ku76b.jpg FileInputStream in = new FileInputStream("D:/images/006l0mbogy1fhehjb6ikoj30ku0ku76b.jpg"); byte[] buf = new byte[1024]; int read = 0; while ((read = in.read(buf)) != -1) &#123; out.write(buf,0,read); &#125; in.close(); out.close(); fs.close(); &#125;&#125;]]></content>
      <categories>
        <category>hadoop</category>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos7设置静态ip并连接外网]]></title>
    <url>%2F2020%2F03%2F11%2Fcentos7%E8%AE%BE%E7%BD%AE%E9%9D%99%E6%80%81ip%E5%B9%B6%E8%BF%9E%E6%8E%A5%E5%A4%96%E7%BD%91%2F</url>
    <content type="text"><![CDATA[此教程可能不具有统一性，非放之四海而皆准，谨慎参考，避免骂娘！​ 打算学习大数据，第一步就是和Linux又打交道了，我们准备了！四台虚拟机分别为hdf-01到hdf-04。配置思想如下图(我自己配置的ip与图片中的ip并不相同):1.虚拟机与宿主机的IP设置​ 打开vmware的编辑下的虚拟网络编辑器记下子网IP与下图的NAT设置下的网关地址。然后打开本机上的网络设置，VMnet8的ipv4属性，设置IP地址。将网关设置与上图的NAT网关相同，IP地址同意网段内随便写，不要重复。2.对虚拟机的ip设置打开虚拟机后，进入/etc/sysconfig/network-scripts/,使用 vi 编辑器打开 ifcfg-ens33文件，不同的机器下文件后的数字不尽相同，自己判断。12345678910111213141516171819202122TYPE=EthernetPROXY_METHOD=noneBROWSER_ONLY=noBOOTPROTO=static #改为staticDEFROUTE=yesIPV4_FAILURE_FATAL=noIPV6INIT=yesIPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_FAILURE_FATAL=noIPV6_ADDR_GEN_MODE=stable-privacyNAME=ens33UUID=01ad6d15-77de-46d0-9d5f-7143e7c557d4DEVICE=ens33ONBOOT=yes # 改为yes，可以自动启动IPADDR=192.168.10.149 # IP地址改为，与网关同意网段的任意地址（不能重复，不能超过255）GATEWAY=192.168.10.2 # 网关改成ANT设置中的网关，自己添加的时候一定要注意单词的拼写NETMASK=255.255.255.0 # 子网掩码，不必多说了DNS1=8.8.8.8 # DNS写不写都行吧，写上也不费事DNS2=114.114.114.114NM_CONTROLLED=noHWADDR=00:0C:29:D0:5F:CA这些配置好后，基本上就可以ping通外网了，最后，当前的虚拟机的网络模式要选择好呀！如图成果3.scp的使用多个虚拟机安装软件的时候，比如java运行环境的安装，一个一个的进行安装太过于麻烦，可以安装一个后，使当前的安装好后的文件夹直接贴附于另一台虚拟机下。说干就干，先看安装1yum install openssh-clients # 很简单，一句yes就可以了我将java的运行环境装在了/apps/jdk8…….，想将这个目录贴于其他主机之上运行下面的代码1scp -r apps/ 192.168.10.146:/ #存放到了根目录下，可以配置host文件映射，使用主机名代替IP地址4.配置免密登陆​ 此处的免密登陆是从一台虚拟机到另外的几台虚拟机,是为了hadop启动其他的节点更为方便。首先1ssh-keygen #生成key，之后两次回车即可此处我在/etc/hosts文件中配置了地址映射，1234192.168.10.149 hdf-01192.168.10.148 hdf-02192.168.10.147 hdf-03192.168.10.146 hdf-04如果没有配置要使用IP地址，然后执行下面命令!123ssh-copy-id hdf-01 #虽然在hdf-01上生成了key，但是也需要在hdf-01上也来一下..........ssh-copy-id hdf-04 # 要输入虚拟机登陆的密码5.安装hadoop集群在hadoop的安装地址 /apps/hadoop-2.9.2下的etc/hadoop目录中修改hadoop-env.sh1export JAVA_HOME=/apps/jdk1.8.0_241修改core-site.xml123456&lt;configuration&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://hdf-01:9000&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt;修改hdfs-site.xm12345678910&lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt; &lt;value&gt;/root/dfs/name&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt; &lt;value&gt;/root/dfs/data&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt;配置环境变量123export JAVA_HOME=/apps/jdk1.8.0_241export HADOOP_HOME=/apps/hadoop-2.9.2export PATH=$PATH:$JAVA_HOME/bin:$HADOOP_HOME/bin:$HADOOP_HOME/sbin使用scp将hdf-01虚拟机下的hadoop安装到其他机器上12scp -r /apps/hadoop-2.9.2 hdf-02:/apps......6.启动HDFS初始化namenode的元数据目录在hdf-01上执行命令来初始化元数据存储目录并启动12hadoop namenode -format # 初始化hadoop-daemon.sh start namenode # 启动namenode进程然后在windows中用浏览器访问namenode提供的web端口 500701http://hdf-01:50070 # 需要关闭centos7的防火墙然后，启动众datanode们（在任意地方）1hadoop-daemon.sh start datanode7.批量启动脚本来启动HDFS配置hdf-01到所有集群中所有机器（包括自己）的免密登陆（见上方）配置完免密，可以执行一次 ssh0.0.0.0修改hadoop安装目录中 /etc/hadoop/slaves（把需要启动datanode进程的节点列入）1234hdf-01hdf-02hdf-03hdf-04在hdp-01上用脚本：start-dfs.sh 来自动启动整个集群。如果要停止，则用脚本：stop-dfs.sh8.hdfs常用操作命令1.上传到hdfs中123hadoop fs -put /本地文件 /aaa hadoop fs -copyFromLocal /本地文件 /hdfs路径 # copyFromLocal等价于 puthadoop fs -moveFromLocal /本地文件 /hdfs路径 # 跟copyFromLocal的区别是：从本地移动到hdfs中2.下载文件到客户端本地磁盘123hadoop fs -get /hdfs中的路径 /本地磁盘目录hadoop fs -copyToLocal /hdfs中的路径 /本地磁盘路径 ## 跟get等价hadoop fs -moveToLocal /hdfs路径 /本地路径 ## 从hdfs中移动到本地3.在hdfs中创建文件夹1hadoop fs -mkdir -p /aaa/xxx4.移动hdfs中的文件（更名）1hadoop fs -mv /hdfs的路径 /hdfs的另一个路径5.删除hdfs中文件或者文件夹1hadoop fs -rm -r /aaa6.修改文件的权限12hadoop fs -chown user:group /aaahadoop fs -chmod 700 /aaa7.追加内容到已存在的文件1hadoop fs -appendToFile /本地文件 /hdfs中的文件8.显示文本文件的内容12hadoop fs -cat /hdfs中的文件hadoop fs -tail /hdfs中的文件]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>bigData</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习笔记]]></title>
    <url>%2F2020%2F02%2F28%2Fpython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[python笔记python的字符串​ 1. 字符串类型有独特的索引机制，可以正着数也可以倒着数；从字符串中取单个字符串或者字串的方式分别为:123456#单个字符串,拿去最后一个字符TempStr[-1] #拿取字符子串,从第一个到第三个字符（但是不包括第三个）TempStr[1:3]#从头拿到最后一个但是不包括最后一个TempStr[0:-1]​ 字符串中的转义符python中表示字符串的方法有很多，使用单引号、双引号、三引号都可以的；字符串中有单引号，外层就是用双引号，字符串中有使用双引号的，外层就包裹单引号，如果字符串中有双引号也有单引号、那就使用三引号进行包裹;12a='''一切都像是,刚睡醒一样'''print("朱自清春的第一句&#123;&#125;".format(a))4.nuicode编码切换常见的字符串处理方法槽的格式的控制具体使用字符串进度条123456789101112import timescale = 50print("执行开始".center(scale//2,"-")) # 求商然后取整，位于字符的中间位置了start = time.perf_counter()for i in range(scale+1): a="*"*i; b="."*(scale-i) c=(i/scale)*100 dur=time.perf_counter()-start print("\r&#123;:^3.0f&#125;%[&#123;&#125;&#123;&#125;]&#123;:.2f&#125;s".format(c,a,b,dur),end='') # \r移动光标到最开始的位置 time.sleep(0.1)print("\n"+"执行结束".center(scale//2,'-'))输出结果：123-----------执行开始----------100%[**************************************************]5.05s-----------执行结束----------8.国际与国内BMI指数计算1234567891011121314151617height, weight = eval(input("请输入身高(米)和体重(公斤)[使用逗号隔开]："))bmi = weight / pow(height, 2)print("BMI 数值为：&#123;:.2f&#125;".format(bmi))who, nat = "", ""if bmi &lt; 18.5: who, nat = "偏瘦", "偏瘦"elif 18.5 &lt;= bmi &lt; 24: who, nat = "正常", "正常"elif 24 &lt;= bmi &lt; 25: who, nat = "正常", "偏胖"elif 25 &lt;= bmi &lt; 28: who, nat = "偏胖", "偏胖"elif 28 &lt;= bmi &lt; 30: who, nat = "偏胖", "肥胖"else: who, nat = "肥胖", "肥胖"print("BMI指标为：国际&#123;&#125;,国内&#123;&#125;".format(who,nat))python常用库random随机数计算机中不会真正的产生随机数。ptyhon中的随机数会设置一个seed值，seed值设置相同出现的随机数也就相同，未设置seed的值，会默认为当前时间。12345import randomrandom.seed(10)print(random.random())random.seed(10)print(random.random())两次输出结果一样都是 0.5714025946899135圆周率的计算（蒙特卡洛方式计算）：12345678910111213from random import randomfrom time import perf_counterDarts =10000*10000hits =0.0start =perf_counter()for i in range(1,Darts+1): x,y=random(),random() dist=pow(x**2 +y**2,0.5) if dist &lt;=1.0: hits=hits+1pi=4*(hits/Darts)print("圆周率为：&#123;&#125;".format(pi))print("运行时间&#123;:.5f&#125;s".format(perf_counter()-start))python变量python中在函数中有局部变量和全局变量相同时，要在函数中使用全局变量，需要使用保留字 global123456789101112131415161718192021222324252627282930313233343536373839404142434445import turtledef drawLine(draw): drawGap() turtle.pendown() if (draw) else turtle.penup() turtle.fd(40) drawGap() turtle.right(90)def drawDigit(digit): drawLine(True) if (digit) in [2, 3, 4, 5, 6, 8, 9] else drawLine(False) drawLine(True) if (digit) in [0, 1, 3, 4, 5, 6, 7, 8, 9] else drawLine(False) drawLine(True) if (digit) in [0, 2, 3, 5, 6, 8] else drawLine(False) drawLine(True) if (digit) in [0, 2, 6, 8] else drawLine(False) turtle.left(90) drawLine(True) if (digit) in [0, 4, 5, 6, 8, 9] else drawLine(False) drawLine(True) if (digit) in [0, 2, 3, 5, 6, 7, 8, 9] else drawLine(False) drawLine(True) if (digit) in [0, 1, 2, 3, 4, 7, 8, 9] else drawLine(False) turtle.left(180) turtle.penup() turtle.fd(20)def drawDate(date): for i in date: drawDigit(eval(i))def main(): turtle.setup(800, 350, 200, 200) turtle.penup() turtle.fd(-300) turtle.pensize(5) drawDate("20200221") turtle.hideturtle() turtle.done()main()# 增加小间隔更像数码管def drawGap(): turtle.penup() turtle.fd(5)python的第三方库的安装​ 使用pip进行安装，有时候会有pip在cmd下不是命令的报错，需要将python的安装目录下的Script文件夹加入到Path的环境变量之中即可。1pip install pyinstallerpyinstaller这个第三方库可以将python的程序打包为直接可执行的程序，比如exe之类的。打包命令为：1pyinstaller -F &lt;文件名.py&gt;相关参数如下：加图标的打包命令：1pyinstaller -i &lt;图标名称.ico&gt; -F &lt;文件名.py&gt;python递归基本上都一样，这记一个科恩曲线，表示一下：1234567891011121314151617181920212223import turtledef koch(size,n): if n==0: turtle.fd(size) else: for angle in [0,60,-120,60]: turtle.left(angle) koch(size/3,n-1)def main(): turtle.setup(600,600) turtle.penup() turtle.goto(-200,100) turtle.pendown() turtle.pensize(2) level=5 koch(400,level) turtle.right(120) koch(400,level) turtle.right(120) koch(400, level) turtle.hideturtle() turtle.done()main()python集合python的集合没有重复的元素，使用{}或者set()建立集合1234A=&#123;"python",123,("python",123)&#125;print(A) #&#123;'python', ('python', 123), 123&#125;B=set("pypy123") print(B) # &#123;'2', '3', '1', 'p', 'y'&#125;集合的操作符12S &lt;= T 或者 S &lt; T 返回True/False，判断S和T的子集关系S &gt;= T 或者 S &gt; T 返回True/False, 判断S和T的包含关系集合的操作方法数组去重：123ls = ["p","p","y","y",123]s = set(ls) # 利用集合无重复的特点it = list(s) # 将集合转换回数组python序列1ls = ["123",123,"lsss"]元组类型的方法：python元组类型元组类型一旦被创建就不可以被修改了，可以用圆括号表示也可以不用，python的函数中可以返回两个值12def func(): return 1,2在内部会被解析成为一个元组类型返回出去;因为元组的不可改变的特性，可以将序列改变为元组起到保护数据的作用:12lt = tuole(ls) # 将序列变为元组ls = list(lt) # 将序列变为元组python 字典类型字典类型是映射的体现，字典是键值对的集合，键值对之间无序，采用大括号{}和dict()创建，键值对用冒号：表示1&#123;&lt;键1&gt;:&lt;值1&gt;,&lt;键2&gt;:&lt;值2&gt;&#125;]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>其他语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6入门]]></title>
    <url>%2F2020%2F01%2F10%2FES6%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[let命令​ let与var在的区别:let只在所定义的代码块中有用，var则是在整个函数中都阔以用（自己理解，还没验证）。let不存在变量提升的问题，变量提升就是，先使用再定义，不报错，只是会提示undefinde。123456// var情况console.log(foo); // 输出undefindevar foo=2;// let情况console.log(foo); // 报错ReferencrErrorlet foo=2;和var一样在同一作用域不可以重复声明。区块作用域​ 在es5中区块中不可定义函数而es6中可以。但是并不鼓励这么使用….123if(true)&#123; function f()&#123;&#125; // es5中是会报错的&#125;避免不了可以使用函数表达式123if(true)&#123; let f = function f()&#123;&#125; // es5中是会报错的&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>理论</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手写SpringAop]]></title>
    <url>%2F2020%2F01%2F07%2F%E6%89%8B%E5%86%99SpringAop%2F</url>
    <content type="text"><![CDATA[Spring的核心技术​ spring的核心技术有AOP与IOC，控制反转与面向切面编程，首先对于AOP有一些概念的解释，AOP的作用很多，日志打印、权限管理等等。123456关注点：重复代码就叫做关注点；切面：关注点形成的类，就叫切面(类)！面向切面编程，就是指 对很多功能都有的重复的代码抽取，再在运行的时候网业务方法上动态植入“切面类代码”。切入点：执行目标对象方法，动态植入切面代码。可以通过切入点表达式，指定拦截哪些类的哪些方法； 给指定的类在运行的时候植入切面类代码。1234567@Aspect 指定一个类为切面类 @Pointcut("execution(* com.itmayiedu.service.UserService.add(..))") 指定切入点表达式@Before("pointCut_()") 前置通知: 目标方法之前执行@After("pointCut_()") 后置通知：目标方法之后执行（始终执行）@AfterReturning("pointCut_()") 返回后通知： 执行方法结束前执行(异常不执行)@AfterThrowing("pointCut_()") 异常通知: 出现异常时候执行@Around("pointCut_()") 环绕通知： 环绕目标方法执行SpringAop的demo12345678910111213141516171819202122232425262728293031323334353637@Component@Aspectpublic class AopLog &#123; // 前置通知 @Before("execution(* com.itmayiedu.service.UserService.add(..))") public void begin() &#123; System.out.println("前置通知"); &#125; // // 后置通知 @After("execution(* com.itmayiedu.service.UserService.add(..))") public void commit() &#123; System.out.println("后置通知"); &#125; // 运行通知 @AfterReturning("execution(* com.itmayiedu.service.UserService.add(..))") public void returning() &#123; System.out.println("运行通知"); &#125; // 异常通知 @AfterThrowing("execution(* com.itmayiedu.service.UserService.add(..))") public void afterThrowing() &#123; System.out.println("异常通知"); &#125; // 环绕通知 @Around("execution(* com.itmayiedu.service.UserService.add(..))") public void around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable &#123; System.out.println("环绕通知开始"); proceedingJoinPoint.proceed(); System.out.println("环绕通知结束"); &#125;&#125;Spring的声明式事务管理Spring声明式事务管理器类：Jdbc技术：DataSourceTransactionManagerHibernate技术：HibernateTransactionManager编程式事务实现：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Componentpublic class TransactionUtils &#123; @Autowired private DataSourceTransactionManager dataSourceTransactionManager; // 开启事务 public TransactionStatus begin() &#123; TransactionStatus transaction = dataSourceTransactionManager.getTransaction(new DefaultTransactionAttribute()); return transaction; &#125; // 提交事务 public void commit(TransactionStatus transactionStatus) &#123; dataSourceTransactionManager.commit(transactionStatus); &#125; // 回滚事务 public void rollback(TransactionStatus transactionStatus) &#123; dataSourceTransactionManager.rollback(transactionStatus); &#125;&#125;@Servicepublic class UserService &#123; @Autowired private UserDao userDao; @Autowired private TransactionUtils transactionUtils; public void add() &#123; TransactionStatus transactionStatus = null; try &#123; transactionStatus = transactionUtils.begin(); userDao.add("wangmazi", 27); int i = 1 / 0; System.out.println("我是add方法"); userDao.add("zhangsan", 16); transactionUtils.commit(transactionStatus); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (transactionStatus != null) &#123; transactionStatus.rollbackToSavepoint(transactionStatus); &#125; &#125; &#125;&#125;AOP技术封装手动事务12345678910111213141516171819202122232425@Component@Aspectpublic class AopTransaction &#123; @Autowired private TransactionUtils transactionUtils; // // 异常通知 @AfterThrowing("execution(* com.itmayiedu.service.UserService.add(..))") public void afterThrowing() &#123; System.out.println("程序已经回滚"); // 获取程序当前事务 进行回滚 TransactionAspectSupport.currentTransactionStatus().setRollbackOnly(); &#125; // 环绕通知 @Around("execution(* com.itmayiedu.service.UserService.add(..))") public void around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable &#123; System.out.println("开启事务"); TransactionStatus begin = transactionUtils.begin(); proceedingJoinPoint.proceed(); transactionUtils.commit(begin); System.out.println("提交事务"); &#125;&#125;]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>深入了解系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[策略模式与观察者模式]]></title>
    <url>%2F2019%2F11%2F11%2F%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[策略模式什么是策略模式​ 定义了一系列的算法，并将每一个算法封装起来，而且使它们还可以相互替换。策略模式让算法独立于使用它的客户而独立变化。策略模式的运用​ 策略模式的用意是针对一组算法或逻辑，将每一个算法或逻辑封装到具有共同接口的独立的类中，从而使得它们之间可以相互替换。策略模式使得算法或逻辑可以在不影响到客户端的情况下发生变化。说到策略模式就不得不提及OCP(Open Closed Principle) 开闭原则，即对扩展开放，对修改关闭。策略模式的出现很好地诠释了开闭原则，有效地减少了分支语句。此代码通过模拟不同会员购物车打折力度不同分为三种策略，初级会员，中级会员，高级会员1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//策略模式 定义抽象方法 所有支持公共接口abstract class Strategy &#123; // 算法方法 abstract void algorithmInterface();&#125;class StrategyA extends Strategy &#123; @Override void algorithmInterface() &#123; System.out.println("算法A"); &#125;&#125;class StrategyB extends Strategy &#123; @Override void algorithmInterface() &#123; System.out.println("算法B"); &#125;&#125;class StrategyC extends Strategy &#123; @Override void algorithmInterface() &#123; System.out.println("算法C"); &#125;&#125;// 使用上下文维护算法策略class Context &#123; Strategy strategy; public Context(Strategy strategy) &#123; this.strategy = strategy; &#125; public void algorithmInterface() &#123; strategy.algorithmInterface(); &#125;&#125;class ClientTestStrategy &#123; public static void main(String[] args) &#123; Context context; context = new Context(new StrategyA()); context.algorithmInterface(); context = new Context(new StrategyB()); context.algorithmInterface(); context = new Context(new StrategyC()); context.algorithmInterface(); &#125;&#125;观察者模式​ 最初是学习android的时候，做电子商城的下载的时候，需要在多个位置显示下载的进度，所以使用了这个观察者模式，这也可能是我最（实际）早接触的设计模式了。123456public interface Observer &#123; // 观察者方法 void update(Subjecct subjecct);&#125;12345678910111213141516171819202122public class Subjecct &#123; //观察者的存储集合 private List&lt;Observer&gt; list = new ArrayList&lt;&gt;(); // 注册观察者方法 public void registerObserver(Observer obs) &#123; list.add(obs); &#125; // 删除观察者方法 public void removeObserver(Observer obs) &#123; list.remove(obs); this.notifyAllObserver(); &#125; // 通知所有的观察者更新 public void notifyAllObserver() &#123; for (Observer observer : list) &#123; observer.update(this); &#125; &#125;&#125;12345678910111213141516171819202122232425262728293031public class WeatherObserver implements Observer&#123; private String weatherState; private String name; private String activity; @Override public void update(Subjecct subjecct) &#123; weatherState = ((WeatherSubject) subjecct).getState(); System.out.println(name+":"+weatherState+",我准备去"+activity); &#125; public void setName(String name) &#123; this.name = name; &#125; public void setActivity(String activity) &#123; this.activity = activity; &#125; public String getWeatherState() &#123; return weatherState; &#125; public String getName() &#123; return name; &#125; public String getActivity() &#123; return activity; &#125;&#125;12345678910111213public class WeatherSubject extends Subjecct&#123; //被观察对象的属性 private String state; public String getState()&#123; return state; &#125; public void setState(String state)&#123; this.state=state; //主题对象(目标对象)值发生改变 this.notifyAllObserver(); &#125;&#125;1234567891011121314151617181920public class Client &#123; public static void main(String[] args) &#123; // 创建目标 WeatherSubject subjecct = new WeatherSubject(); // 创建观察者 WeatherObserver observerSu = new WeatherObserver(); observerSu.setName("苏"); observerSu.setActivity("图书馆"); WeatherObserver observerYu = new WeatherObserver(); observerYu.setName("吃瓜群众"); observerYu.setActivity("爬山"); // 注册观察者 subjecct.registerObserver(observerSu); subjecct.registerObserver(observerYu); // 发布时间更新 subjecct.setState("明天天气晴朗，24°，阵风3级"); // 当确定不需要再接受广播事件的时候将其取消 subjecct.removeObserver(observerSu); &#125;&#125;print:12苏:明天天气晴朗，24°，阵风3级,我准备去图书馆吃瓜群众:明天天气晴朗，24°，阵风3级,我准备去爬山]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>策略模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[建造者模板适配器外观等设计模式浅显认知]]></title>
    <url>%2F2019%2F10%2F30%2F%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E6%9D%BF%E9%80%82%E9%85%8D%E5%99%A8%E5%A4%96%E8%A7%82%E7%AD%89%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%B5%85%E6%98%BE%E8%AE%A4%E7%9F%A5%2F</url>
    <content type="text"><![CDATA[建造者模式这里以游戏开发中人物的构造过程为例。在游戏中创建一个形象时，需要对每个部位进行创建。简化而言，需要创建头部，身体和四肢。先来个person1234567891011121314151617181920212223242526272829public class Person &#123; private String head; private String body; private String foot; public String getHead() &#123; return head; &#125; public void setHead(String head) &#123; this.head = head; &#125; public String getBody() &#123; return body; &#125; public void setBody(String body) &#123; this.body = body; &#125; public String getFoot() &#123; return foot; &#125; public void setFoot(String foot) &#123; this.foot = foot; &#125;&#125;​ 对应建造各个部位的接口（建造的部位，你可以比作游戏中某些部位的加强，护膝、头盔、胸甲之类的，最后还要负责组装起来）1234567891011public interface Builder &#123; void builderHead(); void builderBody(); void builderFoot(); Person BuilderPersion(); //组装&#125;接口的实现，理解为对应部位装备的加强12345678910111213141516171819202122232425262728public class ConcreteBuilder implements Builder&#123; private Person person; public ConcreteBuilder()&#123; person= new Person(); &#125; @Override public void builderHead() &#123; person.setHead("建造者头部分"); &#125; @Override public void builderBody() &#123; person.setBody("建造者身体"); &#125; @Override public void builderFoot() &#123; person.setFoot("建造者尾部"); &#125; @Override public Person BuilderPersion() &#123; return person; &#125;&#125;最后的使用：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建1234567891011121314151617public class PersonDirector &#123; public Person constructPerson(Builder pb) &#123; pb.builderHead(); pb.builderBody(); pb.builderFoot(); return pb.BuilderPersion(); &#125; public static void main(String[] args) &#123; PersonDirector pb = new PersonDirector(); Person person = pb.constructPerson(new ConcreteBuilder()); System.out.println(person.getHead()); System.out.println(person.getBody()); System.out.println(person.getFoot()); &#125;&#125;print:123建造者头部分建造者身体建造者尾部模板方法模式核心思想：处理某个流程的代码已经都具备，但是其中某个节点的代码暂时不能确定。因此，我们采用工厂方法模式，将这个节点的代码实现转移给子类完成，换句话就是，处理步骤在父类中定义好，具体的实现延迟到子类中定义。说人话就是：就是将一些相同操作的代码，封装成一个算法的骨架。核心的部分留在子类中操作，在父类中只把那些骨架做好银行业务为例子:1234567891011121314151617181920212223// 模板方法public abstract class BankTemplateMethod &#123; // 1.取号排队 public void takeNumber() &#123; System.out.println("取号排队。。"); &#125; // 2.每个子类不同的业务实现，由各自子类实现. abstract void transact(); // 3.评价 public void evaluate() &#123; System.out.println("反馈评价.."); &#125; public void process() &#123; takeNumber(); transact(); evaluate(); &#125; &#125;存钱：123456public class SaveMoney extends BankTemplateMethod&#123; @Override void transact() &#123; System.out.println("我要存款"); &#125;&#125;取钱：123456public class DrawMoney extends BankTemplateMethod&#123; @Override void transact() &#123; System.out.println("我要取款"); &#125;&#125;clent:12345678public class Client &#123; public static void main(String[] args) &#123; BankTemplateMethod bankTemplate=new DrawMoney(); bankTemplate.process(); BankTemplateMethod saveMoney = new SaveMoney(); saveMoney.process(); &#125;&#125;print123456取号排队。。我要取款反馈评价..取号排队。。我要存款反馈评价..外观模式​ 外观模式（Facade Pattern）门面模式，隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。demo：123456789// 邮件发送public interface EamilSmsService &#123; public void sendSms(); &#125;public class EamilSmsServiceImpl implements EamilSmsService&#123; public void sendSms() &#123; System.out.println("发送邮件消息"); &#125;&#125;1234567891011// 微信消息推送public interface WeiXinSmsService &#123; public void sendSms(); &#125;public class EamilSmsServiceImpl implements EamilSmsService&#123; @Override public void sendSms() &#123; System.out.println("发送邮件消息"); &#125;&#125;12345678910// 阿里短信消息public interface AliSmsService &#123; public void sendSms();&#125;public class AliSmsServiceImpl implements AliSmsService &#123; @Override public void sendSms() &#123; System.out.println("支付宝发送消息..."); &#125;&#125;1234567891011121314151617// 门面类public class Computer &#123; AliSmsService aliSmsService; EamilSmsService eamilSmsService; WeiXinSmsService weiXinSmsService; public Computer() &#123; aliSmsService = new AliSmsServiceImpl(); eamilSmsService = new EamilSmsServiceImpl(); weiXinSmsService = new WeiXinSmsServiceImpl(); &#125; public void sendMsg() &#123; aliSmsService.sendSms(); eamilSmsService.sendSms(); weiXinSmsService.sendSms(); &#125;&#125;12345public class Client &#123; public static void main(String[] args) &#123; new Computer().sendMsg(); &#125;&#125;这不就是Java的封装吗？适配器模式在设计模式中，适配器模式（英语：adapter pattern）有时候也称包装样式或者包装(wrapper)。将一个类的接口转接成用户所期待的。一个适配使得因接口不兼容而不能在一起工作的类工作在一起，做法是将类自己的接口包裹在一个已存在的类中。demo：123456//日本110V 电源接口public interface JP110VInterface &#123; public void connect();&#125;12345678public class JP110VInterfaceImpl implements JP110VInterface &#123; @Override public void connect() &#123; System.out.println("日本110V,接通电源,开始工作.."); &#125;&#125;123public interface CN220VInterface &#123; public void connect();&#125;123456789public class CN220VInterfaceImpl implements CN220VInterface &#123; @Override public void connect() &#123; System.out.println("中国220V,接通电源,开始工作"); &#125;&#125;定义一个电饭煲12345678910111213public class ElectricCooker &#123; private JP110VInterface jp110VInterface;//日本电饭煲 ElectricCooker(JP110VInterface jp110VInterface)&#123; this.jp110VInterface=jp110VInterface; &#125; public void cook()&#123; jp110VInterface.connect(); System.out.println("开始做饭了.."); &#125;&#125;电源适配器：12345678910111213public class PowerAdaptor implements JP110VInterface &#123; private CN220VInterface cn220VInterface; public PowerAdaptor(CN220VInterface cn220VInterface) &#123; this.cn220VInterface = cn220VInterface; &#125; @Override public void connect() &#123; cn220VInterface.connect(); &#125;&#125;1234567891011public class AdaptorTest &#123; public static void main(String[] args) &#123; CN220VInterface cn220VInterface = new CN220VInterfaceImpl(); PowerAdaptor powerAdaptor = new PowerAdaptor(cn220VInterface); // 电饭煲 ElectricCooker cooker = new ElectricCooker(powerAdaptor); cooker.cook();//使用了适配器,在220V的环境可以工作了。 &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>建造者</tag>
        <tag>模板</tag>
        <tag>适配</tag>
        <tag>外观</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[静态代理与动态代理]]></title>
    <url>%2F2019%2F10%2F28%2F%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[何为代理模式​ 代理控制对象的访问,可以详细访问某个对象的方法，在这个方法调用处理，或调用后处理。既(AOP微实现)AOP核心技术面向切面编程。静态代理与动态代理静态代理先写一个接口123public interface IUserDao &#123; void save();&#125;接口的实现123456public class IUserDaoImpl implements IUserDao&#123; @Override public void save() &#123; System.out.println("保存输出数据........."); &#125;&#125;进行调用12345678910111213141516171819public class Proxy implements IUserDao&#123; private IUserDao target; public Proxy(IUserDao iuserDao) &#123; this.target = iuserDao; &#125; public void save() &#123; System.out.println("开启事物..."); target.save(); System.out.println("关闭事物..."); &#125; public static void main(String[] args) &#123; IUserDao user=new IUserDaoImpl(); Proxy proxy=new Proxy(user); proxy.save(); &#125;&#125;内容输出123开启事物...保存输出数据.........关闭事物...静态代理模式用起来，太过繁琐。在内容多了以后代码会略显臃肿，静态代理也较为少用。动态代理JDK动态代理​ 是根据类加载器和接口创建代理类（此代理类是接口的实现类，所以必须使用接口面向接口生成代理，位于java.lang.reflect包下）说白了就是使用了反射。*dk动态代理，必须是面向接口，目标业务类必须实现接口​ 简单的一个demo来说明问题，还就静态代理的接口与实现。123456789101112131415161718192021222324252627public class InvocationHandlerImpl implements InvocationHandler &#123; private Object target;// 这其实业务实现类对象，用来调用具体的业务方法 // 通过构造函数传入目标对象 public InvocationHandlerImpl(Object target) &#123; this.target = target; &#125; public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Object result = null; System.out.println("调用开始处理"); result = method.invoke(target, args); System.out.println("调用结束处理"); return result; &#125; public static void main(String[] args) throws NoSuchMethodException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException &#123; // 被代理对象 IUserDao userDao = new IUserDaoImpl(); InvocationHandlerImpl invocationHandlerImpl = new InvocationHandlerImpl(userDao); ClassLoader loader = userDao.getClass().getClassLoader(); Class&lt;?&gt;[] interfaces = userDao.getClass().getInterfaces(); // 主要装载器、一组接口及调用处理动态代理实例 IUserDao newProxyInstance = (IUserDao) Proxy.newProxyInstance(loader, interfaces, invocationHandlerImpl); newProxyInstance.save(); &#125;&#125;输出123调用开始处理保存输出数据.........调用结束处理CGLIB动态代理​ cglib[CodeGeneration Library]实现动态代理，并不要求委托类必须实现接口，底层采用asm字节码生成框架生成代理类的字节码。引入一下依赖12345678910&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.7&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt;&lt;/dependency&gt;动态代理的demo12345678910111213141516171819202122232425public class CglibProxy implements MethodInterceptor &#123; private Object targetObject; // 这里的目标类型为Object，则可以接受任意一种参数作为被代理类，实现了动态代理 public Object getInstance(Object target) &#123; // 设置需要创建子类的类 this.targetObject = target; Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(target.getClass()); enhancer.setCallback(this); return enhancer.create(); &#125; public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; System.out.println("开启事物"); Object result = proxy.invoke(targetObject, args); System.out.println("关闭事物"); // 返回代理对象 return result; &#125; public static void main(String[] args) &#123; CglibProxy cglibProxy = new CglibProxy(); UserDao userDao = (UserDao) cglibProxy.getInstance(new UserDao()); userDao.save(); &#125;&#125;CGLIB动态代理与JDK动态区别java动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。而cglib动态代理是利用asm开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。在Spring中如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP如果目标对象实现了接口，可以强制使用CGLIB实现AOP如果目标对象没有实现了接口，必须采用CGLIB库，spring会自动在JDK动态代理和CGLIB之间转换JDK动态代理只能对实现了接口的类生成代理，而不能针对类 。CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法 。因为是继承，所以该类或方法最好不要声明成final ，final可以阻止继承和多态。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>静态代理</tag>
        <tag>动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker]]></title>
    <url>%2F2019%2F10%2F09%2Fdocker%2F</url>
    <content type="text"><![CDATA[docker 梳理docker的镜像的获取​ 获得docker的redis镜像1docker search redis会得到关于redis的一些镜像12345678910111213141516NAME DESCRIPTION STARS OFFICIAL AUTOMATEDredis Redis is an open source key-value store that… 7381 [OK] bitnami/redis Bitnami Redis Docker Image 128 [OK]sameersbn/redis 77 [OK]grokzen/redis-cluster Redis cluster 3.0, 3.2, 4.0 &amp; 5.0 57 rediscommander/redis-commander Alpine image for redis-commander - Redis man… 31 [OK]kubeguide/redis-master redis-master with &quot;Hello World!&quot; 30 redislabs/redis Clustered in-memory database engine compatib… 23 oliver006/redis_exporter Prometheus Exporter for Redis Metrics. Supp… 18 arm32v7/redis Redis is an open source key-value store that… 17 redislabs/redisearch Redis With the RedisSearch module pre-loaded… 17 webhippie/redis Docker images for Redis 10 [OK]s7anley/redis-sentinel-docker Redis Sentinel 9 [OK]insready/redis-stat Docker image for the real-time Redis monitor… 8 [OK]redislabs/redisgraph A graph database module for Redis 8 [OK]bitnami/redis-sentinel Bitnami Docker Image for Redis Sentinel 7 [OK]将name为redis的镜像拉下来1docker pull redis查看本地的镜像列表1docker images12REPOSITORY TAG IMAGE ID CREATED SIZEredis latest 01a52b3b5cd1 10 days ago 98.2MB有了本地镜像就需要启动一下了1docker run -d redis74beaff66a23a436e49d5b1d65e7edb8a6fe3d01b5489b2a05d77b74b9ec1981此种方式启动是后台启动。执行：1docker ps12CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES74beaff66a23 redis &quot;docker-entrypoint.s…&quot; 8 minutes ago Up 8 minutes 6379/tcp trusting_dirac显示后台中运行着的docker容器。1docker stop 74be参数解析：参数名称参数意义IMAGE创建容器时所使用的镜像COMMAND运行容器中的软件执行的命令CREATED容器的创建时间STATUS容器的状态: UP 表示运行状态 Exited 表示关闭状态PORTS宿主机端口和容器中软件的端口的对应关系NAMES容器的名称CONTAINER ID容器id关闭CONTAINER ID 以74be开头的docker容器。再次执行docker ps后无在运行中的容器。容器停止后无法使用docker ps来查看，但是1docker ps -a可以查看所有的容器（运行中的或者已经停止的）1docker ps -l可以查看最后一次运行的容器。1docker ps -f status=exited可以查看停止的容器。镜像的可以删除的，同样已经创建的容器也是可以删除的12docker rm $CONTAINER_ID/NAME 删除单个容器docker rm `docker ps -a -q` 删除所有的容器当然，此处的删除是退出状态下的容器。执行删除后，容器就不存在了。可以用 *docker ps -f status=exited *验证一下容器退出后还可以再次启动的使用查看停止的容器命令123456CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES74beaff66a23 redis &quot;docker-entrypoint.s…&quot; 20 minutes ago Exited (0) 10 minutes ago trusting_dirac8e0c1259e6a8 redis &quot;docker-entrypoint.s…&quot; 22 minutes ago Exited (0) 21 minutes ago pensive_torvaldsd85bdd153358 redis &quot;docker-entrypoint.s…&quot; About an hour ago Exited (0) 24 minutes ago happy_kowalevski0a3afac8e147 redis &quot;docker-entrypoint.s…&quot; About an hour ago Exited (0) About an hour ago stupefied_hypatia23dfcd1a6787 redis &quot;docker-entrypoint.s…&quot; About an hour ago Exited (0) About an hour ago romantic_golick就CONTAINER ID讲容器启动1docker start $CONTAINER_NAME/ID就上面的后台启动，可以这样进入容器内部1docker exec -it redis /bin/bash退出直接 exit 即可初次启动参数：参数名称参数意义-i运行容器-t表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即分配一个伪终端-d在 run 后面加上-d 参数,则会创建一个守护式容器在后台运行（这样创建容器后不会自动登录容器，如果只加-i -t 两个参数，创建后就会自动进去容器）-name–name 为创建的容器命名-v表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录），可以使用多个－v 做多个目录或文件映射。注意：最好做目录映射，在宿主机上做修改，然后共享到容器上-p表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个－p 做多个端口映射参数运用例子：创建交互形式的容器1docker run -it --name=mjw_tomcat -p 8888:8080 -v /usr/local/webapps/:/usr/local/tomcat/webapps tomcat创建守护式的容器1docker run -di --name=mjw_tomcat2 -p 8088:8080 -v /usr/local/webapps/:/usr/local/tomcat/webapps tomcat另一种启动方式，直接交互式启动。1sudo docker run -it redis12345678910111213141516171819202122232425261:C 06 Oct 2019 16:26:26.073 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo1:C 06 Oct 2019 16:26:26.073 # Redis version=5.0.6, bits=64, commit=00000000, modified=0, pid=1, just started1:C 06 Oct 2019 16:26:26.073 # Warning: no config file specified, using the default config. In order to specify a config file use redis-server /path/to/redis.conf _._ _.-``__ &apos;&apos;-._ _.-`` `. `_. &apos;&apos;-._ Redis 5.0.6 (00000000/0) 64 bit .-`` .-```. ```\/ _.,_ &apos;&apos;-._ ( &apos; , .-` | `, ) Running in standalone mode |`-._`-...-` __...-.``-._|&apos;` _.-&apos;| Port: 6379 | `-._ `._ / _.-&apos; | PID: 1 `-._ `-._ `-./ _.-&apos; _.-&apos; |`-._`-._ `-.__.-&apos; _.-&apos;_.-&apos;| | `-._`-._ _.-&apos;_.-&apos; | http://redis.io `-._ `-._`-.__.-&apos;_.-&apos; _.-&apos; |`-._`-._ `-.__.-&apos; _.-&apos;_.-&apos;| | `-._`-._ _.-&apos;_.-&apos; | `-._ `-._`-.__.-&apos;_.-&apos; _.-&apos; `-._ `-.__.-&apos; _.-&apos; `-._ _.-&apos; `-.__.-&apos; 1:M 06 Oct 2019 16:26:26.074 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.1:M 06 Oct 2019 16:26:26.074 # Server initialized1:M 06 Oct 2019 16:26:26.075 # WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add &apos;vm.overcommit_memory = 1&apos; to /etc/sysctl.conf and then reboot or run the command &apos;sysctl vm.overcommit_memory=1&apos; for this to take effect.1:M 06 Oct 2019 16:26:26.075 # WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command &apos;echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled&apos; as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.1:M 06 Oct 2019 16:26:26.075 * Ready to accept connections但是你Ctrl+c退出后容器也就直接关闭了。(这种方式应该不推荐使用)docker的容器的备份将容器保存为镜像1docker commit 容器名称 保存的新镜像的名讲镜像打包1docker save –o 打包以后的文件名称 镜像名称打包后的镜像的回复1docker load -i 镜像保存的tar包https://blog.csdn.net/Min_JW/article/details/83686051 看这篇文章，对两种启动方式有详细的说明，端口的映射与磁盘的映射]]></content>
      <categories>
        <category>容器</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[狗东商城(四)]]></title>
    <url>%2F2019%2F09%2F16%2F%E7%8B%97%E4%B8%9C%E5%95%86%E5%9F%8E-%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[商品详情​ 商品详情页面会有页面内的Tab，然后还有广播的发送，与接收，接收到广播后弹出窗口。对购物车的商品的类型进行选择。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333import 'package:flutter/material.dart';import '../../service/ScreenAdaper.dart';import '../../widget/JdButton.dart';import '../../model/ProductContentModel.dart';import '../../config/Config.dart';import '../../service/EventBus.dart';import './CartNum.dart';import '../../service/CartServices.dart';import 'package:provider/provider.dart';import '../../provider/Cart.dart';import 'package:fluttertoast/fluttertoast.dart';class ProductContentFirst extends StatefulWidget &#123; final List _productContentList; ProductContentFirst(this._productContentList,&#123;Key key&#125;) : super(key: key); _ProductContentFirstState createState() =&gt; _ProductContentFirstState();&#125;class _ProductContentFirstState extends State&lt;ProductContentFirst&gt; with AutomaticKeepAliveClientMixin&#123; bool get wantKeepAlive =&gt;true; ProductContentitem _productContent; var cartProvider; // 广播监听 var actionEventBus; List _attr = []; // 商品的属性 String _selectedValue; // 商品的选中属性 @override void initState() &#123; super.initState(); this._productContent=widget._productContentList[0]; this._attr=this._productContent.attr; _initAttr(); //监听广播 //监听所有广播 // eventBus.on().listen((event) &#123; // print(event); // this._attrBottomSheet(); // &#125;); // 监听底部的加入购物车按钮 this.actionEventBus=eventBus.on&lt;ProductContentEvent&gt;().listen((str) &#123; print(str); this._attrBottomSheet(); &#125;); &#125; //销毁 void dispose()&#123; super.dispose(); this.actionEventBus.cancel(); //取消事件监听 &#125; _initAttr()&#123; //给数据添加一个"checked"的字段 var attr=this._attr; for(var i=0;i&lt;attr.length;i++)&#123; for(var j=0;j&lt;attr[i].list.length;j++)&#123; if(j==0)&#123; attr[i].attrList.add(&#123;"title":attr[i].list[j],"checked":true&#125;); &#125;else&#123; attr[i].attrList.add(&#123;"title":attr[i].list[j],"checked":false&#125;); &#125; &#125; &#125; _getSelectAttrValue(); &#125; //改变属性值 _changeAttr(cate, title, setBottomState) &#123; var attr = this._attr; for (var i = 0; i &lt; attr.length; i++) &#123; if (attr[i].cate == cate) &#123; for (var j = 0; j &lt; attr[i].attrList.length; j++) &#123; attr[i].attrList[j]["checked"] = false; if (title == attr[i].attrList[j]["title"]) &#123; attr[i].attrList[j]["checked"] = true; &#125; &#125; &#125; &#125; setBottomState(() &#123; //注意 改变showModalBottomSheet里面的数据 来源于StatefulBuilder this._attr = attr; &#125;); _getSelectAttrValue(); &#125; // 获得选中的值 _getSelectAttrValue()&#123; var _list=this._attr; List tempArr = []; for (var i = 0; i &lt; _list.length; i++) &#123; for (var j = 0; j &lt; _list[i].attrList.length; j++) &#123; if (_list[i].attrList[j]['checked'] == true) &#123; tempArr.add(_list[i].attrList[j]["title"]); &#125; &#125; &#125; setState(() &#123; this._selectedValue = tempArr.join(','); // 此处的数据格式&#123;"牛皮","系带","红色"&#125; // 将商品的选中属性，赋值，便于传递 this._productContent.selectedAttr=this._selectedValue; &#125;); print(this._selectedValue); &#125; List&lt;Widget&gt; _getAttrItemWidget(attrItem,setBottomState) &#123; List&lt;Widget&gt; attrItemList = []; attrItem.attrList.forEach((item) &#123; attrItemList.add(Container( margin: EdgeInsets.all(10), child: InkWell( onTap: () &#123; _changeAttr(attrItem.cate, item["title"], setBottomState); &#125;, child: Chip( label: Text("$&#123;item["title"]&#125;",style: TextStyle( color: item["checked"] ? Colors.white : Colors.black38 ),), padding: EdgeInsets.all(10), backgroundColor: item["checked"] ? Colors.red : Colors.black26, ), ), )); &#125;); return attrItemList; &#125; //封装一个组件 渲染attr ,分为了两层，两个循环，都返回Widget List&lt;Widget&gt; _getAttrWidget(setBottomState) &#123; List&lt;Widget&gt; attrList = []; this._attr.forEach((attrItem) &#123; attrList.add(Wrap( children: &lt;Widget&gt;[ Container( padding: EdgeInsets.only(left: 10), width: ScreenAdaper.width(130), child: Padding( padding: EdgeInsets.only(top: ScreenAdaper.height(40)), child: Text("$&#123;attrItem.cate&#125;: ", style: TextStyle(fontWeight: FontWeight.bold,)), ), ), Container( width: ScreenAdaper.width(580), child: Wrap( children: _getAttrItemWidget(attrItem,setBottomState), ), ) ], )); &#125;); return attrList; &#125; // 加入购物车的弹窗 _attrBottomSheet() &#123; showModalBottomSheet( context: context, builder: (context) &#123; return StatefulBuilder( builder: (BuildContext context,setBottomState)&#123; return GestureDetector( onTap: () &#123; return false; &#125;, child: Stack( children: &lt;Widget&gt;[ Container( padding: EdgeInsets.all(10), child: ListView( children: &lt;Widget&gt;[ Column( mainAxisAlignment: MainAxisAlignment.center, children: _getAttrWidget(setBottomState), ), Divider(), Container( margin: EdgeInsets.fromLTRB(10,10,0,0), height: ScreenAdaper.height(80), child: Row( children: &lt;Widget&gt;[ // TODO Text("数量:", style: TextStyle(fontWeight: FontWeight.bold)), Container( padding: EdgeInsets.only(left:10), child: CartNum(this._productContent), ) ], ), ) ], ), ), Positioned( bottom: 0, width: ScreenAdaper.width(750), height: ScreenAdaper.height(90), child: Row( children: &lt;Widget&gt;[ Expanded( flex: 1, child: Container( margin: EdgeInsets.only(left: 10), child: JdButton( color: Color.fromRGBO(253, 1, 0, 0.9), text: "加入购物车", cb: () async&#123; await CartServices.addCart(this._productContent); Navigator.pop(context); this.cartProvider.updateCartList(); Fluttertoast.showToast( msg: '加入购物车成功', toastLength: Toast.LENGTH_SHORT,gravity: ToastGravity.CENTER,); print('加入购物车'); &#125;, ), )), Expanded(flex: 1, child: Container( margin: EdgeInsets.fromLTRB(10, 0, 10, 0), child: JdButton( color: Color.fromRGBO(255, 165, 0, 0.9), text: "立即购买", cb: () &#123; print('立即购买'); &#125;, )),), ], )) ], ), ); &#125;, ); &#125;); &#125; @override Widget build(BuildContext context) &#123; this.cartProvider = Provider.of&lt;Cart&gt;(context); //处理图片 String pic = Config.domain + this._productContent.pic; pic = pic.replaceAll('\\', '/'); return Container( padding: EdgeInsets.all(10), child: ListView( children: &lt;Widget&gt;[ AspectRatio( aspectRatio: 16 / 9, child: Image.network( "$&#123;pic&#125;", fit: BoxFit.cover), ), // 标题 Container( padding: EdgeInsets.only(top: 10), child: Text("$&#123;this._productContent.title&#125;", style: TextStyle( color: Colors.black87, fontSize: ScreenAdaper.size(38), ))), Container( padding: EdgeInsets.only(top: 10), child:this._productContent.subTitle!=null?Text( "$&#123;this._productContent.subTitle&#125;", style: TextStyle( color: Colors.black87, fontSize: ScreenAdaper.size(32))):Text(""), ), Container( padding: EdgeInsets.only(top: 10), child: Row( children: &lt;Widget&gt;[ Expanded( flex: 1, child: Row( children: &lt;Widget&gt;[ Text("特价"), Text("¥$&#123;this._productContent.price&#125;", style: TextStyle( color: Colors.red, fontSize: ScreenAdaper.size(46))) ], ), ), Expanded( flex: 1, child: Row( mainAxisAlignment: MainAxisAlignment.end, children: &lt;Widget&gt;[ Text("原件:"), Text("¥$&#123;this._productContent.oldPrice&#125;", style: TextStyle( color: Colors.black38, fontSize: ScreenAdaper.size(28), decoration: TextDecoration.lineThrough)), ], ), ) ], ), ), // 筛选 Container( margin: EdgeInsets.only(top: 10), height: ScreenAdaper.height(80), child: InkWell( onTap: () &#123; _attrBottomSheet(); &#125;, child: Row( children: &lt;Widget&gt;[ // TODO Text("已选:", style: TextStyle(fontWeight: FontWeight.bold)), Text("115，黑色，XL， 1件") ], ), )), Divider(), Container( height: ScreenAdaper.height(80), child: Row( children: &lt;Widget&gt;[ Text("运费:", style: TextStyle(fontWeight: FontWeight.bold)), Text("免运费"), ], ), ), Divider(), ], )); &#125;&#125;​ 此处的属性参数是嵌套的，有两层的循环，需要分开处理，传入数据返回widget。1234567891011121314151617181920212223242526272829303132333435class ProductContentitem &#123; String sId; String title; String cid; Object price; String oldPrice; Object isBest; Object isHot; Object isNew; String status; String pic; String content; String cname; List&lt;Attr&gt; attr; // 为数组 .......// 略class Attr &#123; String cate; List&lt;String&gt; list; // 属性类型也为数组 List&lt;Map&gt; attrList; Attr(&#123;this.cate, this.list&#125;); Attr.fromJson(Map&lt;String, dynamic&gt; json) &#123; cate = json['cate']; list = json['list'].cast&lt;String&gt;(); attrList=[]; &#125; Map&lt;String, dynamic&gt; toJson() &#123; final Map&lt;String, dynamic&gt; data = new Map&lt;String, dynamic&gt;(); data['cate'] = this.cate; data['list'] = this.list; return data; &#125;&#125;]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>狗东商城</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[狗东商城(三)]]></title>
    <url>%2F2019%2F09%2F16%2F%E7%8B%97%E4%B8%9C%E5%95%86%E5%9F%8E-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[home的深入搜索栏​ home页面的搜索栏，四个页面四个不同的appBar，在main和tab管理处不设置appBar。在各自页面设置对应的appBar。123456789101112131415161718192021222324252627282930313233appBar: AppBar( leading: IconButton( icon: Icon(Icons.center_focus_weak, size: 28, color: Colors.black87), onPressed: null), title: InkWell( onTap: () &#123; Navigator.pushNamed(context, '/search'); &#125;, child: Container( padding: EdgeInsets.only(left: 10), height: ScreenAdaper.height(68), decoration: BoxDecoration( color: Color.fromRGBO(233, 233, 233, 0.8), borderRadius: BorderRadius.circular(30)), child: Row( crossAxisAlignment: CrossAxisAlignment.center, children: &lt;Widget&gt;[ Icon(Icons.search), Text("笔记本", style: TextStyle(fontSize: ScreenAdaper.size(28))) ], ), )), actions: &lt;Widget&gt;[ IconButton( icon: Icon( Icons.message, size: 28, color: Colors.black87, ), onPressed: null) ], ),​​ 此处的搜索栏，点击后会直接跳转到一个新页面（searchPage），或者说这个搜索栏是个假的。具有迷惑性。search页面123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188import 'package:flutter/material.dart';import '../service/ScreenAdaper.dart';import '../service/SearchService.dart';class SearchPage extends StatefulWidget &#123; SearchPage(&#123;Key key&#125;) : super(key: key); _SearchPageState createState() =&gt; _SearchPageState();&#125;class _SearchPageState extends State&lt;SearchPage&gt; &#123; var _keywords; var _historyList = []; @override void initState() &#123; super.initState(); this._getHistoryData(); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Container( child: TextField( autofocus: true, decoration: InputDecoration( border: OutlineInputBorder( borderRadius: BorderRadius.circular(30), borderSide: BorderSide.none)), onChanged: (value) &#123; this._keywords = value; &#125;, ), height: ScreenAdaper.height(68), decoration: BoxDecoration( color: Color.fromRGBO(233, 233, 233, 0.8), borderRadius: BorderRadius.circular(30)), ), actions: &lt;Widget&gt;[ InkWell( child: Container( height: ScreenAdaper.height(68), width: ScreenAdaper.width(80), child: Row( children: &lt;Widget&gt;[Text("搜索")], ), ), onTap: () &#123; if(this._keywords!=null)&#123; SearchServices.setHistoryDate(this._keywords); Navigator.pushReplacementNamed(context, '/productlist', arguments: &#123;"keywords": this._keywords&#125;); &#125; &#125;, ) ], ), body: Container( padding: EdgeInsets.all(10), child: ListView( children: &lt;Widget&gt;[ Text("热搜", style: TextStyle( fontSize: ScreenAdaper.size(28), color: Colors.black87)), Divider(), Wrap( children: &lt;Widget&gt;[ Container( padding: EdgeInsets.all(10), margin: EdgeInsets.all(10), decoration: BoxDecoration( color: Color.fromRGBO(233, 233, 233, 0.9), borderRadius: BorderRadius.circular(10), ), child: Text("女装"), ), Container( padding: EdgeInsets.all(10), margin: EdgeInsets.all(10), decoration: BoxDecoration( color: Color.fromRGBO(233, 233, 233, 0.9), borderRadius: BorderRadius.circular(10), ), child: Text("笔记本电脑"), ), Container( padding: EdgeInsets.all(10), margin: EdgeInsets.all(10), decoration: BoxDecoration( color: Color.fromRGBO(233, 233, 233, 0.9), borderRadius: BorderRadius.circular(10), ), child: Text("女装"), ), Container( padding: EdgeInsets.all(10), margin: EdgeInsets.all(10), decoration: BoxDecoration( color: Color.fromRGBO(233, 233, 233, 0.9), borderRadius: BorderRadius.circular(10), ), child: Text("女装"), ) ], ), SizedBox(height: 10), Container( child: Text("历史记录", style: Theme.of(context).textTheme.title), ), Divider(height: 6), Column( children: this._historyList.map((value) &#123; return new Column( children: &lt;Widget&gt;[ ListTile( title: Text("$&#123;value&#125;"), onLongPress: () &#123; this._showAlertDialog("$&#123;value&#125;"); &#125;, ), Divider(), ], ); &#125;).toList(), ), SizedBox(height: 30), InkWell( onTap: () &#123; SearchServices.clearHistoryList(); this._getHistoryData(); &#125;, child: Container( width: ScreenAdaper.width(400), height: ScreenAdaper.height(64), decoration: BoxDecoration( border: Border.all(color: Colors.black45, width: 1), ), child: Row( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[Icon(Icons.delete), Text("清空历史纪律")], ), ), ), ], ), )); &#125; // 弹出框 _showAlertDialog(keyworld) async &#123; var result = await showDialog( barrierDismissible: false, //表示点击灰色背景的时候是否消失弹出框 context: context, builder: (context) &#123; return AlertDialog( title: Text("提示信息!"), content: Text("您确定要删除吗?"), actions: &lt;Widget&gt;[ FlatButton( child: Text("取消"), onPressed: () &#123; print("取消"); Navigator.pop(context, 'Cancle'); &#125;, ), FlatButton( child: Text("确定"), onPressed: () async &#123; //注意异步 await SearchServices.removeHistoryData(keyworld); this._getHistoryData(); Navigator.pop(context, "Ok"); &#125;, ) ], ); &#125;); &#125; _getHistoryData() async &#123; var _historyListData = await SearchServices.getHistoryList(); setState(() &#123; this._historyList = _historyListData; &#125;); &#125;&#125;SharedPreferences在search页面会有搜索历史记录的保存，此处使用了SharedPreferences，来保存记录的！12// 依赖shared_preferences: ^0.5.3+1如何使用：（和android中的sp差不多，能分类型进行存储的bool、int、double）1234567891011121314151617181920import 'package:shared_preferences/shared_preferences.dart';class Storage&#123; static Future&lt;void&gt; setString(key,value) async&#123; SharedPreferences sp=await SharedPreferences.getInstance(); sp.setString(key, value); &#125; static Future&lt;String&gt; getString(key) async&#123; SharedPreferences sp=await SharedPreferences.getInstance(); return sp.getString(key); &#125; static Future&lt;void&gt; remove(key) async&#123; SharedPreferences sp=await SharedPreferences.getInstance(); sp.remove(key); &#125; static Future&lt;void&gt; clear() async&#123; SharedPreferences sp=await SharedPreferences.getInstance(); sp.clear(); &#125;&#125;保存搜索记录12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/*1、获取本地存储里面的数据 (searchList)2、判断本地存储是否有数据2.1、如果有数据 1、读取本地存储的数据 2、判断本地存储中有没有当前数据， 如果有不做操作、 如果没有当前数据,本地存储的数据和当前数据拼接后重新写入2.2、如果没有数据直接把当前数据放在数组中写入到本地存储 */import 'dart:convert';import 'Storage.dart';class SearchServices &#123; static setHistoryDate(keywords) async &#123; // 这个方法的问题，获取为空会报错，所以要try catch一下 try &#123; List searchListData = json.decode(await Storage.getString('searchList')); var hasDate = searchListData.any((v) &#123; // 这是一个方法有返回值的，直接返回给了hasData return v == keywords; &#125;); if (!hasDate) &#123; // 存在就放进去,（应该放到最前面，表示最近的搜索） searchListData.add(keywords); await Storage.setString('searchList', json.encode(searchListData)); &#125; &#125; catch (e) &#123; // List tempList = new List(); tempList.add(keywords); await Storage.setString('searchList', json.encode(tempList)); &#125; &#125; static getHistoryList() async &#123; try &#123; List searchListData = json.decode(await Storage.getString('searchList')); if (searchListData != null) &#123; return searchListData; &#125; else &#123; return []; &#125; &#125; catch (e) &#123; return []; &#125; &#125; static clearHistoryList() async &#123; await Storage.remove('searchList'); &#125; static removeHistoryData(keywords) async &#123; List searchListData = json.decode(await Storage.getString('searchList')); searchListData.remove(keywords); await Storage.setString('searchList', json.encode(searchListData)); &#125;&#125;搜索结果页面123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370import 'package:flutter/material.dart';import '../service/ScreenAdaper.dart';import '../config/Config.dart';import '../model/ProductModel.dart';import 'package:dio/dio.dart';import '../widget/LoadingWidget.dart';import '../service/SearchService.dart';class ProductList extends StatefulWidget &#123; Map arguments; ProductList(&#123;Key key, this.arguments&#125;) : super(key: key); _ProductListState createState() =&gt; _ProductListState();&#125;class _ProductListState extends State&lt;ProductList&gt; &#123; final GlobalKey&lt;ScaffoldState&gt; _scaffoldKey = new GlobalKey&lt;ScaffoldState&gt;(); // 上拉分页控制器 ScrollController _scrollController = ScrollController(); //配置search搜索框的值 var _initKeywordsController = new TextEditingController(); // 分页 int _page = 1; // 每页有多少条数据 int _pageSize = 8; // 数据 List _productList = []; // 是否有数据 bool _hasMore = true; //排序:价格升序 sort=price_1 价格降序 sort=price_-1 销量升序 sort=salecount_1 销量降序 sort=salecount_-1 String _sort = ""; // 重复请求？？？？ // 是否存在有数据 bool flag = true; /*二级导航数据*/ List _subHeaderList = [ &#123; "id": 1, "title": "综合", "fileds": "all", "sort": -1, //排序 升序：price_1 &#123;price:1&#125; 降序：price_-1 &#123;price:-1&#125; &#125;, &#123;"id": 2, "title": "销量", "fileds": 'salecount', "sort": -1&#125;, &#123;"id": 3, "title": "价格", "fileds": 'price', "sort": -1&#125;, &#123;"id": 4, "title": "筛选"&#125; ]; //二级导航选中判断 int _selectHeaderId = 1; var _cid; // 搜索关键词 var _keywords; // 点击分类时的标题 var _title; @override void initState() &#123; super.initState(); this._cid = widget.arguments["cid"]; this._title = widget.arguments["title"]; this._keywords = widget.arguments["keywords"]; this._initKeywordsController.text = this._keywords; _getProductListData(); //监听滚动条滚动事件 _scrollController.addListener(() &#123; //_scrollController.position.pixels //获取滚动条滚动的高度 //_scrollController.position.maxScrollExtent //获取页面高度 if (_scrollController.position.pixels &gt; _scrollController.position.maxScrollExtent - 20) &#123; if (this.flag &amp;&amp; this._hasMore) &#123; _getProductListData(); &#125; &#125; &#125;); &#125; // 获得请求的数据 _getProductListData() async &#123; setState(() &#123; this.flag = false; &#125;); var api; if (this._keywords == null) &#123; api = '$&#123;Config.domain&#125;api/plist?cid=$&#123;this._cid&#125;&amp;page=$&#123;this._page&#125;&amp;sort=$&#123;this._sort&#125;&amp;pageSize=$&#123;this._pageSize&#125;'; &#125; else &#123; api = '$&#123;Config.domain&#125;api/plist?search=$&#123;this._keywords&#125;&amp;page=$&#123;this._page&#125;&amp;sort=$&#123;this._sort&#125;&amp;pageSize=$&#123;this._pageSize&#125;'; &#125; var result = await Dio().get(api); var productList = new ProductModel.fromJson(result.data); print(productList.result.length); if (productList.result.length &lt; this._pageSize) &#123; setState(() &#123; // this._productList = productList.result; this._productList.addAll(productList.result); this._hasMore = false; this.flag = true; &#125;); &#125; else &#123; setState(() &#123; // this._productList = productList.result; this._productList.addAll(productList.result); this._page++; this.flag = true; &#125;); &#125; &#125; // 显示加载中的小圆圈 Widget _showMore(index) &#123; if (this._hasMore) &#123; return (index == this._productList.length - 1) ? LoadingWidget() : Text(""); &#125; else &#123; return (index == this._productList.length - 1) ? Text("--我是有底线的--") : Text(""); &#125; &#125; Widget _ProductList() &#123; if (this._productList.length &gt; 0) &#123; return Container( padding: EdgeInsets.all(10), margin: EdgeInsets.only(top: ScreenAdaper.height(80)), // 不让分栏遮挡住 child: ListView.builder( controller: _scrollController, itemCount: this._productList.length, itemBuilder: (context, index) &#123; String pic = this._productList[index].pic; pic = Config.domain + pic.replaceAll('\\', '/'); return Column(children: &lt;Widget&gt;[ Row( children: &lt;Widget&gt;[ Container( width: ScreenAdaper.width(180), height: ScreenAdaper.height(180), child: Image.network("$&#123;pic&#125;", fit: BoxFit.cover), ), Expanded( flex: 1, child: Container( height: ScreenAdaper.height(180), margin: EdgeInsets.only(left: 10), child: Column( mainAxisAlignment: MainAxisAlignment.spaceBetween, crossAxisAlignment: CrossAxisAlignment.start, children: &lt;Widget&gt;[ Text("$&#123;this._productList[index].title&#125;", maxLines: 2, overflow: TextOverflow.ellipsis), Row( children: &lt;Widget&gt;[ Container( height: ScreenAdaper.height(36), margin: EdgeInsets.only(right: 10), padding: EdgeInsets.fromLTRB(10, 0, 10, 0), //注意 如果Container里面加上decoration属性，这个时候color属性必须得放在BoxDecoration decoration: BoxDecoration( borderRadius: BorderRadius.circular(10), color: Color.fromRGBO(230, 230, 230, 0.9), ), child: Text("4g"), ), Container( height: ScreenAdaper.height(36), margin: EdgeInsets.only(right: 10), padding: EdgeInsets.fromLTRB(10, 0, 10, 0), decoration: BoxDecoration( borderRadius: BorderRadius.circular(10), color: Color.fromRGBO(230, 230, 230, 0.9), ), child: Text("126"), ), ], ), Text( "¥$&#123;this._productList[index].price&#125;", style: TextStyle( color: Colors.red, fontSize: 16), ) ], ), )) ], ), Divider(height: 20), _showMore(index), ]); &#125;)); &#125; else &#123; return LoadingWidget(); &#125; &#125; _subHeaderChange(id) &#123; if (id == 4) &#123; _scaffoldKey.currentState.openEndDrawer(); setState(() &#123; this._selectHeaderId = id; &#125;); &#125; else &#123; setState(() &#123; this._selectHeaderId = id; this._sort = "$&#123;this._subHeaderList[id - 1]["fileds"]&#125;_$&#123;this._subHeaderList[id - 1]["sort"]&#125;"; print("this._sort:" + this._sort); // 重置分页 this._page = 1; // 重置数据 this._productList = []; // 改变sort排序 this._subHeaderList[id - 1]['sort'] = this._subHeaderList[id - 1]['sort'] * -1; // 回到顶部 _scrollController.jumpTo(0); // 重置_hasMore this._hasMore = true; // 重新请求 this._getProductListData(); &#125;); &#125; &#125; Widget _showIcon(id) &#123; if (id == 2 || id == 3) &#123; if (this._subHeaderList[id - 1]["sort"] == 1) &#123; return Icon(Icons.arrow_drop_down); &#125; return Icon(Icons.arrow_drop_up); &#125; return Text(""); &#125; //筛选导航 Widget _subHeaderWidget() &#123; return Positioned( top: 0, height: ScreenAdaper.height(80), width: ScreenAdaper.width(750), child: Container( width: ScreenAdaper.width(750), height: ScreenAdaper.height(80), // color: Colors.red, decoration: BoxDecoration( border: Border( bottom: BorderSide( width: 1, color: Color.fromRGBO(233, 233, 233, 0.9)))), child: Row( children: this._subHeaderList.map((value) &#123; return Expanded( flex: 1, child: InkWell( child: Padding( padding: EdgeInsets.fromLTRB(0, ScreenAdaper.height(16), 0, ScreenAdaper.height(16)), child: Row( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ Text( "$&#123;value["title"]&#125;", textAlign: TextAlign.center, style: TextStyle( color: (this._selectHeaderId == value["id"]) ? Colors.red : Colors.black54), ), _showIcon(value["id"]), ], )), onTap: () &#123; this._subHeaderChange(value["id"]); &#125;, )); &#125;).toList(), ), ), ); &#125; _searchBar() &#123; if (this._keywords == null) &#123; return AppBar( title: Text(this._title), ); &#125; else &#123; return AppBar( title: Container( child: TextField( controller: this._initKeywordsController, autofocus: true, decoration: InputDecoration( border: OutlineInputBorder( borderRadius: BorderRadius.circular(30), borderSide: BorderSide.none)), onChanged: (value) &#123; this._keywords = value; &#125;, ), height: ScreenAdaper.height(68), decoration: BoxDecoration( color: Color.fromRGBO(233, 233, 233, 0.8), borderRadius: BorderRadius.circular(30)), ), actions: &lt;Widget&gt;[ InkWell( child: Container( height: ScreenAdaper.height(68), width: ScreenAdaper.width(80), child: Row( children: &lt;Widget&gt;[Text("搜索")], ), ), onTap: () &#123; if (this._keywords != null) &#123; SearchServices.setHistoryDate(this._keywords); &#125; _subHeaderChange(1); &#125;, ) ], ); &#125; &#125; @override Widget build(BuildContext context) &#123; ScreenAdaper.init(context); return new Scaffold( key: _scaffoldKey, appBar: _searchBar(), endDrawer: Drawer( // 右侧边栏 child: Container( child: Text("实现筛选功能"), ), ), // body:Text("$&#123;widget.arguments&#125;") body: new Stack( children: &lt;Widget&gt;[ _ProductList(), _subHeaderWidget(), ], )); &#125;&#125;搜索后筛选的过程，本质上是字符串的拼接。上拉加载(_scrollController.position.pixels //获取滚动条滚动的高度_scrollController.position.maxScrollExtent //获取页面高度) 滚动条的高度快和页面高度相同时触发监听]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>狗东商城</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[狗东商城(二)]]></title>
    <url>%2F2019%2F09%2F16%2F%E7%8B%97%E4%B8%9C%E5%95%86%E5%9F%8E-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[页面布局页面布局的管理12345678910111213141516171819202122232425import 'package:flutter/material.dart';void main() =&gt; runApp(MyApp());class MyApp extends StatefulWidget &#123; MyApp(&#123;Key key&#125;) : super(key: key); _MyAppState createState() =&gt; _MyAppState();&#125;class _MyAppState extends State&lt;MyApp&gt; &#123; @override Widget build(BuildContext context) &#123; return MultiProvider(providers: [ ChangeNotifierProvider(builder: (_) =&gt; Counter()), ChangeNotifierProvider(builder: (_) =&gt; Cart()) ], child: MaterialApp( // 此处对应之前的路由配置 initialRoute: '/', onGenerateRoute:onGenerateRoute, theme: ThemeData( primaryColor: Colors.white ), ), ); &#125;&#125;home页面123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264import 'package:flutter/material.dart';import 'package:flutter_swiper/flutter_swiper.dart';import '../../service/ScreenAdaper.dart';import '../../model/FocusModel.dart';import '../../model/ProductModel.dart';import 'package:dio/dio.dart';import '../../config/Config.dart';class HomePage extends StatefulWidget &#123; HomePage(&#123;Key key&#125;) : super(key: key); _HomePageState createState() =&gt; _HomePageState();&#125;class _HomePageState extends State&lt;HomePage&gt; with AutomaticKeepAliveClientMixin &#123; @override bool get wantKeepAlive =&gt; true; List _focusData = []; List _faverData = []; List _hotData = []; @override void initState() &#123; super.initState(); _getFocusData(); _getFaverDate(); _getHotData(); &#125; // 获取轮播图数据 _getFocusData() async &#123; var api = '$&#123;Config.domain&#125;api/focus'; print("api:" + "$&#123;api&#125;"); var result = await Dio().get(api); print(result); var focusList = FocusModel.fromJson(result.data); print("modeldate:$&#123;focusList.result&#125;"); setState(() &#123; this._focusData = focusList.result; &#125;); &#125; // 获取猜你喜欢的商品的数据 _getFaverDate() async &#123; var api = '$&#123;Config.domain&#125;api/plist?is_hot=1'; print("faver:" + "$&#123;api&#125;"); var result = await Dio().get(api); var faverList = ProductModel.fromJson(result.data); setState(() &#123; this._faverData = faverList.result; &#125;); &#125; // 获得热门推荐数据 _getHotData() async &#123; var api = '$&#123;Config.domain&#125;api/plist?is_best=1'; var result = await Dio().get(api); var hotList = ProductModel.fromJson(result.data); setState(() &#123; this._hotData = hotList.result; &#125;); &#125; //轮播图 Widget _swiperWidget() &#123; return Container( child: AspectRatio( aspectRatio: 2 / 1, child: Swiper( itemBuilder: (BuildContext context, int index) &#123; String pic = this._focusData[index].pic; pic = Config.domain + pic.replaceAll('\\', '/'); return new Image.network( "$&#123;pic&#125;", fit: BoxFit.fill, ); &#125;, itemCount: this._focusData.length, pagination: new SwiperPagination(), // index标志 autoplay: true), ), ); &#125; Widget _titleWidget(value) &#123; return Container( height: ScreenAdaper.height(38), margin: EdgeInsets.only(left: ScreenAdaper.width(10)), padding: EdgeInsets.only(left: ScreenAdaper.width(10)), decoration: BoxDecoration( border: Border( left: BorderSide( color: Colors.red, width: ScreenAdaper.width(10), ))), child: Text( value, style: TextStyle(color: Colors.black54), ), ); &#125; // 猜你喜欢 Widget _hotProductListWidget() &#123; if (_faverData.length &gt; 0) &#123; return Container( height: ScreenAdaper.height(234), padding: EdgeInsets.all(ScreenAdaper.width(20)), child: ListView.builder( scrollDirection: Axis.horizontal, itemBuilder: (contxt, index) &#123; var pic = this._faverData[index].sPic; pic = Config.domain + pic.replaceAll('\\', '/'); return Column( children: &lt;Widget&gt;[ Container( height: ScreenAdaper.height(140), width: ScreenAdaper.width(140), margin: EdgeInsets.only(right: ScreenAdaper.width(21)), // padding: EdgeInsets.only(right: ScreenAdaper.width(21)), child: Image.network(pic, fit: BoxFit.cover), ), Container( padding: EdgeInsets.only(top: ScreenAdaper.height(10)), height: ScreenAdaper.height(44), child: Text("￥$&#123;this._faverData[index].price&#125;"), ) ], ); &#125;, itemCount: _faverData.length, ), ); &#125; else &#123; return Text(""); &#125; &#125; _recProductItemWidgetfix() &#123; var itemWidth = (ScreenAdaper.getScreenWidth() - 30) / 2; return Container( padding: EdgeInsets.all(10), child: Wrap( runSpacing: 10, spacing: 10, children: this._hotData.map((value) &#123; var pic = value.sPic; pic = Config.domain + pic.replaceAll('\\', '/'); return Container( padding: EdgeInsets.all(10), width: itemWidth, decoration: BoxDecoration( border: Border.all( color: Color.fromRGBO(233, 233, 233, 0.9), width: 1)), child: InkWell( onTap: () &#123; Navigator.pushNamed(context, '/productContent', arguments: &#123;"id": value.sId&#125;); &#125;, child: Column( children: &lt;Widget&gt;[ Container( width: double.infinity, child: AspectRatio( //防止服务器返回的图片大小不一致导致高度不一致问题 aspectRatio: 1 / 1, child: Image.network( '$&#123;pic&#125;', fit: BoxFit.cover, ), ), ), Padding( padding: EdgeInsets.only(top: ScreenAdaper.height(20)), child: Text( "$&#123;value.title&#125;", maxLines: 2, overflow: TextOverflow.ellipsis, style: TextStyle(color: Colors.black54), ), ), Padding( padding: EdgeInsets.only(top: ScreenAdaper.height(20)), child: Stack( children: &lt;Widget&gt;[ Align( alignment: Alignment.centerLeft, child: Text( "$&#123;value.price&#125;", style: TextStyle(color: Colors.red, fontSize: 16), ), ), Align( alignment: Alignment.centerRight, child: Text("$&#123;value.oldPrice&#125;", style: TextStyle( color: Colors.black54, fontSize: 14, decoration: TextDecoration.lineThrough)), ) ], ), ) ], ), )); &#125;).toList()), ); &#125; @override Widget build(BuildContext context) &#123; ScreenAdaper.init(context); return Scaffold( appBar: AppBar( leading: IconButton( icon: Icon(Icons.center_focus_weak, size: 28, color: Colors.black87), onPressed: null), title: InkWell( onTap: () &#123; Navigator.pushNamed(context, '/search'); &#125;, child: Container( padding: EdgeInsets.only(left: 10), height: ScreenAdaper.height(68), decoration: BoxDecoration( color: Color.fromRGBO(233, 233, 233, 0.8), borderRadius: BorderRadius.circular(30)), child: Row( crossAxisAlignment: CrossAxisAlignment.center, children: &lt;Widget&gt;[ Icon(Icons.search), Text("笔记本", style: TextStyle(fontSize: ScreenAdaper.size(28))) ], ), )), actions: &lt;Widget&gt;[ IconButton( icon: Icon( Icons.message, size: 28, color: Colors.black87, ), onPressed: null) ], ), body: Center( child: ListView( children: &lt;Widget&gt;[ _swiperWidget(), SizedBox(height: ScreenAdaper.width(20)), _titleWidget("猜你喜欢"), SizedBox(height: ScreenAdaper.width(20)), _hotProductListWidget(), _titleWidget("热门推荐"), _recProductItemWidgetfix(), ], )), ); &#125;&#125;Category页面123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209import 'package:flutter/material.dart';import '../../service/ScreenAdaper.dart';import 'package:dio/dio.dart';import '../../config/Config.dart';import '../../model/CateModel.dart';class CategoryPage extends StatefulWidget &#123; CategoryPage(&#123;Key key&#125;) : super(key: key); _CategoryPageState createState() =&gt; _CategoryPageState();&#125;class _CategoryPageState extends State&lt;CategoryPage&gt; with AutomaticKeepAliveClientMixin &#123; @override bool get wantKeepAlive =&gt; true; int _selectIndex = 0; List _leftdata = []; List _rightdata = []; @override void initState() &#123; super.initState(); _getLeftdata(); &#125; // 左边的数据请求 _getLeftdata() async &#123; var api = '$&#123;Config.domain&#125;api/pcate'; print("left:" + "$&#123;api&#125;"); var result = await Dio().get(api); print("result:+$&#123;result&#125;"); var leftList = Catemodel.fromJson(result.data); print("sult:+$&#123;leftList&#125;"); setState(() &#123; this._leftdata = leftList.result; &#125;); _getRightCateData(this._leftdata[0].sId); &#125; //右侧分类 _getRightCateData(pid) async &#123; var api = '$&#123;Config.domain&#125;api/pcate?pid=$&#123;pid&#125;'; var result = await Dio().get(api); var rightCateList = new Catemodel.fromJson(result.data); // print(rightCateList.result); setState(() &#123; this._rightdata = rightCateList.result; &#125;); &#125; // 左边 _leftWidget(leftWidth) &#123; if (this._leftdata.length &gt; 0) &#123; return Container( width: leftWidth, height: double.infinity, // color: Colors.cyan, child: ListView.builder( itemCount: this._leftdata.length, itemBuilder: (context, index) &#123; return Column( children: &lt;Widget&gt;[ InkWell( onTap: () &#123; setState(() &#123; _selectIndex = index; this._getRightCateData(this._leftdata[index].sId); &#125;); &#125;, child: Container( alignment: Alignment.center, width: double.infinity, //padding:EdgeInsets.only(top:ScreenAdaper.height(24)), height: ScreenAdaper.height(84), child: Text( "$&#123;this._leftdata[index].title&#125;", textAlign: TextAlign.center, ), color: _selectIndex == index ? Color.fromRGBO(240, 246, 246, 0.9) : Colors.white, ), ), Divider(height: 2), ], ); &#125;), ); &#125; else &#123; return Container( width: leftWidth, height: double.infinity, ); &#125; &#125; // 右边 _rightWidget(rightItemWidth, rightItemHeight) &#123; if (this._rightdata.length &gt; 0) &#123; return Expanded( flex: 1, child: Container( padding: EdgeInsets.all(ScreenAdaper.width(10)), height: double.infinity, color: Color.fromRGBO(240, 246, 246, 0.9), child: GridView.builder( gridDelegate: SliverGridDelegateWithFixedCrossAxisCount( crossAxisCount: 3, childAspectRatio: rightItemWidth / rightItemHeight, crossAxisSpacing: 5, // 左右的间距 mainAxisSpacing: 2 // 上下的间距 ), itemCount: this._rightdata.length, itemBuilder: (context, index) &#123; //处理图片 String pic = this._rightdata[index].pic; pic = Config.domain + pic.replaceAll('\\', '/'); return Container( child: InkWell( onTap: () =&gt; Navigator.pushNamed(context, '/productlist', arguments: &#123; "cid": this._rightdata[index].sId, "title": this._rightdata[index].title &#125;), child: Column( children: &lt;Widget&gt;[ AspectRatio( aspectRatio: 1 / 1, child: Image.network("$&#123;pic&#125;", fit: BoxFit.cover), ), Container( margin: EdgeInsets.only(top: 5), height: ScreenAdaper.height(30), child: Text( "$&#123;this._rightdata[index].title&#125;", style: TextStyle(fontSize: 12), ), ) ], ), )); &#125;))); &#125; else &#123; return Expanded( flex: 1, child: Container( padding: EdgeInsets.all(10), height: double.infinity, color: Color.fromRGBO(240, 246, 246, 0.9), child: Text("加载中..."), )); &#125; &#125; @override Widget build(BuildContext context) &#123; ScreenAdaper.init(context); var leftWidth = ScreenAdaper.getScreenWidth() / 4; //右侧每一项宽度=（总宽度-左侧宽度-GridView外侧元素左右的Padding值-GridView中间的间距）/3 var rightItemWidth = (ScreenAdaper.getScreenWidth() - leftWidth - 20 - 20) / 3; //获取计算后的宽度 rightItemWidth = ScreenAdaper.width(rightItemWidth); //获取计算后的高度 var rightItemHeight = rightItemWidth + ScreenAdaper.height(28); return Scaffold( appBar: AppBar( leading: IconButton( icon: Icon(Icons.center_focus_weak, size: 28, color: Colors.black87), onPressed: null), title: InkWell( onTap: () &#123; Navigator.pushNamed(context, '/search'); &#125;, child: Container( padding: EdgeInsets.only(left: 10), height: ScreenAdaper.height(68), decoration: BoxDecoration( color: Color.fromRGBO(233, 233, 233, 0.8), borderRadius: BorderRadius.circular(30)), child: Row( crossAxisAlignment: CrossAxisAlignment.center, children: &lt;Widget&gt;[ Icon(Icons.search), Text("笔记本", style: TextStyle(fontSize: ScreenAdaper.size(28))) ], ), )), actions: &lt;Widget&gt;[ IconButton( icon: Icon( Icons.message, size: 28, color: Colors.black87, ), onPressed: null) ], ), body: new Row( children: &lt;Widget&gt;[ _leftWidget(leftWidth), _rightWidget(rightItemWidth, rightItemHeight) ], ), ); &#125;&#125;Cart页面123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170import 'package:flutter/material.dart';import 'package:provider/provider.dart';import 'package:gou_dong_store/provider/CheckOut.dart';import '../../provider/Cart.dart';import '../../service/ScreenAdaper.dart';import '../../service/CartServices.dart';import '../../service/UserServices.dart';import 'package:fluttertoast/fluttertoast.dart';import '../Cart/CartItem.dart';import 'dart:convert';class CartPage extends StatefulWidget &#123; CartPage(&#123;Key key&#125;) : super(key: key); _CartPageState createState() =&gt; _CartPageState();&#125;class _CartPageState extends State&lt;CartPage&gt; &#123; bool _isEdit = false; var checkOutProvider; @override void initState() &#123; // TODO: implement initState super.initState(); print("cart"); &#125; doCheckOut() async &#123; //1、获取购物车选中的数据 List checkOutData = await CartServices.getCheckOutData(); print("----------------------------------$&#123;checkOutData&#125;"); //2、保存购物车选中的数据 //this.checkOutProvider.changeCheckOutListData(checkOutData); //3、购物车有没有选中的数据 if (checkOutData.length &gt; 0) &#123; //4、判断用户有没有登录 var loginState = await UserServices.getUserLoginState(); if (loginState) &#123; Navigator.pushNamed(context, '/Text', arguments: &#123;"flag": 1234&#125;); // Navigator.pushNamed(context, '/Text'); &#125; else &#123; Fluttertoast.showToast( msg: '您还没有登录，请登录以后再去结算', toastLength: Toast.LENGTH_SHORT, gravity: ToastGravity.CENTER, ); Navigator.pushNamed(context, '/login'); &#125; &#125; else &#123; Fluttertoast.showToast( msg: '购物车没有选中的数据', toastLength: Toast.LENGTH_SHORT, gravity: ToastGravity.CENTER, ); &#125; &#125; @override Widget build(BuildContext context) &#123; //var counterProvider = Provider.of&lt;Counter&gt;(context); var cartProvider = Provider.of&lt;Cart&gt;(context); //checkOutProvider = Provider.of&lt;CheckOut&gt;(context); return Scaffold( appBar: AppBar( title: Text("购物车"), actions: &lt;Widget&gt;[ IconButton( icon: Icon(Icons.launch), onPressed: () &#123; setState(() &#123; this._isEdit = !this._isEdit; cartProvider.notCheckAll(); &#125;); &#125;, ) ], ), body: cartProvider.cartList.length &gt; 0 ? Stack( children: &lt;Widget&gt;[ ListView( children: &lt;Widget&gt;[ Column( children: cartProvider.cartList.map((value) &#123; return CartItem(value); &#125;).toList()), SizedBox(height: ScreenAdaper.height(100)) ], ), Positioned( bottom: 0, width: ScreenAdaper.width(750), height: ScreenAdaper.height(90), child: Container( padding: EdgeInsets.all(5), decoration: BoxDecoration( border: Border( top: BorderSide(width: 1, color: Colors.black12)), color: Colors.white, ), width: ScreenAdaper.width(750), height: ScreenAdaper.height(90), child: Stack( children: &lt;Widget&gt;[ Align( alignment: Alignment.centerLeft, child: Row( children: &lt;Widget&gt;[ Container( width: ScreenAdaper.width(60), child: Checkbox( value: cartProvider.isCheckedAll, activeColor: Colors.pink, onChanged: (val) &#123; //实现全选或者反选 cartProvider.checkAll(val); &#125;, ), ), Text("全选"), SizedBox(width: 20), this._isEdit == false ? Text("合计:") : Text(""), Container( padding: EdgeInsets.only(left: 5), child: this._isEdit == false ? Text("$&#123;cartProvider.allPrice&#125;", style: TextStyle( fontSize: 20, color: Colors.red)) : Text(""), ) ], ), ), this._isEdit == false ? Align( alignment: Alignment.centerRight, child: Container( padding: EdgeInsets.only(right: 2), child: RaisedButton( child: Text("结算", style: TextStyle(color: Colors.white)), color: Colors.red, onPressed: doCheckOut, ), )) : Align( alignment: Alignment.centerRight, child: RaisedButton( child: Text("删除", style: TextStyle(color: Colors.white)), color: Colors.red, onPressed: () &#123; cartProvider.removeItem(); &#125;, ), ) ], ), ), ) ], ) : Center( child: Text("购物车空空如也"), ), ); &#125;&#125;User页面123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141import 'package:flutter/material.dart';import 'package:provider/provider.dart';import '../../provider/Counter.dart';import '../../service/ScreenAdaper.dart';import '../../service/UserServices.dart';import '../../widget/JdButton.dart';import '../../service/EventBus.dart';class UserPage extends StatefulWidget &#123; UserPage(&#123;Key key&#125;) : super(key: key); _UserPageState createState() =&gt; _UserPageState();&#125;class _UserPageState extends State&lt;UserPage&gt; &#123; bool isLogin=false; // 登陆状态 List userInfo=[]; // 用户信息 @override void initState() &#123; // TODO: implement initState super.initState(); this._getUserinfo(); //监听登录页面改变的事件 (这是一个监听器，打开监听而已)，弹出登陆页面与页面销毁后，不会重新执行init的 eventBus.on&lt;UserEvent&gt;().listen((event) &#123; print(event.str); this._getUserinfo(); &#125;); &#125; @override void dispose() &#123; super.dispose(); &#125; _getUserinfo() async&#123; var isLogin=await UserServices.getUserLoginState(); var userInfo=await UserServices.getUserInfo(); setState(() &#123; this.userInfo=userInfo; this.isLogin=isLogin; &#125;); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( body: Center( child: ListView( children: &lt;Widget&gt;[ Container( height: ScreenAdaper.width(220), width: double.infinity, decoration: BoxDecoration( image: DecorationImage( image: AssetImage('images/user_bg.jpg'), fit: BoxFit.cover)), child: Row( children: &lt;Widget&gt;[ Container( margin: EdgeInsets.fromLTRB(10, 0, 10, 0), child: ClipOval( child: Image.asset( 'images/user.png', fit: BoxFit.cover, width: ScreenAdaper.width(100), height: ScreenAdaper.width(100), ), ), ), !this.isLogin? Expanded( flex: 1, child: InkWell( onTap: () &#123; Navigator.pushNamed(context, '/login'); &#125;, child: Text("登录/注册", style: TextStyle(color: Colors.white)), ), ): Expanded( flex: 1, child: Column( mainAxisAlignment: MainAxisAlignment.center, crossAxisAlignment: CrossAxisAlignment.start, children: &lt;Widget&gt;[ Text("用户名：$&#123;this.userInfo[0]["username"]&#125;", style: TextStyle( color: Colors.white, fontSize: ScreenAdaper.size(32))), Text("普通会员", style: TextStyle( color: Colors.white, fontSize: ScreenAdaper.size(24))), ], ),) ], ), ), ListTile( leading: Icon(Icons.assignment, color: Colors.red), title: Text("全部订单"), ), Divider(), ListTile( leading: Icon(Icons.payment, color: Colors.green), title: Text("待付款"), ), Divider(), ListTile( leading: Icon(Icons.local_car_wash, color: Colors.orange), title: Text("待收货"), ), Container( // 中间的分割线 width: double.infinity, height: 10, color: Color.fromRGBO(242, 242, 242, 0.9)), ListTile( leading: Icon(Icons.favorite, color: Colors.lightGreen), title: Text("我的收藏"), ), Divider(), ListTile( leading: Icon(Icons.people, color: Colors.black54), title: Text("在线客服"), ), Divider(), JdButton( text: "退出登录", cb: ()&#123; UserServices.loginOut(); this._getUserinfo(); &#125;, ) ], ), ), ); &#125;&#125;]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>狗东商城</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[狗东商城(一)]]></title>
    <url>%2F2019%2F09%2F10%2F%E7%8B%97%E4%B8%9C%E5%95%86%E5%9F%8E-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[一点废话​ 公司准备做App，一下子做两个端的。最终选择了flutter来完成，学的有段日子了，教程中的京东商城项目做的大约也有了一半了，随即来记录一下，不然这段日子岂不是又白学了。开始​ 项目中的狗东商城（爱称），是最开始的b2c的版本。内容涉及的也较为广泛。大致就是下面的这种样子。项目搭建​ 先搭建出大体的框架，然后在向里面填充。底部Tab页面1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import 'package:flutter/material.dart';import '../../service/ScreenAdaper.dart';import 'Cart.dart';import 'Category.dart';import 'Home.dart';import 'User.dart';class Tabs extends StatefulWidget &#123; Tabs(&#123;Key key&#125;) : super(key: key); _TabsState createState() =&gt; _TabsState();&#125;class _TabsState extends State&lt;Tabs&gt; &#123; PageController _pageController; @override void initState() &#123; super.initState(); this._pageController = new PageController(initialPage: this._currentIndex); &#125; int _currentIndex = 0; // 存储页面的List List&lt;Widget&gt; _pageList = [ HomePage(), CategoryPage(), CartPage(), UserPage(), ]; @override Widget build(BuildContext context) &#123; ScreenAdaper.init(context); return new Scaffold( body: PageView( controller: this._pageController, children: this._pageList, onPageChanged: (index) &#123; setState(() &#123; this._currentIndex = index; &#125;); &#125;, // physics: NeverScrollableScrollPhysics(), //禁止pageView滑动 ), // 底部的切换 bottomNavigationBar: BottomNavigationBar( currentIndex: this._currentIndex, onTap: (index) &#123; setState(() &#123; // 控制底部切换的事件 this._currentIndex = index; this._pageController.jumpToPage(index); &#125;); &#125;, type: BottomNavigationBarType.fixed, fixedColor: Colors.red, items: [ BottomNavigationBarItem(icon: Icon(Icons.home), title: Text("首页")), BottomNavigationBarItem( icon: Icon(Icons.category), title: Text("分类")), BottomNavigationBarItem( icon: Icon(Icons.shopping_cart), title: Text("购物车")), BottomNavigationBarItem(icon: Icon(Icons.people), title: Text("我的")) ], ), ); &#125; /* * * IndexedStack( // 切换页面状态的一种方法，但不适于精确的页面控制，在商城项目中不太适用（购物车模块需要更新的，但是，此种方法的加载是一次加载所有的页面） index: this._currentIndex, children: _pageList, ), */&#125;路由的切换​ 路由是统一管理的，在一个类中配置完全，然后在其他类中直接调用。(此种方便大型的项目，小项目适合普通路由)123456789101112131415161718192021222324252627//配置路由final routes = &#123; '/': (context) =&gt; Tabs(), '/search': (context) =&gt; SearchPage(), '/productlist' :(context,&#123;arguments&#125;) =&gt; ProductList(arguments:arguments), '/search': (context) =&gt; SearchPage(), '/productContent': (context,&#123;arguments&#125;) =&gt; ProductContent(arguments:arguments),&#125;;//固定写法var onGenerateRoute = (RouteSettings settings) &#123;// 统一处理 final String name = settings.name; final Function pageContentBuilder = routes[name]; if (pageContentBuilder != null) &#123; if (settings.arguments != null) &#123; final Route route = MaterialPageRoute( builder: (context) =&gt; pageContentBuilder(context, arguments: settings.arguments)); return route; &#125; else &#123; final Route route = MaterialPageRoute(builder: (context) =&gt; pageContentBuilder(context)); return route; &#125; &#125;&#125;;页面的适配​ 为应对不同的设备，需要用到一个页面的适配的工具类，一般的设计原稿都是用的iphone6的尺寸。适配也是在ip6的基础上进行一定比例的放大或缩小。引入适配的库：1flutter_screenutil: ^0.5.3如何使用：1234567891011121314151617181920212223import 'package:flutter_screenutil/flutter_screenutil.dart';class ScreenAdaper&#123; // 屏幕适配器 static init(context)&#123; // 自定义了设计稿的宽高 ScreenUtil.instance = ScreenUtil(width: 750, height: 1334)..init(context); &#125; static height(double value)&#123; // 设置高 return ScreenUtil.getInstance().setHeight(value); &#125; static width(double value)&#123; // 设置宽 return ScreenUtil.getInstance().setWidth(value); &#125; static getScreenHeight()&#123; // 获得屏幕的高 return ScreenUtil.screenHeightDp; &#125; static getScreenWidth()&#123; // 获得屏幕的宽 return ScreenUtil.screenWidthDp; &#125; static size(double value)&#123; // 设置字体的大小 return ScreenUtil.getInstance().setSp(value); &#125;&#125;实体类的创建​ 移动端的大都接收json这种数据，但是将传递来的json数据渲染成为对应的实体类，如果一个个的来手写的话也是个体力活。所幸，有一个转换的网站,方便快捷。复制正确的json数据格式，就能得到对应的实体。生成后，如果后期需要也是可以直接在里面添加字段的。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125// 商品的详情数据，单个显示，不存在数组class ProductContentModel &#123; ProductContentitem result; ProductContentModel(&#123;this.result&#125;); ProductContentModel.fromJson(Map&lt;String, dynamic&gt; json) &#123; result = json['result'] != null ? new ProductContentitem.fromJson(json['result']) : null; &#125; Map&lt;String, dynamic&gt; toJson() &#123; final Map&lt;String, dynamic&gt; data = new Map&lt;String, dynamic&gt;(); if (this.result != null) &#123; data['result'] = this.result.toJson(); &#125; return data; &#125;&#125;class ProductContentitem &#123; String sId; String title; String cid; Object price; String oldPrice; Object isBest; Object isHot; Object isNew; String status; String pic; String content; String cname; List&lt;Attr&gt; attr; String subTitle; // 新增，用于购物车数量添加 int count; String selectedAttr; Object salecount; ProductContentitem( &#123;this.sId, this.title, this.cid, this.price, this.oldPrice, this.isBest, this.isHot, this.isNew, this.status, this.pic, this.content, this.cname, this.attr, this.subTitle, this.count, this.salecount, this.selectedAttr &#125;); // 通俗来说就是将json字符串(dart的Map类型的数据)转换为List的 ProductContentitem.fromJson(Map&lt;String, dynamic&gt; json) &#123; sId = json['_id']; title = json['title']; cid = json['cid']; price = json['price']; oldPrice = json['old_price']; isBest = json['is_best']; isHot = json['is_hot']; isNew = json['is_new']; status = json['status']; pic = json['pic']; content = json['content']; cname = json['cname']; if (json['attr'] != null) &#123; attr = new List&lt;Attr&gt;(); json['attr'].forEach((v) &#123; attr.add(new Attr.fromJson(v)); &#125;); &#125; subTitle = json['sub_title']; salecount = json['salecount']; // 新增 count=1; selectedAttr=''; &#125; // 将 Map&lt;String, dynamic&gt; toJson() &#123; final Map&lt;String, dynamic&gt; data = new Map&lt;String, dynamic&gt;(); data['_id'] = this.sId; data['title'] = this.title; data['cid'] = this.cid; data['price'] = this.price; data['old_price'] = this.oldPrice; data['is_best'] = this.isBest; data['is_hot'] = this.isHot; data['is_new'] = this.isNew; data['status'] = this.status; data['pic'] = this.pic; data['content'] = this.content; data['cname'] = this.cname; if (this.attr != null) &#123; data['attr'] = this.attr.map((v) =&gt; v.toJson()).toList(); &#125; data['sub_title'] = this.subTitle; data['salecount'] = this.salecount; return data; &#125;&#125;class Attr &#123; String cate; List&lt;String&gt; list; List&lt;Map&gt; attrList; Attr(&#123;this.cate, this.list&#125;); Attr.fromJson(Map&lt;String, dynamic&gt; json) &#123; cate = json['cate']; list = json['list'].cast&lt;String&gt;(); attrList=[]; &#125; Map&lt;String, dynamic&gt; toJson() &#123; final Map&lt;String, dynamic&gt; data = new Map&lt;String, dynamic&gt;(); data['cate'] = this.cate; data['list'] = this.list; return data; &#125;&#125;商品列表的数据12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// 数组形式的数据,数据的解析有循环class ProductModel &#123; List&lt;Result&gt; result; ProductModel(&#123;this.result&#125;); ProductModel.fromJson(Map&lt;String, dynamic&gt; json) &#123; if (json['result'] != null) &#123; result = new List&lt;Result&gt;(); json['result'].forEach((v) &#123; result.add(new Result.fromJson(v)); &#125;); &#125; &#125; Map&lt;String, dynamic&gt; toJson() &#123; final Map&lt;String, dynamic&gt; data = new Map&lt;String, dynamic&gt;(); if (this.result != null) &#123; data['result'] = this.result.map((v) =&gt; v.toJson()).toList(); &#125; return data; &#125;&#125;class Result &#123; String sId; String title; String cid; Object price; String oldPrice; String pic; String sPic; Result( &#123;this.sId, this.title, this.cid, this.price, this.oldPrice, this.pic, this.sPic&#125;); Result.fromJson(Map&lt;String, dynamic&gt; json) &#123; sId = json['_id']; title = json['title']; cid = json['cid']; price = json['price']; oldPrice = json['old_price']; pic = json['pic']; sPic = json['s_pic']; &#125; Map&lt;String, dynamic&gt; toJson() &#123; final Map&lt;String, dynamic&gt; data = new Map&lt;String, dynamic&gt;(); data['_id'] = this.sId; data['title'] = this.title; data['cid'] = this.cid; data['price'] = this.price; data['old_price'] = this.oldPrice; data['pic'] = this.pic; data['s_pic'] = this.sPic; return data; &#125;&#125;]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>狗东商城</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[若干排序]]></title>
    <url>%2F2019%2F09%2F09%2F%E8%8B%A5%E5%B9%B2%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[冒泡排序本质上是两两进行比较，较大向后移动，故名思意为冒泡排序。123456789for (int i = 1; i &lt;num.length ; i++) &#123; for(int j=0;j&lt;num.length-1;j++)&#123; if (num[j] &gt; num[j + 1]) &#123; int temp = num[j]; num[j] = num[j + 1]; num[j + 1] = temp; &#125; &#125;&#125;冒泡排序的最坏时间复杂度为O(N2)。因此，冒泡排序的平均时间复杂度为O(N2)。总结起来，其实就是一句话：当数据越接近正序时，冒泡排序性能越好。冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。优化即使数组是有序的也需要比较n-1次，这就不太合理了，微微的优化一下，有序后就可以直接跳出了，不用再循环了。1234567891011121314boolean flag=false;for (int i = 1; i &lt;num.length ; i++) &#123; for(int j=0;j&lt;num.length-1;j++)&#123; if (num[j] &gt; num[j + 1]) &#123; int temp = num[j]; num[j] = num[j + 1]; num[j + 1] = temp; flag=true; &#125; &#125; if(!flag)&#123; brreak; &#125;&#125;快速排序​ 找一个flag，通常为要比对数组中的第一个数，最为标尺。让两个游标（i，j）j从后向前，i从前到后遍历，遍历到下标为j的比flag小的数后停下来，然后i再从前到后遍历，找到下标为i比flag大的然后停下来，交换j与i之间的值。直到i与j重合后，将当前i与j重合的数与flag互换。然后以flag为数组中心，分成两段重复上面的操作。（递归）图片出自《啊哈算法》，很幽默风趣的一本算法数。推荐推荐推荐，图片说明的也很是清楚。123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Quickly &#123; public static void quickSort(int[] arr,int low,int high)&#123; int i,j,temp,t; if(low&gt;high)&#123; return; &#125; i=low; j=high; //temp就是基准位 temp = arr[low]; while (i&lt;j) &#123; //先看右边，依次往左递减 while (temp&lt;=arr[j]&amp;&amp;i&lt;j) &#123; j--; &#125; //再看左边，依次往右递增 while (temp&gt;=arr[i]&amp;&amp;i&lt;j) &#123; i++; &#125; //如果满足条件则交换 if (i&lt;j) &#123; t = arr[j]; arr[j] = arr[i]; arr[i] = t; &#125; &#125; //最后将基准为与i和j相等位置的数字交换 arr[low] = arr[i]; arr[i] = temp; //递归调用左半数组 quickSort(arr, low, j-1); //递归调用右半数组 quickSort(arr, j+1, high); &#125; public static void main(String[] args)&#123; int[] arr = &#123;1,3,5,7,8&#125;; quickSort(arr, 0, arr.length-1); for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125; &#125;&#125;​ 快速排序的效率很高的，通常情况下（平均）的时间复杂度为O(nlog2^n)，最坏为O(N^2)，但是快速排序不太稳定，不能用于对象的比较。（相同的值，排序后顺序会打乱）选择排序​ 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。重复，直到所有元素均排序完毕12345678910111213141516public static void main(String[] args) &#123; int[] arr = &#123;1, 3, 5, 7, 8&#125;; for (int i = 0; i &lt; arr.length - 1; i++) &#123; int min = i; for (int j = i + 1; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[min]) &#123; min = j; &#125; &#125; if (i != min) &#123; int temp = arr[i]; arr[i] = arr[min]; arr[min] = temp; &#125; &#125; &#125;​ 任何情况下都是 O(n²) ，也是一个不稳定的排序。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[navicte破解]]></title>
    <url>%2F2019%2F09%2F05%2Fnavicte%E7%A0%B4%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[安装​ 首先安装一下navicat软件（无脑下一步，但是要知道按到那个目录了），下载中有的，给的版本是112.1.22版本号有用的，后面你会用到。破解​ 附带的是有破解的文件，解压放好，同样要知道位置在哪！然后打开你的cmd窗口，管理员状态下的。然后进入到破解文件解压的目录。1cd C:\Users\ningb\Downloads\Compressed上面是我的地址。然后输入下面路径然后回车1navicat-patcher.exe "D:\soft\tools\Navicat Premium 12"这是我的安装路径。同样你需要改为自己的。没有意外就是上图的模样。不要关闭命令行，接着输入1navicat-keygen.exe -text .\RegPrivateKey.pem然后会让你选择你对应的版本，自己什么版本就选择什么版本如图最开始的软件版本也起作用了，输入后才会有密钥的。此时有密钥了，还需要你输入用户名与组织，随便输入，不用太长就可以了。这回就可以去软件里进行注册了，注册的时候切记断网，输入密钥以后需要会出现手动激活的按钮，点击后出现弹窗，弹窗上部会有一个码，下部有一个输入框，将码复制过来，命令行等的着急了。输入到命令行后，两次回车,命令行会再生成一个码，然后复制到手动激活窗口的输入框内，确定，然后就激活成功了。]]></content>
      <categories>
        <category>破解</category>
      </categories>
      <tags>
        <tag>数据库、软件破解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter零碎]]></title>
    <url>%2F2019%2F08%2F21%2Fflutter%E9%9B%B6%E7%A2%8E%2F</url>
    <content type="text"><![CDATA[沉浸式状态栏12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import 'package:flutter/material.dart';/**************************主 要 引 入************************/import 'dart:io';import 'package:flutter/services.dart';/************************************************************/void main() &#123; runApp(new MaterialApp( title: '滑动删除示例', debugShowCheckedModeBanner: false, // 去掉调试的标签 home: new MyApp(), ));&#125;class MyApp extends StatelessWidget &#123; List&lt;String&gt; items = new List&lt;String&gt;.generate(30, (i) =&gt; "列表项 $&#123;i + 1&#125;"); @override Widget build(BuildContext context) &#123;/*************************** 主 要 代 码 *********************/ if (Platform.isAndroid) &#123; SystemUiOverlayStyle systemUiOverlayStyle = SystemUiOverlayStyle(statusBarColor: Colors.transparent); SystemChrome.setSystemUIOverlayStyle(systemUiOverlayStyle); &#125;/************************************************************/ return new Scaffold( appBar: new AppBar( title: new Text('滑动删除示例'), ), body: new ListView.builder( itemCount: items.length, itemBuilder: (context, index) &#123; // 有点懵逼，这语言有点委婉 final item = items[index]; return new Dismissible( key: new Key(item), onDismissed: (direction) &#123; items.removeAt(index); Scaffold.of(context).showSnackBar( new SnackBar(content: new Text("$item 被删除了"))); &#125;, child: new ListTile(title: new Text('$item'),) ); &#125;, ), ); &#125;&#125;]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
        <tag>flutter小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[&位运算在实际项目中的使用]]></title>
    <url>%2F2019%2F08%2F15%2F%E4%BD%8D%E8%BF%90%E7%AE%97%E5%9C%A8%E5%AE%9E%E9%99%85%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[&amp;位运算的使用大二的时候在数电课上讲的，讲过就直接消化了，啥也没留下，觉得它没什么用处。工作主要写java和本专业的通信工程相差甚远。废话少说，直接来Code。123411: 0 0 0 0 1 0 1 179: 0 1 0 0 1 1 1 1————————————————————11: 0 0 0 0 1 0 1 1拿大白话来说，就是0&amp;0为0，1&amp;1为1，1&amp;0还是0，于是就有了上面的计算结果。最近的工作上改了个文章分类的bug，文章分多个板块发布，换句话了来说就是一篇文章可以发多个板块。看了看前人写的代码里，判断这篇文章究竟属于那个分类，就使用了&amp;位运算。举个例子：123456789000000001 // 语文000000010 // 数学000000100 // 英语000001000 // 物理000010000 // 化学000100000 // 生物001000000 // 体育010000000 // 历史100000000 // 政治分别用上面的二进制数代表不同的学科，小明今天上的课用二进制表示为：1100100100那么他今天都上过什么课？（不钻牛角尖，说明问题更重要）这时候使用&amp;位运算就比较合适了。将二进制表示的科目依次遍历，与小明今天上的课进行&amp;位运算，如果等于当前的二进制表示的学科。那么就意味着上过这个课。1100000000 &amp; 100100100 = 100000000 // 意味着小明今天上过政治课实际项目中，使用枚举拿到值进行遍历就阔以了。先到这，以后再添加// TODO]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型模式]]></title>
    <url>%2F2019%2F08%2F15%2F%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[浅拷贝1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class Person implements Cloneable &#123; private int age; private String name; private ArrayList&lt;String&gt; inter=new ArrayList&lt;&gt;(); public int getAge() &#123; return age; &#125; public String getName() &#123; return name; &#125; public void getInter() &#123; for (String inte:inter)&#123; System.out.println(inte); &#125; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void setName(String name) &#123; this.name = name; &#125; public void setInter(String inter) &#123; this.inter.add(inter); &#125; @Override protected Person clone() &#123; /*此种copy为浅copy,只能正确的copy基础类型，应用类型不可以copy， 但是String因为是final修饰的，所以有这样与基础类型相似的效果 其实是不可以copy的*/ try &#123; Person person = (Person) super.clone(); return person; &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; /*try &#123; Book book = (Book) super.clone();// book.image=(ArrayList&lt;String&gt;)this.image.clone();//深复制 return book; &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return null;*/ return null; &#125; public void show()&#123; System.out.println("-----start-----"); System.out.println("name:"+this.name); for (String inte:inter)&#123; System.out.println(inte); &#125; System.out.println("age:"+this.age); System.out.println("-----end-----"); &#125;&#125;1234567891011121314151617public class QianCopy &#123; public static void main(String[] args) &#123; Person person = new Person(); person.setAge(16); person.setName("ning"); person.setInter("ball"); person.show(); System.out.println("=========================="); Person person1=person.clone(); person1.setInter("fly"); person1.setName("guo"); person1.setAge(17); person1.show(); &#125;&#125;输出中可以看到List中属性有重复123456789101112131415161718192021222324252627// person-----start-----name:ningballage:16-----end-----==========================// person1-----start-----name:ningballage:16-----end-----// person1-----start-----name:guoballflyage:17-----end-----// person-----start-----name:ningballflyage:16-----end-----深拷贝​ 与浅copy的区别在于123456789101112@Override protected Person clone() &#123; try &#123; Person person = (Person) super.clone(); // 为引用类型添加一个lone person.inter = (ArrayList&lt;String&gt;) this.inter.clone(); return person; &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return null; &#125;1234567891011121314151617181920212223242526// person-----start-----name:ningballage:16-----end-----==========================// person1-----start-----name:ningballage:16-----end-----// person1-----start-----name:guoballflyage:17-----end-----// person-----start-----name:ningballage:16-----end-----]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>原型模式</tag>
        <tag>深浅拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dart(一)]]></title>
    <url>%2F2019%2F08%2F13%2Fdart-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[Hello world​ 安装dart的环境就不赘述了，无脑安装就可以了，安装过程中好像需要梯子（vpn），我装的时候失败好多次，我的梯子不能用了，准备不装了的时候，莫名其妙的装好了。迷の操作。惯例，一门新的语言必须要传统一下。123main()&#123; print("hello world");&#125;直接就输出了 “hello world”，没有那么多繁杂的语法。变量类型定义变量123456main()&#123; var age=24; // 使用var来定义变量，会自动的识别类型 int Age=24; // 直接使用int来定义也可以 age="25"; // （报错）类型检验自动识别类型以后，第一次什么类型之后就是什么类型了 print(age);&#125;定义常量1234567main()&#123; // 赋值一次后就不能改变了，称之为常量,（感觉我说的就是废话） final age=23; const Age=25; print(Age); print(age);&#125;final与const的区别：final 可以开始不赋值 只能赋一次 ; 而final不仅有const的编译时常量的特性，最重要的它是运行时常量，并且final是惰性初始化，即在运行时第一次使用前才初始化。12345main()&#123; final time=new DateTime.now(); const Time=new DateTime.now(); // 报错 print(time);&#125;字符拼接123456main()&#123; String name="kign"; String age= "23"; print(name +":"+ age); print("$&#123;name&#125;+:+$&#123;age&#125;");&#125;list的定义12345678910111213main() &#123; List l1 = ["aaa", "bbb", "ccc"]; print(l1[1]); List l2 = [ &#123;'age': 12&#125;, &#123;"age": 34&#125; ]; print(l2[0]["age"]); var l3 = new List&lt;String&gt;(); l3.add("value"); l3.add("page"); print(l3[1]);&#125;Map的定义123456789main() &#123; Map m1=&#123;"name":"张三","age":24,"work":["程序员","外卖员"]&#125;; print(m1["work"]); var p=new Map(); p["name"]="李四"; p["age"]=23; p["work"]=["程序员","外卖员"]; print(p["age"]);&#125;类型判断12345678main() &#123; var age = 25; if (age is int) &#123; // is关键字 print("int类型数据"); &#125; else &#123; print("其它类型数据"); &#125;&#125;？？运算符​ 判断当前是否为空，为空则为？？后的值，不为空则为当前赋值的值123456789main() &#123; var a; var b = a ?? 10; print(b); var c = 22; var d = c ?? 10; print(d);&#125;输出：121022??=运算符​ 判断当前变量是否为空，为空则将运算符后的数值赋值给当变量123456789main() &#123; var a; a??=23; print(a); var b=10; b??=23; print(b);&#125;输出：122310类型转换12345678main() &#123; var a="12"; var b=double.parse(a); print(b); var c="13"; print(c.toString());&#125;集合循环list1234567891011121314151617181920212223242526List myList=['香蕉','苹果','西瓜'];// 最普通的循环for(var i=0;i&lt;myList.length;i++)&#123; print(myList[i]);&#125;// forEach for(var item in myList)&#123; print(item);&#125;// forEach myList.forEach((value)&#123; print("$value");&#125;);// A数组扩大二倍赋值给B数组List myList=[1,3,4];List newList=new List();for(var i=0;i&lt;myList.length;i++)&#123; newList.add(myList[i]*2);&#125;print(newList);// A数组扩大二倍给B数组List myList=[1,3,4]; var newList=myList.map((value)&#123; return value*2;&#125;);print(newList.toList());list内容的判断123456789101112131415161718// 一List myList=[1,3,4,5,7,8,9];var newList=myList.where((value)&#123; // 将数组中大于5的给予一个新数组 return value&gt;5;&#125;);print(newList.toList());// 二List myList=[1,3,4,5,7,8,9];var f=myList.any((value)&#123; //只要集合里面有满足条件的就返回true return value&gt;5;&#125;);print(f);// 三 List myList=[1,3,4,5,7,8,9]; var f=myList.every((value)&#123; //每一个都满足条件返回true否则返回false return value&gt;5; &#125;); print(f);Set的循环12345main() &#123; var s=new Set(); s.addAll([1,222,333]); s.forEach((value)=&gt;print(value));&#125;Map的循环123456789main() &#123; Map person=&#123; "name":"张三", "age":20 &#125;; person.forEach((key,value)&#123; print("$key---$value"); &#125;);&#125;方法定义可选参数方法123456789101112main() &#123; String msg = printUserInfo("king"); // String msg = printUserInfo("king",23); print(msg);&#125;String printUserInfo(String username, [int age]) &#123; //行参 if (age != null) &#123; return "姓名:$username---年龄:$age"; &#125; return "姓名:$username---年龄保密";&#125;输出：12姓名:king---年龄保密// 姓名:king---年龄:23默认参数方法123456789101112main() &#123; print(printUserInfo('张三')); print(printUserInfo('小李', '女')); print(printUserInfo('小李', '女', 30));&#125;String printUserInfo(String username, [String sex = '男', int age]) &#123; //行参 if (age != null) &#123; return "姓名:$username---性别:$sex--年龄:$age"; &#125; return "姓名:$username---性别:$sex--年龄保密";&#125;输出：123姓名:张三---性别:男--年龄保密姓名:小李---性别:女--年龄保密姓名:小李---性别:女--年龄:30命名参数的方法12345678910main() &#123; String printUserInfo(String username, &#123;int age, String sex = '男'&#125;) &#123; //行参 if (age != null) &#123; return "姓名:$username---性别:$sex--年龄:$age"; &#125; return "姓名:$username---性别:$sex--年龄保密"; &#125; print(printUserInfo('张三', age: 20, sex: '未知'));&#125;输出：1姓名:张三---性别:未知--年龄:20将方法当作参数123456789101112main() &#123; //方法 fn1()&#123; print('fn1'); &#125; //方法 fn2(fn)&#123; fn(); &#125; //调用fn2这个方法 把fn1这个方法当做参数传入 fn2(fn1);&#125;输出：1fn1箭头函数数组循环1234567main()&#123; List list=['苹果','香蕉','西瓜']; list.forEach((value)=&gt;print(value)); list.forEach((value)=&gt;&#123; print(value) // 不能写分号，只能写一行&#125;);&#125;数组计算12345main()&#123; List list=[4,1,2,3,4]; var newList=list.map((value)=&gt;value&gt;2?value*2:value); print(newList.toList());&#125;闭包问题闭包：全局变量特点: 全局变量常驻内存、全局变量污染全局局部变量的特点： 不常驻内存会被垃圾机制回收、不会污染全局想实现的功能：常驻内存不污染全局产生了闭包,闭包可以解决这个问题…..闭包: 函数嵌套函数, 内部函数会调用外部函数的变量或参数, 变量或参数不会被系统回收(不会释放内存)闭包的写法： 函数嵌套函数，并return 里面的函数，这样就形成了闭包。全局变量123456789101112/*全局变量*/var a=123;void main() &#123; print(a); fn() &#123; a++; print(a); &#125; fn(); fn(); fn();&#125;输出：1234123124125126局部变量1234567891011void main() &#123; printInfo() &#123; var myNum = 123; myNum++; print(myNum); &#125; printInfo(); printInfo(); printInfo();&#125;输出：123124124124闭包1234567891011121314main() &#123; fn() &#123; var a = 123; /*不会污染全局 常驻内存*/ return () &#123; a++; print(a); &#125;; &#125; var b = fn(); b(); b(); b();&#125;输出：123124125126Dart的类构造函数​ dart的构造函数不像java那样可以重载，它有它自己的一套12345678910111213141516171819class Person&#123; String name; int age; //默认构造函数的简写 Person(this.name,this.age); Person.now()&#123; print('我是命名构造函数'); &#125; Person.setInfo(String name,int age)&#123; this.name=name; this.age=age; &#125; void printInfo()&#123; print("$&#123;this.name&#125;----$&#123;this.age&#125;"); &#125;&#125;类抽离成为模块​ 在此目录下的dart文件1lib/Person.dart引入所需要的类中12345678import 'lib/Person.dart';void main()&#123; Person p1=new Person.setInfo('李四1',30); p1.printInfo(); &#125;Dart中的私有方法和私有属性​ 私有方法与私有属性需要用_来修饰，但需要提取出来，否则无法达到私有的效果123456789101112131415161718192021class Animal&#123; String _name; //私有属性 int age; //默认构造函数的简写 Animal(this._name,this.age); void printInfo()&#123; print("$&#123;this._name&#125;----$&#123;this.age&#125;"); &#125; String getName()&#123; return this._name; &#125; void _run()&#123; print('这是一个私有方法'); &#125; execRun()&#123; this._run(); //类里面方法的相互调用 &#125;&#125;get与set的使用12345678910111213class Rect&#123; num height; num width; Rect(this.height,this.width); get area&#123; return this.height*this.width; &#125;&#125;void main()&#123; Rect r=new Rect(10,2); print("面积:$&#123;r.area&#125;"); //注意调用直接通过访问属性的方式访问area&#125;1234567891011121314151617class Rect&#123; num height; num width; Rect(this.height,this.width); get area&#123; return this.height*this.width; &#125; set areaHeight(value)&#123; this.height=value; &#125;&#125;void main()&#123; Rect r=new Rect(10,4); // print("面积:$&#123;r.area()&#125;"); r.areaHeight=6; print(r.area);&#125;连缀操作符12345678910111213141516171819main() &#123; Person p1 = new Person('张三1', 20); p1 ..name = "李四" ..age = 30 ..printInfo();&#125;class Person &#123; String name; num age; Person(this.name, this.age); void printInfo() &#123; print("$&#123;this.name&#125;---$&#123;this.age&#125;"); &#125;&#125;输出：1李四---30Dart的继承​ 其他未写的继承的特性与java区别不大12345678910111213141516171819202122232425262728class Person &#123; String name; num age; Person(this.name,this.age); Person.xxx(this.name,this.age); void printInfo() &#123; print("$&#123;this.name&#125;---$&#123;this.age&#125;"); &#125;&#125;class Web extends Person&#123; String sex; Web(String name, num age,String sex) : super.xxx(name, age)&#123; this.sex=sex; &#125; run()&#123; print("$&#123;this.name&#125;---$&#123;this.age&#125;--$&#123;this.sex&#125;"); &#125;&#125;main()&#123; Web w=new Web('张三', 12,"男"); w.printInfo(); w.run();&#125;输出:12张三---12张三---12--男Dart的抽象类与接口​ dart中的抽象类大致上与java并无太大的区别，也就不赘述了。需要注意的是java与dart的向上转型，后子类的方法无法调用了，需要类型的转换。​ dart是没有interface这个关键词的，接口的定义用abstract关键字修饰的。其他用法与java类似，也不赘述。dart的mixins属性12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/*mixins的中文意思是混入，就是在类中混入其他功能。在Dart中可以使用mixins实现类似多继承的功能因为mixins使用的条件，随着Dart版本一直在变，这里讲的是Dart2.x中使用mixins的条件： 1、作为mixins的类只能继承自Object，不能继承其他类 2、作为mixins的类不能有构造函数 3、一个类可以mixins多个mixins类 4、mixins绝不是继承，也不是接口，而是一种全新的特性*/class Person&#123; String name; num age; Person(this.name,this.age); printInfo()&#123; print('$&#123;this.name&#125;----$&#123;this.age&#125;'); &#125; void run()&#123; print("Person Run"); &#125;&#125;class A &#123; String info="this is A"; void printA()&#123; print("A"); &#125; void run()&#123; print("A Run"); &#125;&#125;class B &#123; void printB()&#123; print("B"); &#125; void run()&#123; print("B Run"); &#125;&#125;class C extends Person with B,A&#123; C(String name, num age) : super(name, age);&#125;void main()&#123; var c=new C('张三',20); c.printInfo(); c.run(); // 后面的继承会把前面的给覆盖掉&#125;输出：12张三----20A Run泛型接口​ 本质上和java的泛型接口大同小异1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/*Dart中的泛型接口: 实现数据缓存的功能：有文件缓存、和内存缓存。内存缓存和文件缓存按照接口约束实现。 1、定义一个泛型接口 约束实现它的子类必须有getByKey(key) 和 setByKey(key,value) 2、要求setByKey的时候的value的类型和实例化子类的时候指定的类型一致*/abstract class Cache&lt;T&gt;&#123; getByKey(String key); void setByKey(String key, T value);&#125;class FlieCache&lt;T&gt; implements Cache&lt;T&gt;&#123; @override getByKey(String key) &#123; return null; &#125; @override void setByKey(String key, T value) &#123; print("我是文件缓存 把key=$&#123;key&#125; value=$&#123;value&#125;的数据写入到了文件中"); &#125;&#125;class MemoryCache&lt;T&gt; implements Cache&lt;T&gt;&#123; @override getByKey(String key) &#123; return null; &#125; @override void setByKey(String key, T value) &#123; print("我是内存缓存 把key=$&#123;key&#125; value=$&#123;value&#125; -写入到了内存中"); &#125;&#125;void main()&#123; // MemoryCache m=new MemoryCache&lt;String&gt;(); // m.setByKey('index', '首页数据'); MemoryCache m=new MemoryCache&lt;Map&gt;(); m.setByKey('index', &#123;"name":"张三","age":20&#125;);&#125;java的对照一下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.king.Abstract;import java.util.HashMap;import java.util.Map;/** * @Author: guoning * @Description: // TODO * @Date: 2019/8/16 17:08 * @Version: 1.0 */interface Cache&lt;T&gt;&#123; String getByKey(String key); void setByKey(String key,T value);&#125;class FlieCache&lt;T&gt; implements Cache&lt;T&gt;&#123; @Override public String getByKey(String key) &#123; return null; &#125; @Override public void setByKey(String key, T value) &#123; System.out.println("我是内存缓存 把key="+key+"value="+value+" -写入到了内存中"); &#125;&#125;class MemoryCache&lt;T&gt; implements Cache&lt;T&gt;&#123; @Override public String getByKey(String key) &#123; return null; &#125; @Override public void setByKey(String key, T value) &#123; System.out.println("我是内存缓存 把key="+key+"value="+value+" -写入到了内存中"); &#125;&#125;public class Delete2&#123; public static void main(String[] args) &#123; // MemoryCache m=new MemoryCache&lt;String&gt;(); // m.setByKey('index', '首页数据'); Map&lt;String,Object&gt; map=new HashMap(); map.put("name","张三"); map.put("age",20); MemoryCache m=new MemoryCache&lt;Map&gt;(); m.setByKey("index",map); &#125;&#125;]]></content>
      <categories>
        <category>dart</category>
      </categories>
      <tags>
        <tag>dart</tag>
        <tag>new language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter页面的跳转]]></title>
    <url>%2F2019%2F08%2F06%2Fflutter%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%B7%B3%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[Flutter简单的页面跳转123456789101112131415161718192021222324252627282930313233343536373839404142434445import 'package:flutter/material.dart';void main() &#123; runApp(new MaterialApp( title: 'Stack层叠布局示例', home: new FirstScreen(), ));&#125;class FirstScreen extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; return new Scaffold( appBar: new AppBar( title: new Text('导航页面'), ), body: new Center( child: new RaisedButton(child: new Text('查看商品详情'), onPressed: ()&#123; // 以压栈的形式，将页面压入 Navigator.push(context, new MaterialPageRoute(builder: (context)=&gt; new SecondScreen()) ); &#125;), ), ); &#125;&#125;class SecondScreen extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; return new Scaffold(appBar: new AppBar( title: new Text("这是一个金铲铲"), ), body: new Center( child: new RaisedButton( onPressed: ()&#123; // 返回页面的时候会将栈顶元素pop出来 Navigator.pop(context); &#125;, child: new Text('返回页面'), ), ), ); &#125;&#125;页面跳转并发送数据12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import 'package:flutter/material.dart';class Product &#123; final String title; final String description; Product(this.title, this.description);&#125;void main() &#123; runApp(new MaterialApp( title: '传递数据示例', home: new ProductList( products: new List.generate(20, (i) =&gt; new Product('商品 $i', '这是一个商品详情 $i')), ), ));&#125;class ProductList extends StatelessWidget &#123; final List&lt;Product&gt; products; ProductList(&#123;Key key, @required this.products&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; return new Scaffold( appBar: new AppBar( title: new Text("商品列表"), ), body: new ListView.builder( itemCount: products.length, itemBuilder: (context, index) &#123; return new ListTile( title: new Text(products[index].title), onTap: () &#123; Navigator.push( context, new MaterialPageRoute( builder: (context) =&gt; new ProductDetail(product: products[index])), ); &#125;, ); &#125;), ); &#125;&#125;class ProductDetail extends StatelessWidget &#123; final Product product; ProductDetail(&#123;Key key, @required this.product&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; return new Scaffold( appBar: new AppBar( title: new Text("$&#123;product.title&#125;"), ), body: new Padding( padding: new EdgeInsets.all(16.0), child: new Text('$&#123;product.description&#125;'), ), ); &#125;&#125;带数据返回的页面跳转1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283import 'package:flutter/material.dart';void main() &#123; runApp(new MaterialApp( title: '跳转页面返回数据', home: new FirstPage(), ));&#125;class FirstPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return new Scaffold( appBar: new AppBar( title: new Text("跳转页面返回数据"), ), body: new Center(child: new RouteButton(),), ); &#125;&#125;class RouteButton extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return new RaisedButton( onPressed: ()&#123; _navigateToSecondPage(context); &#125;, child: new Text('选择一个选项，任意选项'), ); &#125; _navigateToSecondPage(BuildContext context) async &#123; final result = await Navigator.push( context, new MaterialPageRoute(builder: (context) =&gt; new SecondPage()), ); Scaffold.of(context).showSnackBar(new SnackBar(content: new Text("$result"))); &#125;&#125;class SecondPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return new Scaffold( appBar: new AppBar( title: new Text("选择一条数据"), ), body: new Center( child: new Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ new Padding( padding: const EdgeInsets.all(8.0), child: new RaisedButton( onPressed: ()&#123; Navigator.pop(context,'hi，您好'); &#125;, child: new Text('hi，您好'), ), ), new Padding( padding: const EdgeInsets.all(8.0), child: new RaisedButton( onPressed: ()&#123; Navigator.pop(context,'hi flutter'); &#125;, child: new Text('hi flutter'), ), ), ], ), ), ); &#125;&#125;]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
        <tag>dart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter简单手势]]></title>
    <url>%2F2019%2F08%2F05%2Fflutter%E7%AE%80%E5%8D%95%E6%89%8B%E5%8A%BF%2F</url>
    <content type="text"><![CDATA[简单的手势轻触tip123456789101112131415161718192021222324252627282930313233343536373839404142import 'package:flutter/material.dart';void main() &#123; runApp(new MaterialApp( title: '按下处理Demo', home: new MyApp(), ));&#125;class MyButton extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; return new GestureDetector( onTap: ()&#123; // 回调函数 final snackBar = new SnackBar(content: new Text("按下"),); // 底部弹出的提示，类似于toast Scaffold.of(context).showSnackBar(snackBar); &#125;, child: new Container( padding: new EdgeInsets.all(12.0), decoration: new BoxDecoration( color: Theme.of(context).buttonColor, borderRadius: new BorderRadius.circular(10.0), ), child: new Text('测试按钮'), ), ); &#125;&#125;class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return new Scaffold( appBar: new AppBar( title: new Text('按下处理Demo'), ), body:new Center(child: new MyButton(),) ); &#125;&#125;滑动删除​ 结合listview使用滑动手势删除。1234567891011121314151617181920212223242526272829303132333435363738import 'package:flutter/material.dart';void main() &#123; runApp(new MaterialApp( title: '滑动删除示例', home: new MyApp(), ));&#125;class MyApp extends StatelessWidget &#123; List&lt;String&gt; items = new List&lt;String&gt;.generate(30, (i) =&gt; "列表项 $&#123;i + 1&#125;"); @override Widget build(BuildContext context) &#123; return new Scaffold( appBar: new AppBar( title: new Text('滑动删除示例'), ), body: new ListView.builder( itemCount: items.length, itemBuilder: (context, index) &#123; // 有点懵逼，这语言有点委婉 final item = items[index]; return new Dismissible( key: new Key(item), onDismissed: (direction) &#123; items.removeAt(index); Scaffold.of(context).showSnackBar( new SnackBar(content: new Text("$item 被删除了"))); &#125;, child: new ListTile(title: new Text('$item'),) ); &#125;, ), ); &#125;&#125;]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
        <tag>手势</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter入门]]></title>
    <url>%2F2019%2F08%2F02%2Fflutter%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Hello Word​ 工作需要学习flutter，只知道这玩意比原生的还好快，还要美观，而且还能跨平台。但是需要学习一门新的语言，也挺麻烦的。先来个demo，熟悉一个。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107import 'package:flutter/material.dart';// 注释详细了一点void main() =&gt; runApp(MyApp()); // 程序的入口，指向runApp类class MyApp extends StatelessWidget &#123; // This widget is the root of your application.根元素 @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Flutter Demo', // 标题 theme: ThemeData( primarySwatch: Colors.red, // 主题样式 ), home: MyHomePage(title: 'Flutter Demo Home Page'), // home的界面 ); &#125;&#125;class MyHomePage extends StatefulWidget &#123; MyHomePage(&#123;Key key, this.title&#125;) : super(key: key); final String title; @override _MyHomePageState createState() =&gt; _MyHomePageState();&#125;class NewRoute extends StatelessWidget &#123; // 页面的跳转 @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text("New route"), ), body: Center( child: Text("This is new route"), ), ); &#125;&#125;class _MyHomePageState extends State&lt;MyHomePage&gt; &#123; int _counter = 0; void _incrementCounter() &#123; setState(() &#123; _counter++; &#125;); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(widget.title), ), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ Text( 'You have pushed the button this many times:', ), Text( '$_counter', style: Theme.of(context).textTheme.display1, ), FlatButton( child: Text("open new route"), textColor: Colors.blue, onPressed: () &#123; //导航到新路由 Navigator.push( context, new MaterialPageRoute(builder: (context) &#123; return new NewRoute(); &#125;)); &#125;, ), Image.asset("images/avatar.png", width: 100.0, // 添加一个宽为100.0的图片(此处类型是double的) ), TextField( // 输入框 autofocus: true, decoration: InputDecoration( labelText: "用户名", hintText: "用户名或邮箱", prefixIcon: Icon(Icons.person) ), ), TextField( decoration: InputDecoration( labelText: "密码", hintText: "您的登录密码", prefixIcon: Icon(Icons.lock) ), obscureText: true, ), ], ), ), floatingActionButton: FloatingActionButton( // 右下角的浮动按钮 onPressed: _incrementCounter, // 按钮点击事件 tooltip: 'Increment', // 长按弹出的字符 child: Icon(Icons.add), ), ); &#125;&#125;flutter布局​ flutter支持多重布局，每个布局先简单的介绍一下。水平布局123456789101112131415161718192021222324252627282930313233343536import 'package:flutter/material.dart';void main() =&gt; runApp( new MaterialApp( title: '水平布局示例', home: new LayoutDemo(), ),);class LayoutDemo extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return new Scaffold( appBar: new AppBar( title: new Text('水平布局示例'), ), body: new Row( children: &lt;Widget&gt;[ new Expanded( child: new Text('我是第一个', textAlign: TextAlign.center), ), new Expanded( child: new Text('我是第二个', textAlign: TextAlign.center), ), new Expanded( child: new FittedBox( fit: BoxFit.contain, // otherwise the logo will be tiny child: const FlutterLogo(), ), ), ], ), ); &#125;&#125;垂直布局12345678910111213141516171819202122232425262728293031import 'package:flutter/material.dart';void main() =&gt; runApp( new MaterialApp( title: '垂直布局示例', home: new LayoutDemo(), ),);class LayoutDemo extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return new Scaffold( appBar: new AppBar( title: new Text('垂直布局示例'), ), body: new Column( children: &lt;Widget&gt;[ new Text('大家好'), new Text('才是真的好'), new Expanded( child: new FittedBox( fit: BoxFit.contain, child: const FlutterLogo(), ), ), ], ), ); &#125;&#125;Container布局​ 许多布局会自由使用容器来使用padding分隔widget，或者添加边框（border）或边距（margin）。您可以通过将整个布局放入容器并更改其背景颜色或图片来更改设备的背景。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586import 'package:flutter/material.dart';void main() =&gt; runApp( new MaterialApp( title: 'Container布局容器示例', home: new LayoutDemo(), ),);class LayoutDemo extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; Widget container = new Container( decoration: new BoxDecoration( color: Colors.black26, ), child: new Column( children: &lt;Widget&gt;[ new Row( children: &lt;Widget&gt;[ new Expanded( child: new Container( width:150.0, height: 150.0, decoration: new BoxDecoration( border: new Border.all(width: 10.0,color: Colors.black38), borderRadius: const BorderRadius.all(const Radius.circular(8.0)), ), margin: const EdgeInsets.all(4.0), child: new Image.asset('images/1.jpeg'), ), ), new Expanded( child: new Container( width:150.0, height: 150.0, decoration: new BoxDecoration( border: new Border.all(width: 10.0,color: Colors.black38), borderRadius: const BorderRadius.all(const Radius.circular(8.0)), ), margin: const EdgeInsets.all(4.0), child: new Image.asset('images/2.jpeg'), ), ), ], ), new Row( children: &lt;Widget&gt;[ new Expanded( child: new Container( width:150.0, height: 150.0, decoration: new BoxDecoration( border: new Border.all(width: 10.0,color: Colors.black38), borderRadius: const BorderRadius.all(const Radius.circular(8.0)), ), margin: const EdgeInsets.all(4.0), child: new Image.asset('images/3.jpeg'), ), ), new Expanded( child: new Container( width:150.0, height: 150.0, decoration: new BoxDecoration( border: new Border.all(width: 10.0,color: Colors.black38), borderRadius: const BorderRadius.all(const Radius.circular(8.0)), ), margin: const EdgeInsets.all(4.0), child: new Image.asset('images/2.jpeg'), ), ), ], ), ], ), ); return new Scaffold( appBar: new AppBar( title: new Text('Container布局容器示例'), ), body:container, ); &#125;&#125;demo中的图片需要在配置文件中配置1234assets: - images/1.jpeg - images/2.jpeg - images/3.jpegGridView布局1234567891011121314151617181920212223242526272829303132333435363738394041import 'package:flutter/material.dart';void main() &#123; runApp(new MaterialApp( title: 'GridView布局示例', home: new MyApp(), ));&#125;class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; List&lt;Container&gt; _buildGridTitleList(int count) &#123; return new List&lt;Container&gt;.generate( count, (int index) =&gt; new Container( child: new Image.asset('images/$&#123;index + 1&#125;.jpeg'), )); &#125; Widget buildGrid()&#123; return new GridView.extent( maxCrossAxisExtent: 100.0, // 宽度为150像素的网格 padding: const EdgeInsets.all(4.0), mainAxisSpacing: 4.0, // 上下的间距 crossAxisSpacing: 8.0, // 左右的间距 children: _buildGridTitleList(9), ); &#125; return new Scaffold( appBar: new AppBar( title: new Text('GridView布局示例'), ), body: new Center( child: buildGrid(), ), ); &#125;&#125;ListView静态列表1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import 'package:flutter/material.dart';void main() &#123; runApp(new MaterialApp( title: 'ListView布局示例', home: new MyApp(), ));&#125;class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; List&lt;Widget&gt; list = &lt;Widget&gt;[ // 下一篇手势中，会有构造list的方法，dart的语法之后单独写 new ListTile( title: new Text('广州市福田区中山路店',style: new TextStyle(fontWeight: FontWeight.w400,fontSize: 18.0),), subtitle: new Text('广州市福田区国际大厦8楼'), leading: new Icon( Icons.wifi, color: Colors.pinkAccent, ), ), new ListTile( title: new Text('广州市南山区北京路店',style: new TextStyle(fontWeight: FontWeight.w400,fontSize: 18.0),), subtitle: new Text('广州市南山区比克大厦18楼'), leading: new Icon( Icons.airplay, color: Colors.green, ), ), new ListTile( title: new Text('广州市福田区中山路店',style: new TextStyle(fontWeight: FontWeight.w400,fontSize: 18.0),), subtitle: new Text('广州市福田区国际大厦8楼'), leading: new Icon( Icons.wifi, color: Colors.pinkAccent, ), ), new ListTile( title: new Text('广州市福田区中山路店',style: new TextStyle(fontWeight: FontWeight.w400,fontSize: 18.0),), subtitle: new Text('广州市福田区国际大厦8楼'), leading: new Icon( Icons.title, color: Colors.deepPurple, ), ), new ListTile( title: new Text('北京市海淀区国际大厦',style: new TextStyle(fontWeight: FontWeight.w400,fontSize: 18.0),), subtitle: new Text('北京市海淀区国际大厦亢老师教育培训'), leading: new Icon( Icons.account_circle, color: Colors.lightBlueAccent, ), ), ]; return new Scaffold( appBar: new AppBar( title: new Text('ListView布局示例'), ), body: new Center( child: new ListView( children: list, ), ), ); &#125;&#125;动态列表1234567891011121314151617181920212223242526272829303132333435363738394041import 'package:flutter/material.dart';void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123;// TODO: implement build return MaterialApp( home: Scaffold( appBar: AppBar(title: Text('FlutterDemo')), body: HomeContent(), )); &#125;&#125;class HomeContent extends StatelessWidget &#123; List list = new List(); HomeContent(&#123;Key key&#125;) : super(key: key) &#123; for (var i = 0; i &lt; 20; i++) &#123; list.add("这是第$&#123;i&#125;条数据"); &#125; print(list); &#125; @override Widget build(BuildContext context) &#123; // TODO: implement build return ListView.builder( itemCount: this.list.length, itemBuilder: (context, index) &#123; // print(context); return ListTile( leading: Icon(Icons.phone), title: Text("$&#123;list[index]&#125;"), ); &#125;, ); &#125;&#125;stack​ 使用 Stack 在基本小部件(通常是图像)上排列小部件。 小部件可以完全或部分重叠基本小部件。12345678910111213141516171819202122232425262728293031323334353637383940414243444546import 'package:flutter/material.dart';void main() &#123; runApp(new MaterialApp( title: 'Stack层叠布局示例', home: new MyApp(), ));&#125;class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; var stack = new Stack( alignment: const FractionalOffset(0.5, 0.5), // 文本在CircleAvatar所处的位置 children: &lt;Widget&gt;[ new CircleAvatar( backgroundImage: new AssetImage('images/1.jpeg'), radius: 100.0, ), new Container( decoration: new BoxDecoration( color: Colors.black38, // 盒子背景颜色 ), child: new Text( 'guoning', style: new TextStyle( fontSize: 22.0, fontWeight: FontWeight.bold, color: Colors.white, ), ), ), ], ); return new Scaffold( appBar: new AppBar( title: new Text('Stack层叠布局示例'), ), body: new Center( child: stack, ), ); &#125;&#125;层叠定位布局12345678910111213141516171819202122232425262728293031323334353637383940import 'package:flutter/material.dart';void main() &#123; runApp(new MaterialApp( title: '层叠定位布局示例', home: new MyApp(), ));&#125;class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return new Scaffold( appBar: new AppBar( title: new Text('层叠定位布局示例'), ), body: new Center( child: new Stack( children: &lt;Widget&gt;[ new Image.network('https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1539049245502&amp;di=84f58b05165b05ab75587d1c6bc73e3f&amp;imgtype=0&amp;src=http%3A%2F%2Fpic.qiantucdn.com%2F58pic%2F25%2F99%2F58%2F58aa038a167e4_1024.jpg'), new Positioned( bottom: 50.0, // 设置偏移量 right: 50.0, child: new Text( 'guoning', style: new TextStyle( fontSize: 20.0, fontWeight: FontWeight.bold, fontFamily: 'serif', color: Colors.pink, ), ) ), ], ), ), ); &#125;&#125;滚动布局1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import 'package:flutter/material.dart';void main() &#123; runApp(new MaterialApp( title: '滚动布局示例', home: new MyApp(), ));&#125;class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return new Scaffold( appBar: new AppBar( title: new Text('滚动布局示例'), ), body:new ListView( children: &lt;Widget&gt;[ // 同样此处的文字内容也可以改为图片的 new Center( child: new Text( '\n九寨沟', style: new TextStyle( fontSize:30.0, ), ), ), new Center( child: new Text( '五花海风景点', style: new TextStyle( fontSize: 16.0, ), ), ), new Center( child: new Text( // 此处的''' '''用户包裹大段文字的 ''' 九寨沟五花海 [1] 海拔2472米，水深5米，面积9万平方米，被誉为“九寨沟一绝”和“九寨精华”，在珍珠滩瀑布之上，熊猫湖的下部于日则沟孔雀河上游的尽头。五花海四周的山坡，入秋后便笼罩在一片绚丽的秋色中，色彩丰富，姿态万千。由于海底的钙华沉积和各种色泽艳丽的藻类，以及沉水植物的分布差异，使一湖之中形成了许多斑斓的色块，宝蓝、翠绿、橙黄、浅红，似无数块宝石镶嵌成的巨形佩饰，珠光宝气，雍容华贵。金秋时节，湖畔五彩缤纷的彩林倒映在湖面，与湖底的色彩混合成了一个异彩纷呈的彩色世界。其色彩十分丰富，甚至超出了画家的想象力。黄昏时分，火红的晚霞映入水中，湖水似金星飞溅，彩波粼粼，绮丽无比。从老虎嘴俯瞰它的全貌，俨然是一只羽毛丰满的开屏孔雀。长海流入五花海的水在经过石灰岩岩脉时，使水中带入了大量的石灰钙华物质。这些含有钙华物质的白色砂粒有很强的过滤作用，又像是热带珊瑚海中的沙子一样堆积着，连这里的藻类也因为受到了钙华物质的影响而变成白色。阳光一照，海子更为迷离恍惚，绚丽多姿，一片光怪陆离，使人进入了童话境地。 有“九寨沟一绝”和“九寨精华”之誉的五花海，位于四川省九寨沟日则沟孔雀河上游的尽头。沿著幽林栈道，一路下坡而去，穿越幽林，不久便到达五花海。绕过五花海的西侧，有一段栈道是欣赏水光秋色的绝佳点。游人可在此驻卟。沿着栈道继续北行，到达五花海的北岸。一片空旷、平缓的山坡地很快就到了栈疲乏的终点。这里是五花海的出水口与孔雀河道的交接点，上建一座栈桥。栈桥南侧的湖面，水色斑斓，墨绿、宝蓝、翠黄的色块混杂交钽一光十色，似孔雀彩翅；栈桥北侧，河湾状如孔誉头颈，三株古树似顶花翎。因此从这里以下被称为孔雀河道。沿著孔雀河道的左岸北行约一百米，越过河道便上到环山公路。从这段公路俯视五花海，景色更加令人叫绝。沿环山公路往东南方向，就到了五花海东南侧的最高点，这里有一块巨大的石头，称为老虎石。站在老虎石上俯视，可以观察到五花海的全貌。 五花海是九寨沟诸景点中最精彩一个。四周的山坡，入秋后便笼罩在一片绚丽的秋色中，色彩丰富，姿态万千，独霸九寨。五花海的彩叶大半集中在出水口附近的湖畔，一株株彩叶交织成锦，如火焰流金。含碳酸钙质的池水，与含不同叶绿素的水生群落，在阳光作用下，幻化出缤纷色彩，一团团、一块块，有湛蓝、有墨绿、有翠黄。岸上林丛，赤橙黄绿倒映池中，一片色彩斑斓，与水下沉木、植物相互点染，其美尤妙，故得名五花海。九寨人说：五花海是神池，它的水洒向哪儿，哪儿就花繁林茂，美丽富饶。 五花海的底部景观妙不可言，湖水一边是翠绿色的，一边是湖绿色的，湖底的枯树由于钙化，变成一丛丛灿烂的珊瑚，在阳光的照射下，五光十色，非常迷人 ''', style: new TextStyle( fontSize: 14.0, ), ), ), ], ), ); &#125;&#125;Card布局1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import 'package:flutter/material.dart';void main() &#123; runApp(MyApp());&#125;class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Flutter layout demo', home: Scaffold( appBar: AppBar( title: Text('Flutter layout demo'), ), body: Center(child: _buildCard()), ), ); &#125; // #docregion Card Widget _buildCard() =&gt; SizedBox( height: 210, child: Card( child: Column( children: [ ListTile( title: Text('1625 Main Street', style: TextStyle(fontWeight: FontWeight.w500)), subtitle: Text('My City, CA 99984'), leading: Icon( Icons.restaurant_menu, color: Colors.blue[500], ), ), Divider(), // 分割线 ListTile( title: Text('(408) 555-1212', style: TextStyle(fontWeight: FontWeight.w500)), leading: Icon( Icons.contact_phone, color: Colors.blue[500], ), ), ListTile( title: Text('costa@example.com'), leading: Icon( Icons.contact_mail, color: Colors.blue[500], ), ), ], ), ), );&#125;​ 于之前学习Android的时候，布局内容要更丰富一些，这布局只是一个浅显的入门，还要接着深入的。]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
        <tag>Dart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工厂模式]]></title>
    <url>%2F2019%2F07%2F25%2F%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[工厂模式的好处​ 工厂模式是我们最常用的实例化对象模式了，是用工厂方法代替new操作的一种模式。利用工厂模式可以降低程序的耦合性，为后期的维护修改提供了很大的便利。将选择实现类、创建对象统一管理和控制。从而将调用者跟我们的实现类解耦。简单工厂先定义一个Car的接口123public interface Car &#123; public void run();&#125;Audi123456public class Audi implements Car&#123; @Override public void run() &#123; System.out.println("我是高端豪华品牌"); &#125;&#125;Lexus123456public class Lexus implements Car&#123; @Override public void run() &#123; System.out.println("我也是高端豪华品牌"); &#125;&#125;Factory1234567891011121314151617public class Factory &#123; public static Car creatCar(String car) &#123; if ("".equals(car) &amp;&amp; null == car) &#123; return null; &#125; Car Fcar = null; switch (car) &#123; case "lexus": Fcar = new Lexus(); break; case "audi": Fcar = new Audi(); break; &#125; return Fcar; &#125;&#125;Client12345678public class Client &#123; public static void main(String[] args) &#123; Car lexus = Factory.creatCar("lexus"); Car audi = Factory.creatCar("audi"); lexus.run(); audi.run(); &#125;&#125;我们在生成工厂的时候可以加一些业务代码，如日志、判断业务等，这时候可以直接在switch case中加上去就行了。12345678910111213141516171819202122232425262728public class Factory &#123; static Car lexusProduct()&#123; System.out.println("生产雷克萨斯"); return new Lexus(); &#125; static Car audiProduct()&#123; System.out.println("生产奥迪"); return new Audi(); &#125; public static Car creatCar(String car) &#123; if ("".equals(car) &amp;&amp; null == car) &#123; return null; &#125; Car Fcar = null; switch (car) &#123; case "lexus": Fcar = lexusProduct(); break; case "audi": Fcar = audiProduct(); break; &#125; return Fcar; &#125;&#125;优点：我们可以对创建的对象进行一些 “加工” ，而且客户端并不知道，因为工厂隐藏了这些细节。如果，没有工厂的话，那我们是不是就得自己在客户端上写这些代码，这就好比本来可以在工厂里生产的东西，拿来自己手工制作，不仅麻烦以后还不好维护。缺点：如果需要在方法里写很多与对象创建有关的业务代码，而且需要的创建的对象很多的话，我们要在这个简单工厂类里编写很多个方法，每个方法里都得写很多相应的业务代码，而每次增加子类或者删除子类对象的创建都需要打开这简单工厂类来进行修改。这会导致这个简单工厂类很庞大臃肿、耦合性高，而且增加、删除某个子类对象的创建都需要打开简单工厂类来进行修改代码也违反了开-闭原则。（开闭原则是Java世界里最基础的设计原则， 它指导我们如何建立一个稳定的、 灵活的系统， 先来看开闭原则的定义：一个软件实体如类、 模块和函数应该对扩展开放， 对修改关闭）工厂方法模式Car接口与Factory接口1234567public interface Car &#123; public void run();&#125;public interface Factory &#123; public Car creatCar();&#125;生产的不同的不同类型的车12345678910111213public class Lexus implements Car &#123; @Override public void run() &#123; System.out.println("lexus"); &#125;&#125;public class Audi implements Car &#123; @Override public void run() &#123; System.out.println("Audi"); &#125;&#125;不同类型的车对应的不同的工厂12345678910111213public class AudiFactory implements Factory&#123; @Override public Car creatCar() &#123; return new Audi(); &#125;&#125;public class LexusFactory implements Factory&#123; @Override public Car creatCar() &#123; return new Lexus(); &#125;&#125;client12345678public class Client &#123; public static void main(String[] args) &#123; Car audi = new AudiFactory().creatCar(); Car lexus = new LexusFactory().creatCar(); audi.run(); lexus.run(); &#125;&#125;优点：工厂方法把简单工厂的内部逻辑判断转移到了客户端代码来进行。添加功能，本来是改工厂类的，而现在是修改客户端。而且各个不同功能的实例对象的创建代码，也没有耦合在同一个工厂类里，这也是工厂方法模式对简单工厂模式解耦的一个体现。工厂方法模式克服了简单工厂会违背开-闭原则的缺点，又保持了封装对象创建过程的优点。缺点：但工厂方法模式的缺点是每增加一个产品类，就需要增加一个对应的工厂类，增加了额外的开发量。抽象工厂模式使用数据的例子来说明，觉得这个例子很是不错，就拿来主义了实体类12345678910111213141516171819202122public class User &#123; private int uid; private String uname; public int getUid() &#123; return uid; &#125; public void setUid(int uid) &#123; this.uid = uid; &#125; public String getUname() &#123; return uname; &#125; public void setUname(String uname) &#123; this.uname = uname; &#125;&#125;User接口1234public interface IUser &#123; public void insert(User user); public User getUser(int uid);&#125;工厂接口123public interface SqlFactory &#123; public IUser createUser(); //用于访问User表的对象&#125;MysqlUser12345678910public class MysqlUser implements IUser&#123; public void insert(User user)&#123; System.out.println("在mysql中的user表中插入一条元素"); &#125; public User getUser(int id)&#123; System.out.println("在mysql中的user表得到id为"+id+"的一条数据"); return null; &#125;&#125;OracleUser123456789101112public class OracleUser implements IUser&#123; @Override public void insert(User user) &#123; System.out.println("在oracle中的user表中插入一条元素"); &#125; @Override public User getUser(int uid) &#123; System.out.println("在oracle中的user表得到id为"+uid+"的一条数据"); return null; &#125;&#125;MysqlFactory123456public class MysqlFactory implements sqlFactory&#123; @Override public IUser createUser() &#123; return new mysqlUser(); //访问mysql中User表的对象 &#125;&#125;OrcleFactory123456public class OracleFactory implements sqlFactory&#123; @Override public IUser createUser() &#123; return new oracleUser(); //访问oracle中User表的对象 &#125;&#125;Client12345678public class Client &#123; public static void main(String[] args) &#123; sqlFactory factory = new mysqlFactory(); IUser userOperator = factory.createUser(); userOperator.getUser(1); userOperator.insert(new User()); &#125;&#125;效果：比如可以，扩展一下，添加一个login的记录。Login类1234567891011121314151617181920public class Login &#123; private int id; private Date date; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public Date getDate() &#123; return date; &#125; public void setDate(Date date) &#123; this.date = date; &#125;&#125;Login功能接口1234public interface ILogin &#123; public void insert(Login login); public Login getLogin(int id);&#125;MysqlLogin12345678910public class MysqlLogin implements ILogin&#123; public void insert(Login login) &#123; System.out.println("对 MySQL 里的 Login 表插入了一条数据"); &#125; public Login getLogin(int id) &#123; System.out.println("通过 uid 在 MySQL 里的 Login 表得到了一条数据"); return null; &#125;&#125;OracleLogin12345678910public class OracleLogin implements ILogin&#123; public void insert(Login login) &#123; System.out.println("对 Oracle 里的 Login 表插入了一条数据"); &#125; public Login getLogin(int id) &#123; System.out.println("通过 uid 在 Oracle 里的 Login 表得到了一条数据"); return null; &#125;&#125;效果：优点：抽象工厂模式最大的好处是易于交换产品系列，由于具体工厂类，例如 IFactory factory=new OracleFactory(); 在一个应用中只需要在初始化的时候出现一次，这就使得改变一个应用的具体工厂变得非常容易，它只需要改变具体工厂即可使用不同的产品配置。不管是任何人的设计都无法去完全防止需求的更改，或者项目的维护，那么我们的理想便是让改动变得最小、最容易，例如我现在要更改以上代码的数据库访问时，只需要更改具体的工厂即可。抽象工厂模式的另一个好处就是它让具体的创建实例过程与客户端分离，客户端是通过它们的抽象接口操作实例，产品实现类的具体类名也被具体的工厂实现类分离，不会出现在客户端代码中。就像我们上面的例子，客户端只认识IUser和ILogin，至于它是MySQl里的表还是Oracle里的表就不知道了。缺点：如果你的需求来自增加功能，比如增加Login表，就有点太烦了。首先需要增加 ILogin，mysqlLogin,oracleLogin。 然后我们还要去修改工厂类： sqlFactory， mysqlFactory， oracleFactory 才可以实现，需要修改三个类，实在是有点麻烦。还有就是，客户端程序肯定不止一个，每次都需要声明sqlFactory factory=new MysqlFactory()， 如果有100个调用数据库的类，就需要更改100次sqlFactory factory=new oracleFactory()。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>工厂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[枚举]]></title>
    <url>%2F2019%2F07%2F24%2F%E6%9E%9A%E4%B8%BE%2F</url>
    <content type="text"><![CDATA[Please enter the password to read the blog. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>枚举</tag>
        <tag>查漏补缺</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式]]></title>
    <url>%2F2019%2F07%2F23%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[应用场景windows的任务管理器网站的计数器应用程序的日志数据库连接池，因为数据库连接是一种数据库资源。数据库软件系统中使用数据库连接池，主要是节省打开或者关闭数据库连接所引起的效率损耗，这种效率上的损耗还是非常昂贵的，因为何用单例模式来维护，就可以大大降低这种损耗。多线程的线程池的设计一般也是采用单例模式，这是由于线程池要方便对池中的线程进行控制。操作系统的文件系统，也是大的单例模式实现的具体例子，一个操作系统只能有一个文件系统。优缺点优点：在单例模式中，活动的单例只有一个实例，对单例类的所有实例化得到的都是相同的一个实例。这样就 防止其它对象对自己的实例化，确保所有的对象都访问一个实例单例模式具有一定的伸缩性，类自己来控制实例化进程，类就在改变实例化进程上有相应的伸缩性。提供了对唯一实例的受控访问。由于在系统内存中只存在一个对象，因此可以 节约系统资源，当 需要频繁创建和销毁的对象时单例模式无疑可以提高系统的性能。允许可变数目的实例。避免对共享资源的多重占用。缺点：不适用于变化的对象，如果同一类型的对象总是要在不同的用例场景发生变化，单例就会引起数据的错误，不能保存彼此的状态。由于单利模式中没有抽象层，因此单例类的扩展有很大的困难。单例类的职责过重，在一定程度上违背了“单一职责原则”。滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；如果实例化的对象长时间不被利用，系统会认为是垃圾而被回收，这将导致对象状态的丢失。饿汉式12345678910111213public class SingletonDemo &#123; // 类初始化时,会立即加载该对象，线程天生安全,调用效率高 private static SingletonDemo singletonDemo = new SingletonDemo(); private SingletonDemo() &#123; System.out.println("SingletonDemo初始化"); &#125; public static SingletonDemo getInstance() &#123; System.out.println("getInstance"); return singletonDemo; &#125;&#125;懒汉式1234567891011121314public class SingletonDemo &#123; //类初始化时，不会初始化该对象，真正需要使用的时候才会创建该对象。 private static SingletonDemo singletonDemo; private SingletonDemo() &#123; &#125; public synchronized static SingletonDemo getInstance() &#123; if (singletonDemo == null) &#123; singletonDemo = new SingletonDemo(); &#125; return singletonDemo; &#125;&#125;在实例化方法上加synchronzied，太影响运行效率，改为123456789101112131415public class SingletonDemo &#123; private static SingletonDemo singletonDemo; private SingletonDemo() &#123; &#125; public synchronized static SingletonDemo getInstance() &#123; if (singletonDemo == null) &#123; synchronized(SingletonDemo.class)&#123; // 这样对相率有所提升(好像有点问题，忘了在哪学的，存疑？) singletonDemo = new SingletonDemo(); &#125; &#125; return singletonDemo; &#125;&#125;静态内部类《Effective Java》中所推荐的方法1234567891011public class Singleton &#123; private static class SingletonHolder &#123; private static final Singleton uniqueInstance = new Singleton(); &#125; private Singleton ()&#123; &#125; public static final Singleton getInstance() &#123; return SingletonHolder.uniqueInstance; &#125; &#125;使用枚举来创建单例​ 枚举创建本质上就是一个单例，所以枚举可以达到单例的效果。枚举创建单例不仅可以防止反射来创建对象，还可以防止反序列化的方式创建对象。（枚举的使用，之后再开一篇，之前可能是环境的局限性，很少用到枚举的，需要恶补一下）12345678910111213141516171819202122232425/使用枚举实现单例模式 优点:实现简单、枚举本身就是单例，由jvm从根本上提供保障!避免通过反射和反序列化的漏洞 缺点没有延迟加载public class User &#123; public static User getInstance() &#123; return SingletonDemo.INSTANCE.getInstance(); &#125; private static enum SingletonDemo &#123; INSTANCE; // 枚举元素为单例 private User user; private SingletonDemo() &#123; user = new User(); &#125; public User getInstance() &#123; return user; &#125; &#125; public static void main(String[] args) &#123; User u1 = User.getInstance(); User u2 = User.getInstance(); System.out.println(u1 == u2); &#125;&#125;双重监测锁1234567891011121314151617public class SingletonDemo &#123; private volatile SingletonDemo singletonDemo; // 加 volatile 避免重排序问题 private SingletonDemo() &#123; &#125; public SingletonDemo getInstance() &#123; if (singletonDemo == null) &#123; synchronized (SingletonDemo.class) &#123; if (singletonDemo == null) &#123; singletonDemo = new SingletonDemo(); // 多线程下可能会出现重排序的问题 &#125; &#125; &#125; return singletonDemo; &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>单例</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反射机制]]></title>
    <url>%2F2019%2F07%2F21%2F%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[什么是反射​ JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。创建对象的三种方式12345678910111213141516171819public static void main(String[] args) &#123; Student stu = new Student();//这一new 产生一个Student对象，一个Class对象。 Class stuClass1 = stu.getClass();//获取Class对象 System.out.println(stuClass1.getName()); //第二种方式获取Class对象 Class stuClass2 = Student.class; //判断第一种方式获取的Class对象和第二种方式获取的是否是同一个 System.out.println(stuClass1 == stuClass2); //第三种方式获取Class对象 try &#123; //注意此字符串必须是真实路径，就是带包名的类路径，包名.类名 Class stuClass3 = Class.forName("com.king.student.Student"); System.out.println(stuClass3 == stuClass2);//判断三种方式是否获取的是同一个Class对象 &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;使用反射获取构造方法123456789101112131415161718192021222324252627282930313233public static void main(String[] args) throws Exception &#123; //1.加载Class对象 Class clazz = Class.forName("com.king.student.Student"); //2.获取所有公有构造方法 Constructor[] conArray = clazz.getConstructors(); for(Constructor c : conArray)&#123; System.out.println(c); &#125; //3.所有的构造方法(包括：私有、受保护、默认、公有) conArray = clazz.getDeclaredConstructors(); for(Constructor c : conArray)&#123; System.out.println(c); &#125; //4. 获取公有、无参的构造方法 Constructor con = clazz.getConstructor(null); //1&gt;、因为是无参的构造方法所以类型是一个null,不写也可以,这里需要的是一个参数的类型，切记是类型 //2&gt;、返回的是描述这个无参构造函数的类对象。 //调用构造方法 Object obj = con.newInstance(); // 5.获取私有构造方法，并调用 con = clazz.getDeclaredConstructor(char.class); System.out.println(con); //调用构造方法 con.setAccessible(true);//暴力访问(忽略掉访问修饰符) obj = con.newInstance('男'); // 6.私有的单个参数的构造方法 Constructor StringCon = clazz.getDeclaredConstructor(String.class); StringCon.setAccessible(true); StringCon.newInstance("qwert"); &#125;获取成员变量并使用1234567891011121314151617181920212223242526272829//1.加载Class对象 Class stuClass = Class.forName("com.king.student.Student"); //2.获取字段获取所有公有的字段 Field[] fieldArray = stuClass.getFields(); for(Field f : fieldArray)&#123; System.out.println(f); &#125; //3.获取所有的字段(包括私有、受保护、默认的) fieldArray = stuClass.getDeclaredFields(); for(Field f : fieldArray)&#123; System.out.println(f); &#125; // 4.获取公有字段**并调用 Field f = stuClass.getField("name"); System.out.println(f); //获取一个对象 Object obj = stuClass.getConstructor().newInstance(); //为字段设置值 f.set(obj, "刘德华");//为Student对象中的name属性赋值--&gt;stu.name = "刘德华" Student stu = (Student)obj; System.out.println("验证姓名：" + stu.name); //5.获取私有字段 f = stuClass.getDeclaredField("phoneNum"); System.out.println(f); f.setAccessible(true);//暴力反射，解除私有限定 f.set(obj, "18888889999"); System.out.println("验证电话：" + stu); &#125;获得成员方法并调用1234567891011121314151617181920212223242526272829public static void main(String[] args) throws Exception &#123; //1.加载Class对象 Class stuClass = Class.forName("com.king.student.Student"); //2.获取所有公有方法 stuClass.getMethods(); Method[] methodArray = stuClass.getMethods(); for(Method m : methodArray)&#123; System.out.println(m); &#125; // 3.获取所有的方法，包括私有的 methodArray = stuClass.getDeclaredMethods(); for(Method m : methodArray)&#123; System.out.println(m); &#125; //3.获取公有的show1()方法 Method m = stuClass.getMethod("show1", String.class); System.out.println(m); //实例化一个Student对象 Object obj = stuClass.getConstructor().newInstance(); m.invoke(obj, "刘德华"); // 4.获取私有的show4()方法 m = stuClass.getDeclaredMethod("show4", int.class); System.out.println(m); m.setAccessible(true);//解除私有限定 Object result = m.invoke(obj, 20);//需要两个参数，一个是要调用的对象（获取有反射），一个是实参 System.out.println("返回值：" + result); &#125;反射调用main方法12345678910111213141516171819public static void main(String[] args) throws Exception &#123; try &#123; //1.加载Class对象 Class clazz = Class.forName("com.king.student.Student"); //2、获取main方法 //第一个参数：方法名称，第二个参数：方法形参的类型， Method methodMain = clazz.getMethod("main", String[].class); //3、调用main方法 // methodMain.invoke(null, new String[]&#123;“a”,”b”,”c”&#125;); //第一个参数，对象类型，因为方法是static静态的，所以为null可以， //第二个参数是String数组，这里要注意在jdk1.4时是数组，jdk1.5之后是可变参数 //这里拆的时候将 new String[]&#123;“a”,”b”,”c”&#125; 拆成3个对象。。。所以需要将它强转。 // methodMain.invoke(null, (Object)new String[]&#123;"a","b","c"&#125;);//方式一 methodMain.invoke(null, new Object[]&#123;new String[]&#123;"a","b","c"&#125;&#125;);//方式二 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;通过反射运行配置文件12className = com.king.student.StudentmethodName = show1123456789101112131415161718public static void main(String[] args) throws Exception &#123; //通过反射获取Class对象 Class stuClass = Class.forName(getValue(”className”));//com.king.student.Student //2获取show()方法 Method m = stuClass.getMethod(getValue(”methodName”));//show //3.调用show()方法 m.invoke(stuClass.getConstructor().newInstance()); &#125; //此方法接收一个key，在配置文件中获取相应的value public static String getValue(String key) throws IOException&#123; Properties pro = new Properties();//获取配置文件的对象 FileReader in = new FileReader("pro.txt");//获取输入流 pro.load(in);//将流加载到配置文件对象中 in.close(); return pro.getProperty(key);//返回根据key获取的value值 &#125;通过反射越过泛型检查12345678910111213141516public static void main(String[] args) throws Exception&#123; ArrayList&lt;String&gt; strList = new ArrayList&lt;&gt;(); strList.add(”aaa”); strList.add(”bbb”); // strList.add(100); //获取ArrayList的Class对象，反向的调用add()方法，添加数据 Class listClass = strList.getClass(); //得到 strList 对象的字节码 对象 //获取add()方法 Method m = listClass.getMethod(”add”, Object.class); //调用add()方法 m.invoke(strList, 100); //遍历集合 for(Object obj : strList)&#123; System.out.println(obj); &#125; &#125;泛型这个之前面试被人问过，从最开始问我List的泛型中放包装类型还是基本类型！到你觉得java中什么技术比较重要，最后跑到反射中了，然后又告诉我，反射可以这么干。我也不相信，回去自己试了一下，真的可以！面试套路比较深。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[锁的深入化]]></title>
    <url>%2F2019%2F07%2F20%2F%E9%94%81%E7%9A%84%E6%B7%B1%E5%85%A5%E5%8C%96%2F</url>
    <content type="text"><![CDATA[重入锁锁作为并发共享数据，保证一致性的工具，如 synchronized（重量级） 和 reentrantLock(轻量级)。这些已经写好提供的锁为我们开发提供了便利。重入锁，也叫做递归锁，指的是同一线程外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。synchronized1234567891011121314151617181920public class Test implements Runnable &#123; public synchronized void get() &#123; System.out.println("name:" + Thread.currentThread().getName() + " get();"); set(); &#125; public synchronized void set() &#123; System.out.println("name:" + Thread.currentThread().getName() + " set();"); &#125; @Override public void run() &#123; get(); &#125; public static void main(String[] args) &#123; Test ss = new Test(); new Thread(ss).start(); new Thread(ss).start(); new Thread(ss).start(); new Thread(ss).start(); &#125;&#125;reentrantLock123456789101112131415161718192021222324public class Test extends Thread &#123; ReentrantLock lock = new ReentrantLock(); public void get() &#123; lock.lock(); // 加锁，释放所 System.out.println(Thread.currentThread().getId()); set(); lock.unlock(); &#125; public void set() &#123; lock.lock(); System.out.println(Thread.currentThread().getId()); lock.unlock(); &#125; @Override public void run() &#123; get(); &#125; public static void main(String[] args) &#123; Test ss = new Test(); new Thread(ss).start(); new Thread(ss).start(); new Thread(ss).start(); &#125;&#125;读写锁​ 程序中涉及到对一些共享资源的读和写操作，且写操作没有读操作那么频繁。在没有写操作的时候，两个线程同时读一个资源没有任何问题，所以应该允许多个线程能在同时读取共享资源。但是如果有一个线程想去写这些共享资源，就不应该再有其它线程对该资源进行读或写（读-读能共存，读-写不能共存，写-写不能共存）。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class Cache &#123; static Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); static ReentrantReadWriteLock rwl = new ReentrantReadWriteLock(); static Lock r = rwl.readLock(); static Lock w = rwl.writeLock(); // 获取一个key对应的value public static final Object get(String key) &#123; r.lock(); try &#123; System.out.println("正在做读的操作,key:" + key + " 开始"); Thread.sleep(100); Object object = map.get(key); System.out.println("正在做读的操作,key:" + key + " 结束"); System.out.println(); return object; &#125; catch (InterruptedException e) &#123; &#125; finally &#123; r.unlock(); &#125; return key; &#125; // 设置key对应的value，并返回旧有的value public static final Object put(String key, Object value) &#123; w.lock(); try &#123; System.out.println("正在做写的操作,key:" + key + ",value:" + value + "开始."); Thread.sleep(100); Object object = map.put(key, value); System.out.println("正在做写的操作,key:" + key + ",value:" + value + "结束."); System.out.println(); return object; &#125; catch (InterruptedException e) &#123; &#125; finally &#123; w.unlock(); &#125; return value; &#125; // 清空所有的内容 public static final void clear() &#123; w.lock(); try &#123; map.clear(); &#125; finally &#123; w.unlock(); &#125; &#125; public static void main(String[] args) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; Cache.put(i + "", i + ""); &#125; &#125; &#125;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; Cache.get(i + ""); &#125; &#125; &#125;).start(); &#125;&#125;乐观锁与悲观锁乐观锁​ 总是认为不会产生并发问题，每次去取数据的时候总认为不会有其他线程对数据进行修改，因此不会上锁，但是在更新时会判断其他线程在这之前有没有对数据进行修改，一般会使用版本号机制或CAS操作实现。version方式：一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。核心SQL语句 update table set x=x+1, version=version+1 where id=#{id} and version=#{version};CAS操作方式：即或者，涉及到三个操作数，数据所在的内存值，预期值，新值。当需要更新时，判断当前内存值与之前取到的值是否相等，若相等，则用新值更新，若失败则重试，一般情况下是一个自旋操作，即不断的重试。（后面会详细的讲）悲观锁​ 总是假设最坏的情况，每次取数据时都认为其他线程会修改，所以都会加锁（读锁、写锁、行锁等），当其他线程想要访问数据时，都需要阻塞挂起。可以依靠数据库实现，如行锁、读锁和写锁等，都是在操作之前加锁，在Java中，synchronized的思想也是悲观锁。cas无锁机制与锁相比，使用比较交换（下文简称CAS）会使程序看起来更加复杂一些。但由于其非阻塞性，它对死锁问题天生免疫，并且，线程间的相互影响也远远比基于锁的方式要小。更为重要的是，使用无锁的方式完全没有锁竞争带来的系统开销，也没有线程间频繁调度带来的开销，因此，它要比基于锁的方式拥有更优越的性能。无锁的好处：第一，在高并发的情况下，它比有锁的程序拥有更好的性能；第二，它天生就是死锁免疫的。就凭借这两个优势，就值得我们冒险尝试使用无锁的并发。CAS算法的过程是这样：它包含三个参数CAS(V,E,N): V表示要更新的变量，E表示预期值，N表示新值。仅当V值等于E值时，才会将V的值设为N，如果V值和E值不同，则说明已经有其他线程做了更新，则当前线程什么都不做（或者循环上一步，直到满意为止）。最后，CAS返回当前V的真实值。CAS操作是抱着乐观的态度进行的，它总是认为自己可以成功完成操作。当多个线程同时使用CAS操作一个变量时，只有一个会胜出，并成功更新，其余均会失败。失败的线程不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。基于这样的原理，CAS操作即使没有锁，也可以发现其他线程对当前线程的干扰，并进行恰当的处理。简单地说，CAS需要你额外给出一个期望值，也就是你认为这个变量现在应该是什么样子的。如果变量不是你想象的那样，那说明它已经被别人修改过了。你就重新读取，再次尝试修改就好了。在硬件层面，大部分的现代处理器都已经支持原子化的CAS指令。在JDK 5.0以后，虚拟机便可以使用这个指令来实现并发操作和并发数据结构，并且，这种操作在虚拟机中可以说是无处不在。CAS算法图解： （补充图片中的一些说明：刷新主内存，同时也会同步到各个副本之中）CAS存在一个很明显的问题，即ABA问题!如果在这段期间曾经被改成B，然后又改回A，那CAS操作就会误认为它从来没有被修改过。针对这种情况，java并发包中提供了一个带有标记的原子引用类AtomicStampedReference，它可以通过控制变量值的版本来保证CAS的正确性。原子类AtomicInteger​ AtomicInteger，一个提供原子操作的Integer的类。在Java语言中，++i和i++操作并不是线程安全的，在使用的时候，不可避免的会用到synchronized关键字。而AtomicInteger则通过一种线程安全的加减操作接口12345public final int get() //获取当前的值public final int getAndSet(int newValue)//获取当前的值，并设置新的值public final int getAndIncrement()//获取当前的值，并自增public final int getAndDecrement() //获取当前的值，并自减public final int getAndAdd(int delta) //获取当前的值，并加上预期的值Demo1234567891011class Test &#123; private AtomicInteger count = new AtomicInteger(); public void increment() &#123; count.incrementAndGet(); &#125; //使用AtomicInteger之后，不需要加锁，也可以实现线程安全。 public int getCount() &#123; return count.get(); &#125;&#125;其他原子类留待以后补充一下……// TODO]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>锁</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[callable与future]]></title>
    <url>%2F2019%2F07%2F06%2Fcallable%E4%B8%8Efuture%2F</url>
    <content type="text"><![CDATA[callable与future​ 在Java中，创建线程一般有两种方式，一种是继承Thread类，一种是实现Runnable接口。然而，这两种方式的缺点是在线程任务执行结束后，无法获取执行结果。我们一般只能采用共享变量或共享存储区以及线程通信的方式实现获得任务结果的目的。不过，Java中，也提供了使用Callable和Future来实现获取任务结果的操作。Callable用来执行任务，产生结果，而Future用来获得结果。12345678910@FunctionalInterfacepublic interface Callable&lt;V&gt; &#123; /** * Computes a result, or throws an exception if unable to do so. * * @return computed result * @throws Exception if unable to compute a result */ V call() throws Exception;&#125;以上Callable的源码，接口带有泛型的返回值。Future中的常用方法V get() ：获取异步执行的结果，如果没有结果可用，此方法会阻塞直到异步计算完成。V get(Long timeout , TimeUnitunit) ：获取异步执行结果，如果没有结果可用，此方法会阻塞，但是会有时间限制，如果阻塞时间超过设定的timeout时间，该方法将抛出异常。boolean isDone() ：如果任务执行结束，无论是正常结束或是中途取消还是发生异常，都返回true。boolean isCanceller() ：如果任务完成前被取消，则返回true。boolean cancel(booleanmayInterruptRunning) ：如果任务还没开始，执行cancel(…)方法将返回false；如果任务已经启动，执行cancel(true)方法将以中断执行此任务线程的方式来试图停止任务，如果停止成功，返回true；当任务已经启动，执行cancel(false)方法将不会对正在执行的任务线程产生影响(让线程正常执行到完成)，此时返回false；当任务已经完成，执行cancel(…)方法将返回false。mayInterruptRunning参数表示是否中断执行中的线程。demo12345678910111213141516171819202122232425262728public class TestMain &#123; public static void main(String[] args) throws InterruptedException, ExecutionException &#123; ExecutorService executor = Executors.newCachedThreadPool(); Future&lt;Integer&gt; future = executor.submit(new AddNumberTask()); System.out.println(Thread.currentThread().getName() + "线程执行其他任务"); Integer integer = future.get(); // 调用get后会阻塞，直到future拿到返回的数据 System.out.println(integer); // 关闭线程池 if (executor != null) executor.shutdown(); &#125;&#125;class AddNumberTask implements Callable&lt;Integer&gt; &#123; public AddNumberTask() &#123; &#125; @Override public Integer call() throws Exception &#123; System.out.println("####AddNumberTask###call()"); Thread.sleep(5000); return 5000; &#125;&#125;Future模式Future模式的核心在于：去除了主函数的等待时间，并使得原本需要等待的时间段可以用于处理其他业务逻辑Futrure模式:对于多线程，如果线程A要等待线程B的结果，那么线程A没必要等待B，直到B有结果，可以先拿到一个未来的Future，等B有结果是再取真实的结果。原理：本质上是notify与wait的结合使用！附上原理解析代码​ Data接口123public interface Data &#123; public abstract String getRequest();&#125;12345678910111213141516171819202122232425262728293031public class FurureData implements Data &#123; public volatile static boolean ISFLAG = false; private RealData realData; public synchronized void setRealData(RealData realData) &#123; // 如果已经获取到结果，直接返回 if (ISFLAG) &#123; return; &#125; // 如果没有获取到数据,传递真是对象 this.realData = realData; ISFLAG = true; // 进行通知 notify(); &#125; @Override public synchronized String getRequest() &#123; while (!ISFLAG) &#123; try &#123; wait(); &#125; catch (Exception e) &#123; &#125; &#125; // 获取到数据,直接返回 return realData.getRequest(); &#125;&#125;12345678910111213141516171819public class RealData implements Data &#123; private String result; public RealData(String data) &#123; System.out.println("正在使用data:" + data + "网络请求数据,耗时操作需要等待."); try &#123; Thread.sleep(3000); &#125; catch (Exception e) &#123; &#125; System.out.println("操作完毕,获取结果..."); result = data; &#125; @Override public String getRequest() &#123; return result; &#125;&#125;1234567891011121314151617public class FutureClient &#123; public Data request(final String queryStr) &#123; final FurureData furureData = new FurureData(); new Thread(new Runnable() &#123; @Override public void run() &#123; RealData realData = new RealData(queryStr); furureData.setRealData(realData); // set完成时唤醒 &#125; &#125;).start(); return furureData; &#125;&#125;1234567891011public class Main &#123; public static void main(String[] args) &#123; FutureClient futureClient = new FutureClient(); Data request = futureClient.request("请求参数."); System.out.println("请求发送成功!"); System.out.println("执行其他任务..."); String result = request.getRequest(); // 此处如果set未设置上值，会阻塞 System.out.println("获取到结果..." + result); &#125;&#125;运行效果]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给hexo博客的NEXT添加一个云日历]]></title>
    <url>%2F2019%2F06%2F24%2F%E7%BB%99hexo%E5%8D%9A%E5%AE%A2%E7%9A%84NEXT%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E4%BA%91%E6%97%A5%E5%8E%86%2F</url>
    <content type="text"><![CDATA[一点废话hexo中有文件的归档，但是博文的数目多了，浏览的时候也是很不方便的。于是我就有找个云日历的想法了，折腾了几天，网上的方法都试过了。但是没出效果。于是想着自己来写一个。这自己写的这部分是基于净土大神的日历插件。也是我这个云日历的灵魂，感谢大神。效果先看效果，不满意就不用向下看了。可以去找找其他的。图片什么的我就不截了，你直接去我的博客中看吧！会飞的扫帚还是放一张图，吸引一下别人吧！进入正题插件​ 先贴上净土大神写的日历插件，直接在在命令行窗口安装。前提是你要装的有node.js1npm install --save git://github.com/howiefh/hexo-generator-calendar.git安装完毕以后，运行一下 hexo g ，然后去hexo目录下的public 目录下看看是是否有一个calendar.json 文件，这个很重要的。一点说明我使用的是Next的muse主题，比较简约，而且有一个空间比较大的侧边栏。其他的主题，你们自己尝试吧！文件准备放到百度云盘里自取，这是地址 (wl8h)，之前我将这三个引入index.html的文件放在github上引用，后来GitHub的策略便了，我就放到next主题的文件夹内了。开始整合​ 找到 hexo\themes\next\layout_custom\siderbar.swig 文件，将准备好的index.html文件同级别放置，然后打开sidebar.swig文件。在最上面添加代码：123&lt;div id="coustomerCal"&gt; &#123;% include "index.html" %&#125; // swig的语法，我是个菜鸡我也是查资料才知道的&lt;/div&gt;找到hexo\themes\next\source 目录，将对应的css文件，js文件放入到对应的目录下即可最后​ 最开始的那个日历插件，如果没有问题的话，会出现在你的hexo仓库的根目录下，你在github上打开，点击row，copy网址，然后替换calendar.js最后的地址,文件直接拉到最后就看到了。下面的地址是我自己的，你要替换成你的。近来，github又抽风了，点击row也没办法加载这个calendar.json了，我琢磨了一下，直接在calendar.js中用/calendar。json替代github上生成的calendar.json的网络地址，也是可以而且还不用担心网络问题。尾记​ 这个玩意里面可优化的东西很多，如果你使用的话，你自己优化一下，我因为不是专业的前端，也秉持着能将就就将就的原则也没改，这篇文章的修改还是因为github的策略有变我才写的。如果有问题，请留言，我看到了一定会回复的！]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具,突发奇想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给博客添加上宠物]]></title>
    <url>%2F2019%2F06%2F18%2F%E7%BB%99%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E4%B8%8A%E5%AE%A0%E7%89%A9%2F</url>
    <content type="text"><![CDATA[开始之前在博客园上看到，公告栏里有人竟然在养鱼，觉得很好玩！一直念念不忘的，于是就想着在hexo中也来养几只，因为我用的事Next的Muse主题，所以有一个非常合适的侧边栏，先来看看效果。进入正题首先你要去找几只宠物养一下，领养的网站aBowman去找你想养的宠物，狗、乌龟、青蛙之类的。以小金鱼为例子，在下面的 edit settings按钮中可以设置一些参数，颜色、数目、背景图、食物颜色之类的。设置完成以后，下面的框框里有对应的代码，愉快的给copy出来备用。操作主题找到主题下的layout/_custom/sidebar.swig文件，将这一段给copy上。外层用div包裹一下，方便调整样式。当然了，直接复制过来的样式一定不满意，你可以在div中自己修改，也可以在 next/source/css/_custom/custom.style自己添加，直接修改外层包裹着的行间样式，也是可以的！123&lt;div id="fish" style="text-align: center;margin-top: 18px;"&gt;&lt;object type="application/x-shockwave-flash" style="outline:none;" data="/js/fish.swf?up_fishColor1=F45540&amp;amp;up_fishColor4=0D0C0C&amp;amp;up_fishColor9=F45540&amp;amp;up_fishColor6=F45540&amp;amp;up_fishColor5=F45540&amp;amp;up_fishColor10=F45540&amp;amp;up_foodColor=FCB347&amp;amp;up_fishColor3=080707&amp;amp;up_fishColor7=F45540&amp;amp;up_backgroundImage=/images/finsh.JPG&amp;amp;up_numFish=6&amp;amp;up_fishName=Fish&amp;amp;up_fishColor2=F45540&amp;amp;up_fishColor8=F45540&amp;amp;up_backgroundColor=F0F7FF&amp;amp;" width="200" height="375"&gt;&lt;param name="movie" value="https://cdn.abowman.com/widgets/fish/fish.swf?up_fishColor1=F45540&amp;amp;up_fishColor4=0D0C0C&amp;amp;up_fishColor9=F45540&amp;amp;up_fishColor6=F45540&amp;amp;up_fishColor5=F45540&amp;amp;up_fishColor10=F45540&amp;amp;up_foodColor=FCB347&amp;amp;up_fishColor3=080707&amp;amp;up_fishColor7=F45540&amp;amp;up_backgroundImage=http://img.1ppt.com/uploads/allimg/1805/1_180523223723_7.JPG&amp;amp;up_numFish=6&amp;amp;up_fishName=Fish&amp;amp;up_fishColor2=F45540&amp;amp;up_fishColor8=F45540&amp;amp;up_backgroundColor=F0F7FF&amp;amp;"&gt;&lt;param name="AllowScriptAccess" value="always"&gt;&lt;param name="wmode" value="opaque"&gt;&lt;param name="scale" value="noscale"&gt;&lt;param name="salign" value="tl"&gt;&lt;/object&gt;&lt;/div&gt;背景图片flash我已经放到资源目录中了，这块代码仅供参考，要使用你需要修改 data 与 backgroundImage 将路径改为对应的网络地址。你已经懒到了不想修改了，直接使用我这个样式的！！！也给你！123&lt;div id="finsh" style="text-align: center;margin-top: 18px;"&gt; &lt;object type="application/x-shockwave-flash" style="outline:none;" data="https://cdn.abowman.com/widgets/fish/fish.swf?up_fishColor1=F45540&amp;up_fishColor4=0D0C0C&amp;up_fishColor9=F45540&amp;up_fishColor6=F45540&amp;up_fishColor5=F45540&amp;up_fishColor10=F45540&amp;up_foodColor=FCB347&amp;up_fishColor3=080707&amp;up_fishColor7=F45540&amp;up_backgroundImage=http://img.1ppt.com/uploads/allimg/1805/1_180523223723_7.JPG&amp;up_numFish=6&amp;up_fishName=Fish&amp;up_fishColor2=F45540&amp;up_fishColor8=F45540&amp;up_backgroundColor=F0F7FF&amp;" width="200" height="375"&gt;&lt;param name="movie" value="https://cdn.abowman.com/widgets/fish/fish.swf?up_fishColor1=F45540&amp;up_fishColor4=0D0C0C&amp;up_fishColor9=F45540&amp;up_fishColor6=F45540&amp;up_fishColor5=F45540&amp;up_fishColor10=F45540&amp;up_foodColor=FCB347&amp;up_fishColor3=080707&amp;up_fishColor7=F45540&amp;up_backgroundImage=http://img.1ppt.com/uploads/allimg/1805/1_180523223723_7.JPG&amp;up_numFish=6&amp;up_fishName=Fish&amp;up_fishColor2=F45540&amp;up_fishColor8=F45540&amp;up_backgroundColor=F0F7FF&amp;"&gt;&lt;/param&gt;&lt;param name="AllowScriptAccess" value="always"&gt;&lt;/param&gt;&lt;param name="wmode" value="opaque"&gt;&lt;/param&gt;&lt;param name="scale" value="noscale"/&gt;&lt;param name="salign" value="tl"/&gt;&lt;/object&gt;&lt;/div&gt;有跨域什么的问题，好像！把引用的资源放，主题的js目录下！像上面那样直接js/fish.swf 进行引用就能避免了，背景图片同理，因为背景图片引用用的是http协议，也是有跨域问题的！你可以同理放到images的目录下/images/fish.png。]]></content>
      <categories>
        <category>小玩具</category>
      </categories>
      <tags>
        <tag>突发奇想</tag>
        <tag>小玩具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发编程-多线程之间通讯与线程池]]></title>
    <url>%2F2019%2F06%2F17%2F%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E9%80%9A%E8%AE%AF%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[wait与notify抛出问题说明需求:第一个线程写入(input)用户，另一个线程取读取(out)用户.实现读一个，写一个操作。先来看看反面例子一123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Res &#123; public String userName; public String sex;&#125;class InputThread extends Thread &#123; private Res res; public InputThread(Res res) &#123; this.res = res; &#125; @Override public void run() &#123; int count = 0; while (true) &#123; if (count == 0) &#123; res.userName = "小李"; res.sex = "男"; &#125; else &#123; res.userName = "小红"; res.sex = "女"; &#125; count = (count + 1) % 2; // 结果为0 1 0 1循环往复 &#125; &#125;&#125;class OutThrad extends Thread &#123; private Res res; public OutThrad(Res res) &#123; this.res = res; &#125; @Override public void run() &#123; while (true) &#123; // synchronized (res) &#123; System.out.println(res.userName + "," + res.sex); // &#125; &#125; &#125;&#125;public class ThreadDemo &#123; public static void main(String[] args) &#123; Res res = new Res(); InputThread inputThread = new InputThread(res); OutThrad outThrad = new OutThrad(res); inputThread.start(); outThrad.start(); &#125;&#125;输出：男女错位了，造成了线程安全问题。还有synchronized 关键字可以解决线程安全的问题的，加上它。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Res &#123; public String userName; public String sex;&#125;class InputThread extends Thread &#123; private Res res; public InputThread(Res res) &#123; this.res = res; &#125; @Override public void run() &#123; int count = 0; while (true) &#123; synchronized (res) &#123; if (count == 0) &#123; res.userName = "余胜军"; res.sex = "男"; &#125; else &#123; res.userName = "小红"; res.sex = "女"; &#125; count = (count + 1) % 2; &#125; &#125; &#125;&#125;class OutThrad extends Thread &#123; private Res res; public OutThrad(Res res) &#123; this.res = res; &#125; @Override public void run() &#123; while (true) &#123; synchronized (res) &#123; System.out.println(res.userName + "," + res.sex); &#125; &#125; &#125;&#125;public class ThreadDemo01 &#123; public static void main(String[] args) &#123; Res res = new Res(); InputThread inputThread = new InputThread(res); OutThrad outThrad = new OutThrad(res); inputThread.start(); outThrad.start(); &#125;&#125;直接出现了一大堆，和题意不符合！并不是生产一个消费一个的。因为涉及到对象锁,他们必须都放在synchronized中来使用. Wait、Notify一定要在synchronized里面进行使用。Wait必须暂定当前正在执行的线程,并释放资源锁,让其他线程可以有机会运行notify/notifyall: 唤醒因锁池中的线程,使之运行注意:一定要在线程同步中使用,并且是同一个锁的资源，加上wait与notify后，稍加改造。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879class Res &#123; public String userSex; public String userName; //线程通讯标识 public boolean flag = false;&#125;class IntThrad extends Thread &#123; private Res res; public IntThrad(Res res) &#123; this.res = res; &#125; @Override public void run() &#123; int count = 0; while (true) &#123; synchronized (res) &#123; if (res.flag) &#123; try &#123; // 当前线程变为等待 res.wait(); &#125; catch (Exception e) &#123; &#125; &#125; if (count == 0) &#123; res.userName = "小李"; res.userSex = "男"; &#125; else &#123; res.userName = "小紅"; res.userSex = "女"; &#125; count = (count + 1) % 2; res.flag = true; // 唤醒等待的线程 res.notify(); &#125; &#125; &#125;&#125;class OutThread extends Thread &#123; private Res res; public OutThread(Res res) &#123; this.res = res; &#125; @Override public void run() &#123; while (true) &#123; synchronized (res) &#123; if (!res.flag) &#123; try &#123; res.wait(); &#125; catch (Exception e) &#123; &#125; &#125; System.out.println(res.userName + "--" + res.userSex); res.flag = false; res.notify(); &#125; &#125; &#125;&#125;public class ThreaCommun &#123; public static void main(String[] args) &#123; Res res = new Res(); IntThrad intThrad = new IntThrad(res); OutThread outThread = new OutThread(res); intThrad.start(); outThread.start(); &#125;&#125;符合要求正好是生产一个消费一个，也没有线程的安全问题。wait与sleep的区别对于sleep()方法，我们首先要知道该方法是属于Thread类中的。而wait()方法，则是属于Object类中的。sleep()方法导致了程序暂停执行指定的时间，让出cpu给其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。在调用sleep()方法的过程中，线程不会释放对象锁。而当调用wait()方法的时候，线程会释放锁锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备获取对象锁进入运行状态。线程池​ 先说说阻塞队列与非阻塞队列。阻塞队列与非阻塞队列ConcurrentLinkedDeque是一个适用于高并发场景下的队列，通过无锁的方式，实现了高并发状态下的高性能，通常ConcurrentLinkedQueue性能好于BlockingQueue.它是一个基于链接节点的无界线程安全队列。该队列的元素遵循先进先出的原则。头是最先加入的，尾是最近加入的，该队列不允许null元素。ConcurrentLinkedQueue重要方法:add 和offer() 都是加入元素的方法(在ConcurrentLinkedQueue中这俩个方法没有任何区别)poll() 和peek() 都是取头元素节点，区别在于前者会删除元素，后者不会。BlockingQueue在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。BlockingQueue即阻塞队列，从阻塞这个词可以看出，在某些情况下对阻塞队列的访问可能会造成阻塞。被阻塞的情况主要有如下两种：当队列满了的时候进行入队列操作当队列空了的时候进行出队列操作因此，当一个线程试图对一个已经满了的队列进行入队列操作时，它将会被阻塞，除非有另一个线程做了出队列操作；同样，当一个线程试图对一个空队列进行出队列操作时，它将会被阻塞，除非有另一个线程进行了入队列操作。队列很重要，是线程池中的核心，阻塞线程模拟一下生产者与消费者：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384class ProducerThread implements Runnable &#123; private BlockingQueue&lt;String&gt; blockingQueue; private AtomicInteger count = new AtomicInteger(); private volatile boolean FLAG = true; public ProducerThread(BlockingQueue&lt;String&gt; blockingQueue) &#123; this.blockingQueue = blockingQueue; &#125; @Override public void run() &#123; System.out.println(Thread.currentThread().getName() + "生产者开始启动...."); while (FLAG) &#123; String data = count.incrementAndGet() + ""; try &#123; boolean offer = blockingQueue.offer(data, 2, TimeUnit.SECONDS); if (offer) &#123; System.out.println(Thread.currentThread().getName() + ",生产队列" + data + "成功.."); &#125; else &#123; System.out.println(Thread.currentThread().getName() + ",生产队列" + data + "失败.."); &#125; Thread.sleep(1000); &#125; catch (Exception e) &#123; &#125; &#125; System.out.println(Thread.currentThread().getName() + ",生产者线程停止..."); &#125; public void stop() &#123; this.FLAG = false; &#125;&#125;class ConsumerThread implements Runnable &#123; private volatile boolean FLAG = true; private BlockingQueue&lt;String&gt; blockingQueue; public ConsumerThread(BlockingQueue&lt;String&gt; blockingQueue) &#123; this.blockingQueue = blockingQueue; &#125; @Override public void run() &#123; System.out.println(Thread.currentThread().getName() + "消费者开始启动...."); while (FLAG) &#123; try &#123; String data = blockingQueue.poll(2, TimeUnit.SECONDS); if (data == null || data == "") &#123; FLAG = false; System.out.println("消费者超过2秒时间未获取到消息."); return; &#125; System.out.println("消费者获取到队列信息成功,data:" + data); &#125; catch (Exception e) &#123; // TODO: handle exception &#125; &#125; &#125;&#125;public class Test0008 &#123; public static void main(String[] args) &#123; BlockingQueue&lt;String&gt; blockingQueue = new LinkedBlockingQueue&lt;&gt;(3); ProducerThread producerThread = new ProducerThread(blockingQueue); ConsumerThread consumerThread = new ConsumerThread(blockingQueue); Thread t1 = new Thread(producerThread); Thread t2 = new Thread(consumerThread); t1.start(); t2.start(); //10秒后 停止线程.. try &#123; Thread.sleep(10*1000); producerThread.stop(); &#125; catch (Exception e) &#123; // TODO: handle exception &#125; &#125;&#125;什么是线程池以及作用降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。线程池的分类newCachedThreadPool ，创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。12345678910111213141516// 无限大小线程池 jvm自动回收 ExecutorService newCachedThreadPool = Executors.newCachedThreadPool(); for (int i = 0; i &lt; 10; i++) &#123; final int temp = i; newCachedThreadPool.execute(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(100); &#125; catch (Exception e) &#123; // TODO: handle exception &#125; System.out.println(Thread.currentThread().getName() + ",i:" + temp); &#125; &#125;); &#125;newFixedThreadPool，创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待123456789101112ExecutorService newFixedThreadPool = Executors.newFixedThreadPool(5); for (int i = 0; i &lt; 10; i++) &#123; final int temp = i; newFixedThreadPool.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getId() + ",i:" + temp); &#125; &#125;); &#125;newScheduledThreadPool，创建一个定长线程池，支持定时及周期性任务执行。123456789ScheduledExecutorService newScheduledThreadPool = Executors.newScheduledThreadPool(5); for (int i = 0; i &lt; 10; i++) &#123; final int temp = i; newScheduledThreadPool.schedule(new Runnable() &#123; public void run() &#123; System.out.println("i:" + temp); &#125; &#125;, 3, TimeUnit.SECONDS);&#125;newSingleThreadExecutor，创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。12345678910111213141516ExecutorService newSingleThreadExecutor = Executors.newSingleThreadExecutor(); for (int i = 0; i &lt; 10; i++) &#123; final int index = i; newSingleThreadExecutor.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println("index:" + index); try &#123; Thread.sleep(200); &#125; catch (Exception e) &#123; // TODO: handle exception &#125; &#125; &#125;); &#125;四种创建方式的根由​ Executor框架的最顶层实现是ThreadPoolExecutor类，Executors工厂类中提供的newScheduledThreadPool、newFixedThreadPool、newCachedThreadPool方法其实也只是ThreadPoolExecutor的构造函数参数不同而已。通过传入不同的参数，就可以构造出适用于不同应用场景下的线程池。例如 newCachedThreadPool 线程池的创建方式的内部。在此基础上自定义一个线程池.12345678910111213141516171819202122232425public class Test0007 &#123; public static void main(String[] args) &#123; ThreadPoolExecutor executor = new ThreadPoolExecutor(1, 2, 60L, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(3)); for (int i = 1; i &lt;= 6; i++) &#123; TaskThred t1 = new TaskThred("任务" + i); executor.execute(t1); &#125; executor.shutdown(); &#125;&#125;class TaskThred implements Runnable &#123; private String taskName; public TaskThred(String taskName) &#123; this.taskName = taskName; &#125; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()+taskName); &#125;&#125;​ 对构造函数的四个参数解释一下，1 核心线程数 2 最大线程数 3 存活时间（线程闲置后存活的时间）4 时间单位 5 阻塞队列（核心线程数非闲置状态下，线程的存放队列）。对于上面代码的配置中，是可以执行5个线程的，再多是会报错的。根据线程池的原理解析：核心线程执行一个线程，阻塞队列中存放三个，最大线程数减去核心线程数为一，还再可以创建一个线程。所以一共是五个线程，非核心线程创建后，是可以反过来一块执行阻塞队列中的其他线程。线程池的原理​ 判断线程池里的核心线程是否都在执行任务，如果不是（核心线程空闲或者还有核心线程没有被创建）则创建一个新的工作线程来执行任务。如果核心线程都在执行任务，则进入下个流程。线程池判断工作队列是否已满，如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。判断线程池里的线程是否都处于工作状态，如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。CPU密集与IO密集cpu密集​ CPU密集的意思是该任务需要大量的运算，而没有阻塞，CPU一直全速运行。 CPU密集任务只有在真正的多核CPU上才可能得到加速(通过多线程)，而在单核CPU上，无论你开几个模拟的多线程，该任务都不可能得到加速，因为CPU总的运算能力就那些。io密集​ IO密集型，即该任务需要大量的IO，即大量的阻塞。在单线程上运行IO密集型的任务会导致浪费大量的CPU运算能力浪费在等待。所以在IO密集型任务中使用多线程可以大大的加速程序运行，即时在单核CPU上，这种加速主要就是利用了被浪费掉的阻塞时间。两种密集类型下，线程如何配​ CPU密集型时，任务可以少配置线程数，大概和机器的cpu核数相当，这样可以使得每个线程都在执行任务。​ IO密集型时，大部分线程都阻塞，故需要多配置线程数，2*cpu核数。]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>线程池</tag>
        <tag>线程间通讯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发编程-java内存模型]]></title>
    <url>%2F2019%2F06%2F13%2F%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[线程安全​ 当多个线程同时共享，同一个全局变量或静态变量，做写的操作时，可能会发生数据冲突问题，也就是线程安全问题。但是做读操作是不会发生数据冲突问题。最经典的买票的问题：1234567891011121314151617181920212223242526272829303132public class Ticket implements Runnable &#123; int total = 100; @Override public void run() &#123; while (total &gt; 0) &#123; try &#123; Thread.sleep(5); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; sale(); &#125; &#125; private synchronized void sale() &#123; // 不加synchronized，就会有一张票多次被卖的问题 if (total &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + ",出售第" + (100 - total + 1) + "张票"); total--; &#125; &#125; public static void main(String[] args) &#123; Ticket T = new Ticket(); Thread thread1 = new Thread(T,"one"); Thread thread2 = new Thread(T,"two"); Thread thread3 = new Thread(T,"there"); thread1.start(); thread2.start(); thread3.start(); &#125;&#125;synchronized关键字内置锁使用synchronized关键字实现，synchronized关键字有两种用法：修饰需要进行同步的方法（所有访问状态变量的方法都必须进行同步），此时充当锁的对象为调用同步方法的对象(默认this)同步代码块和直接使用synchronized修饰需要同步的方法是一样的，但是锁的粒度可以更细，并且充当锁的对象不一定是this，也可以是其它对象，所以使用起来更加灵活12345678synchronized(同一个数据)&#123; 可能会发生线程冲突问题&#125;就是同步代码块 synchronized(对象) //这个对象可以为任意对象 &#123; 需要被同步的代码 &#125;同步的前提：必须要有两个或者两个以上的线程必须是多个线程使用同一个锁必须保证同步中只能有一个线程在运行好处：解决了多线程的安全问题弊端：多个线程需要判断锁，较为消耗资源、抢锁的资源。同步方法123456public synchronized void sale() &#123; if (trainCount &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + ",出售第" + (100 - trainCount + 1) + "张票"); trainCount--; &#125; &#125;静态同步函数方法上加上static关键字，使用synchronized 关键字修饰 或者使用类.class文件。静态的同步函数使用的锁是 该函数所属字节码文件对象，可以用 getClass方法获取，也可以用当前 类名.class 表示。12345678public static void sale() &#123; synchronized (ThreadTrain3.class) &#123; if (trainCount &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + ",出售第" + (100 - trainCount + 1) + "张票"); trainCount--; &#125; &#125;&#125;tipsynchronized 修饰方法使用锁是当前this锁。synchronized 修饰静态方法使用锁是当前类的字节码文件。线程死锁​ 同步中嵌套同步,导致锁无法释放1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class Deadlock implements Runnable &#123; private int trainCount = 100; private Object oj = new Object(); public boolean flag = true; public void run() &#123; if (flag) &#123; while (trainCount &gt; 0) &#123; synchronized (oj) &#123; try &#123; Thread.sleep(10); &#125; catch (Exception e) &#123; // TODO: handle exception &#125; sale(); &#125; &#125; &#125; else &#123; while (trainCount &gt; 0) &#123; sale(); &#125; &#125; &#125; public synchronized void sale() &#123; synchronized (oj) &#123; try &#123; Thread.sleep(10); &#125; catch (Exception e) &#123; &#125; if (trainCount &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + "," + "出售第" + (100 - trainCount + 1) + "票"); trainCount--; &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; Deadlock threadTrain = new Deadlock(); Thread t1 = new Thread(threadTrain, "窗口1"); Thread t2 = new Thread(threadTrain, "窗口2"); t1.start(); Thread.sleep(40); threadTrain.flag = false; t2.start(); &#125;&#125;Threadlocal​ 当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。ThreadLocal的接口方法ThreadLocal类接口很简单，只有4个方法：void set(Object value)设置当前线程的线程局部变量的值。public Object get()该方法返回当前线程所对应的线程局部变量。public void remove()将当前线程局部变量的值删除，目的是为了减少内存的占用，该方法是JDK 5.0新增的方法。需要指出的是，当线程结束后，对应该线程的局部变量将自动被垃圾回收，所以显式调用该方法清除线程的局部变量并不是必须的操作，但它可以加快内存回收的速度。protected Object initialValue()返回该线程局部变量的初始值，该方法是一个protected的方法，显然是为了让子类覆盖而设计的。这个方法是一个延迟调用方法，在线程第1次调用get()或set(Object)时才执行，并且仅执行1次。ThreadLocal中的缺省实现直接返回一个null。demo创建三个线程，每个线程生成自己独立序列号12345678910111213141516171819202122232425262728293031323334353637383940class Res &#123; // 生成序列号共享变量 public static Integer count = 0; public static ThreadLocal&lt;Integer&gt; threadLocal = new ThreadLocal&lt;Integer&gt;() &#123; protected Integer initialValue() &#123; return 0; &#125; &#125;; public Integer getNum() &#123; int count = threadLocal.get() + 1; threadLocal.set(count); return count; &#125;&#125;public class ThreadlocalTest extends Thread &#123; private Res res; public ThreadlocalTest(Res res) &#123; this.res = res; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 3; i++) &#123; System.out.println(Thread.currentThread().getName() + "---" + "i---" + i + "--num:" + res.getNum()); &#125; &#125; public static void main(String[] args) &#123; Res res = new Res(); ThreadlocalTest threadLocaDemo1 = new ThreadlocalTest(res); ThreadlocalTest threadLocaDemo2 = new ThreadlocalTest(res); ThreadlocalTest threadLocaDemo3 = new ThreadlocalTest(res); threadLocaDemo1.start(); threadLocaDemo2.start(); threadLocaDemo3.start(); &#125;&#125;ThreadLoca实现原理ThreadLoca 通过map集合。Map.put(“当前线程”,值)；线程的三大特性原子性即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。一个很经典的例子就是银行账户转账问题：比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。这2个操作必须要具备原子性才能保证不出现一些意外的问题。我们操作数据也是如此，比如i = i+1；其中就包括，读取i的值，计算i，写入i。这行代码在Java中是不具备原子性的，则多线程运行肯定会出问题，所以也需要我们使用同步和lock这些东西来确保这个特性了。 原子性其实就是保证数据一致、线程安全一部分，可见性当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。若两个线程在不同的cpu，那么线程1改变了i的值还没刷新到主内存，线程2又使用了i，那么这个i值肯定还是之前的，线程1对变量的修改而线程2没看到，这就是可见性问题。有序性程序执行的顺序按照代码的先后顺序执行。一般来说处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。如下：1234int a = 10; //语句1int r = 2; //语句2a = a + 3; //语句3r = a*a; //语句4则因为重排序，他还可能执行顺序为 2-1-3-4，1-3-2-4 但绝不可能 2-1-4-3，因为这打破了依赖关系。 显然重排序对单线程运行是不会有任何问题，而多线程就不一定了，所以我们在多线程编程时就得考虑这个问题了。java内存模型​ 共享内存模型指的就是Java内存模型(简称JMM)，JMM 决定一个线程对共享变量的写入时,能对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。从上图来看，线程A与线程B之间如要通信的话，必须要经历下面2个步骤：首先，线程A把本地内存A中更新过的共享变量刷新到主内存中去。然后，线程B到主内存中去读取线程A之前已更新过的共享变量。下面通过示意图来说明这两个步骤：如上图所示，本地内存A和B有主内存中共享变量x的副本。假设初始时，这三个内存中的x值都为0。线程A在执行时，把更新后的x值（假设值为1）临时存放在自己的本地内存A中。当线程A和线程B需要通信时，线程A首先会把自己本地内存中修改后的x值刷新到主内存中，此时主内存中的x值变为了1。随后，线程B到主内存中去读取线程A更新后的x值，此时线程B的本地内存的x值也变为了1。从整体来看，这两个步骤实质上是线程A在向线程B发送消息，而且这个通信过程必须要经过主内存。JMM通过控制主内存与每个线程的本地内存之间的交互，来为java程序员提供内存可见性保证。总结：什么是Java内存模型：java内存模型简称jmm，定义了一个线程对另一个线程可见。共享变量存放在主内存中，每个线程都有自己的本地内存，当多个线程同时访问一个数据的时候，可能本地内存没有及时刷新到主内存，所以就会发生线程安全问题。Volatile关键字​ 可见性也就是说一旦某个线程修改了该被volatile修饰的变量，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，可以立即获取修改之后的值。在Java中为了加快程序的运行效率，对一些变量的操作通常是在该线程的寄存器或是CPU缓存上进行的，之后才会同步到主存中，而加了volatile修饰符的变量则是直接读写主存。Volatile 保证了线程间共享变量的及时可见性，但不能保证原子性1234567891011121314151617181920212223242526class ThreadVolatileDemo extends Thread &#123; public volatile boolean flag = true; // 一个线程给设置为false后，另一个线程会可见的 @Override public void run() &#123; System.out.println("开始执行子线程...."); while (flag) &#123; &#125; System.out.println("线程停止"); &#125; public void setRuning(boolean flag) &#123; this.flag = flag; &#125;&#125;public class ThreadVolatile &#123; public static void main(String[] args) throws InterruptedException &#123; ThreadVolatileDemo threadVolatileDemo = new ThreadVolatileDemo(); threadVolatileDemo.start(); Thread.sleep(3000); threadVolatileDemo.setRuning(false); System.out.println("flag 已经设置成false"); Thread.sleep(1000); System.out.println(threadVolatileDemo.flag); &#125;&#125;特性保证此变量对所有的线程的可见性，这里的“可见性”，如本文开头所述，当一个线程修改了这个变量的值，volatile 保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。但普通变量做不到这点，普通变量的值在线程间传递均需要通过主内存（详见：Java内存模型）来完成。禁止指令重排序优化。(就是编译器自己优化代码顺序，结果保持不变)有volatile修饰的变量，赋值后多执行了一个“load addl $0x0, (%esp)”操作，这个操作相当于一个内存屏障（指令重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个CPU访问内存时，并不需要内存屏障；（什么是指令重排序：是指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理）。volatile 性能：volatile 的读性能消耗与普通变量几乎相同，但是写操作稍慢，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。volatile与synchronized区别从而我们可以看出volatile虽然具有可见性但是并不能保证原子性。性能方面，synchronized关键字是防止多个线程同时执行一段代码，就会影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized。但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。（单独使用 volatile 还不足以实现计数器），volatile变量不会像锁那样造成线程阻塞，（同步方法一次只能一个线程访问）因此也很少造成可伸缩性问题。在某些情况下，如果读操作远远大于写操作，volatile变量还可以提供优于锁的性能优势。]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>java内存模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发编程-多线程基础]]></title>
    <url>%2F2019%2F06%2F11%2F%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[进程与线程的区别​ 进程是所有线程的集合，每一个线程是进程中的一条执行路径。进程与线程包含与被包含的关系，一个进程里会有多个线程。创建线程的集中方式继承Thread类12345678910111213141516171819202122232425262728class Thread02 extends Thread&#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; Thread.sleep(300); // 设置延时交替执行，效果比较清楚 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("子线程："+i); &#125; &#125;&#125;public class Thread01 &#123; public static void main(String[] args) &#123; Thread02 thread02 = new Thread02(); thread02.start(); for (int i = 0; i &lt; 10; i++) &#123; try &#123; Thread.sleep(300); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("主线程："+i); &#125; &#125;&#125;实现Runnable接口12345678910111213141516171819202122232425262728class Thread04 implements Runnable &#123; public void run() &#123; for (int i = 0; i &lt; 11; i++) &#123; try &#123; Thread.sleep(300); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("子线程：" + i); &#125; &#125;&#125;public class Thread03 &#123; public static void main(String[] args) &#123; Thread04 thread04 = new Thread04(); Thread thread = new Thread(thread04); thread.start(); for (int i = 0; i &lt; 11; i++) &#123; try &#123; Thread.sleep(300); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("主线程：" + i); &#125; &#125;&#125;匿名内部类123456789public class Thread05 &#123; public static void main(String[] args) &#123; new Thread(()-&gt; &#123; // lambda表达式，新特性还是要找机会使用一下的，要不又忘了 for(int i = 1 ; i&lt;100 ; i++)&#123; System.out.println("It is a lambda function!"); &#125; &#125;); &#125;&#125;线程池与Callable、Future留待后面进行补充，此处先留白。接口和继承当然选择接口了，毕竟 java 不支持多继承。线程分类​ Java中有两种线程，一种是用户线程，另一种是守护线程。用户线程是指用户自定义创建的线程，主线程停止，用户线程不会停止。守护线程当进程不存在或主线程停止，守护线程也会被停止。使用 setDaemon(true) 方法设置为守护线程。12345678910111213141516171819202122232425262728public class DaemonThread &#123; public static void main(String[] args) &#123; Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; while (true) &#123; try &#123; Thread.sleep(100); &#125; catch (Exception e) &#123; // TODO: handle exception &#125; System.out.println("我是子线程..."); &#125; &#125; &#125;); thread.setDaemon(true); thread.start(); for (int i = 0; i &lt; 10; i++) &#123; try &#123; Thread.sleep(100); &#125; catch (Exception e) &#123; &#125; System.out.println("我是主线程"); &#125; System.out.println("主线程执行完毕!"); &#125;&#125;线程状态新建状态当用new操作符创建一个线程时， 例如new Thread(r)，线程还没有开始运行，此时线程处在新建状态。 当一个线程处于新生状态时，程序还没有开始运行线程中的代码就绪状态​ 一个新创建的线程并不自动开始运行，要执行线程，必须调用线程的start()方法。当线程对象调用start()方法即启动了线程，start()方法创建线程运行的系统资源，并调度线程运行run()方法。当start()方法返回后，线程就处于就绪状态。​ 处于就绪状态的线程并不一定立即运行run()方法，线程还必须同其他线程竞争CPU时间，只有获得CPU时间才可以运行线程。因为在单CPU的计算机系统中，不可能同时运行多个线程，一个时刻仅有一个线程处于运行状态。因此此时可能有多个线程处于就绪状态。对多个处于就绪状态的线程是由Java运行时系统的线程调度程序(thread scheduler)来调度的。运行状态​ 当线程获得CPU时间后，它才进入运行状态，真正开始执行run()方法.阻塞状态​ 线程运行过程中，可能由于各种原因进入阻塞状态:​ 1.线程通过调用sleep方法进入睡眠状态；2.线程调用一个在I/O上被阻塞的操作，即该操作在输入输出操作完成之前不会返回到它的调用者； 3.线程试图得到一个锁，而该锁正被其他线程持有； 4.线程在等待某个触发条件； 死亡状态有两个原因会导致线程死亡：run方法正常退出而自然死亡。一个未捕获的异常终止了run方法而使线程猝死。为了确定线程在当前是否存活着（就是要么是可运行的，要么是被阻塞了），需要使用isAlive方法。如果是可运行或被阻塞，这个方法返回true； 如果线程仍旧是new状态且不是可运行的， 或者线程死亡了，则返回false.join()的使用当在主线程当中执行到 t1.join() 方法时，就认为主线程应该把执行权让给t1。123456789101112131415161718192021222324252627282930public static void main(String[] args) &#123; Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; Thread.sleep(10); &#125; catch (Exception e) &#123; &#125; System.out.println(Thread.currentThread().getName() + "i:" + i); &#125; &#125; &#125;); t1.start(); // 当在主线程当中执行到t1.join()方法时，就认为主线程应该把执行权让给t1 try &#123; t1.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; for (int i = 0; i &lt; 10; i++) &#123; try &#123; Thread.sleep(10); &#125; catch (Exception e) &#123; &#125; System.out.println("main" + "i:" + i); &#125; &#125;线程优先级​ 在JAVA线程中，通过一个int priority来控制优先级，范围为1-10，其中10最高，默认值为5。下面是源码（基于1.8）中关于priority的一些量和方法。12345678910111213141516171819class PrioritytThread implements Runnable &#123; public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(Thread.currentThread().toString() + "---i:" + i); &#125; &#125;&#125;public class ThreadDemo4 &#123; public static void main(String[] args) &#123; PrioritytThread prioritytThread = new PrioritytThread(); Thread t1 = new Thread(prioritytThread); Thread t2 = new Thread(prioritytThread); t1.start(); // 注意设置了优先级， 不代表每次都一定会被执行。 只是CPU调度会有限分配 t1.setPriority(10); t2.start(); &#125;&#125;Yield方法Thread.yield()方法的作用：暂停当前正在执行的线程，并执行其他线程。（可能没有效果）yield()让当前正在运行的线程回到可运行状态，以允许具有相同优先级的其他线程获得运行的机会。因此，使用yield()的目的是让具有相同优先级的线程之间能够适当的轮换执行。但是，实际中无法保证yield()达到让步的目的，因为，让步的线程可能被线程调度程序再次选中。结论：大多数情况下，yield()将导致线程从运行状态转到可运行状态，但有可能没有效果。线程执行顺序现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行 。本质上就是在T2里让T1.jion()，在 T3 里T2.join()。1234567891011121314151617181920212223242526272829303132333435363738public class JoinThreadDemo02 &#123; public static void main(String[] args) &#123; Thread t1 = new Thread(new Runnable() &#123; public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; System.out.println("t1,i:" + i); &#125; &#125; &#125;); Thread t2 = new Thread(new Runnable() &#123; public void run() &#123; try &#123; t1.join(); &#125; catch (Exception e) &#123; // TODO: handle exception &#125; for (int i = 0; i &lt; 20; i++) &#123; System.out.println("t2,i:" + i); &#125; &#125; &#125;); Thread t3 = new Thread(new Runnable() &#123; public void run() &#123; try &#123; t2.join(); &#125; catch (Exception e) &#123; // TODO: handle exception &#125; for (int i = 0; i &lt; 20; i++) &#123; System.out.println("t3,i:" + i); &#125; &#125; &#125;); t1.start(); t2.start(); t3.start(); &#125;&#125;]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用nginx+tomcat实现动静分离]]></title>
    <url>%2F2019%2F06%2F10%2F%E4%BD%BF%E7%94%A8nginx-tomcat%E5%AE%9E%E7%8E%B0%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[动态资源与静态资源的区别微微的概括一下静态资源： 当用户多次访问这个资源，资源的源代码永远不会改变的资源。动态资源：当用户多次访问这个资源，资源的源代码可能会发送改变。什么是动静分离动静分离是让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作，这就是网站静态化处理的核心思路。为什么要用动静分离在我们的软件开发中，有些请求是需要后台处理的（如：.jsp,.do等等），有些请求是不需要经过后台处理的（如：css、html、jpg、js等等文件），这些不需要经过后台处理的文件称为静态文件，否则动态文件。因此我们后台处理忽略静态文件。这会有人又说那我后台忽略静态文件不就完了吗。当然这是可以的，但是这样后台的请求次数就明显增多了。在我们对资源的响应速度有要求的时候，我们应该使用这种动静分离的策略去解决。动静分离将网站静态资源（HTML，JavaScript，css，img等文件）与后台应用分开部署，提高用户访问静态代码的速度，降低对后台应用访问。这里我们将静态资源放到nginx中，动态资源转发到tomcat服务器中。因此，动态资源转发到tomcat服务器我们就使用到了前面讲到的反向代理了。在nginx中的配置12345678910111213141516171819###静态资源访问 server &#123; listen 80; server_name static.itmayiedu.com; location /static/imgs &#123; root D:/; #会直接匹配D:下的static/imgs目录的 D:/static/imgs index index.html index.htm; &#125; &#125; ###动态资源访问server &#123; listen 80; server_name www.kingstone.com; // 去hosts文件中配置 location / &#123; proxy_pass http://127.0.0.1:8080; index index.html index.htm; &#125; &#125;tip图片这种静态资源，再次访问的话，会出现304状态码。这不是一种错误，而是对客户端有缓存情况下服务端的一种响应。不明觉厉的解释：1234567客户端在请求一个文件的时候，发现自己缓存的文件有 Last Modified ，那么在请求中会包含 If Modified Since ，这个时间就是缓存文件的 Last Modified 。因此，如果请求中包含 If Modified Since，就说明已经有缓存在客户端。服务端只要判断这个时间和当前请求的文件的修改时间就可以确定是返回 304 还是 200 。对于静态文件，例如：CSS、图片，服务器会自动完成 LastModified 和 If Modified Since 的比较，完成缓存或者更新。但是对于动态页面，就是动态产生的页面，往往没有包含 Last Modified 信息，这样浏览器、网关等都不会做缓存，也就是在每次请求的时候都完成一个 200 的请求。因此，对于动态页面做缓存加速，首先要在 Response 的HTTP Header 中增加 Last Modified 定义，其次根据 Request 中的 If Modified Since 和被请求内容的更新时间来返回 200 或者 304 。虽然在返回304 的时候已经做了一次数据库查询，但是可以避免接下来更多的数据库查询，并且没有返回页面内容而只是一个HTTP Header，从而大大的降低带宽的消耗，对于用户的感觉也是提高]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>配置</tag>
        <tag>部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[excel的像素画]]></title>
    <url>%2F2019%2F06%2F08%2Fexcel%E7%9A%84%E5%83%8F%E7%B4%A0%E7%94%BB%2F</url>
    <content type="text"><![CDATA[缘由豆瓣上看的在excel上画像素画，之前工作中用到了excel的解析，那时候这一个小需求写了好久。大约两个星期吧！还被带我的小哥嘲讽了一下，不过确实对excel的解析熟悉了不少（也就是poi的使用……），之前工作的那个解析也是可以写写的，这次就说像素画，不扯其他的。进入正题原理​ 原理就是把图片的每个像素点遍历一下，拿到每个像素的内容，然后设置excel的单元格的合适大小，给每个excel的单元格一一设置背景色。（也不算全部遍历，这是在遍历的时候需要跳跃一下）代码​ 虽然是一个简单的小玩意，使用maven还是方便一些的，依赖如下：123456789101112131415&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;3.9&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;3.9&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml-schemas&lt;/artifactId&gt; &lt;version&gt;3.9&lt;/version&gt;&lt;/dependency&gt;正式代码​ 应豆瓣友邻的要求写一个教程，就把注释写的详细一点1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class ToExcel &#123; public static void load(String picPath) throws Exception&#123; List&lt;Integer&gt; list=new ArrayList&lt;Integer&gt;(); // 用来存图片的像素信息 BufferedImage pic = ImageIO.read(new File(picPath)); int height = pic.getHeight(); // 获得图片的高 int width = pic.getWidth(); // 获得图片的宽 int index=0; // 计数，真实的excel的行数 for(int i=0;i&lt;height;i+=4)&#123; // 并非全部遍历，每次以四个像素对高在跳跃，建议你设置大一点 index++; for(int j=0;j&lt;width;j+=4)&#123; // 并非全部遍历，每次以四个像素对宽在跳跃，建议你设置大一点 int pixel = pic.getRGB(j, i); // 获得跳跃后的像素点 list.add(pixel); // 添加到list当中 &#125; &#125; genExce(list,index); &#125; public static void genExce(List&lt;Integer&gt; total,int heights)&#123; int widths=total.size()/heights; // 通过高度获得宽度 XSSFWorkbook excel = new XSSFWorkbook(); // 创建操作单元格的对象 XSSFSheet sheet = excel.createSheet("beauty"); // 设置excel的表的名称 //设置默认的行高和宽，对于每个单元格来说的 short width= (short) 2; short height= (short) (1.50875*256); sheet.setDefaultRowHeight(height); sheet.setDefaultColumnWidth(width); // 设置一个map用来存放颜色对象，避免过多的创建颜色对象，影响速度（但是创建的以然很多，有点慢） Map&lt;String,XSSFColor&gt; map=new HashMap&lt;String,XSSFColor&gt;(); for (int i = 0; i &lt;heights ; i++) &#123; XSSFRow row = sheet.createRow(i); for (int j = 0; j &lt;widths ; j++) &#123; if(j!=0&amp;&amp;j%widths==0)&#123; // 进行换行处理，要不怎么能成为一个图片 break; &#125; Integer pixel = total.get(i * widths + j); //拿到对应excel位置的图片的像素值 int red = (pixel &amp; 0xff0000) &gt;&gt; 16; // 三基色，红、绿、蓝，用于下面生成颜色 int green = (pixel &amp; 0xff00) &gt;&gt; 8; int blue = pixel &amp; 0xff; XSSFCell cell = row.createCell(j); // 在第i行中添加单元格第j个单元格 XSSFCellStyle style = excel.createCellStyle(); // 创建单元格样式 // 判断颜色存在于集合之中，存在直接拿出，不存在创建放入 if(!map.containsKey(red+"."+green+"."+blue))&#123; map.put(red+"."+green+"."+blue,new XSSFColor(new Color(red,green,blue))); &#125; // 统一在map中拿取颜色对象 style.setFillForegroundColor(map.get(red+"."+green+"."+blue)); //solid 填充 foreground 前景色 style.setFillPattern(HSSFCellStyle.SOLID_FOREGROUND); cell.setCellStyle(style); System.out.println(i * widths + j); // 运行时间有点长，给你个输出，不至于让你感觉程序卡死了..... &#125; &#125; FileOutputStream out = null; try &#123; out = new FileOutputStream("D:/old_color.xlsx"); excel.write(out); out.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; // 程序的入口 try &#123; load("D:/1.jpg"); // 读取图片地址 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;tip图片的大小别使用太大的，手机拍的照片最好在ps里缩小一下，然后再用，如果最后生成的excel打不开，将循环图片的那个间隔值设置大一些，12或者16长宽统一。程序的时间只要都耗费到了，生成颜色对象的那块。主要还是我太菜了，如果路过的大神有什么可以大幅度的提升运行时间的办法，可以留个言我试一下。运行效果太慢了，我就不贴出来了。相信来看的大部分都是豆瓣的观光团，效果你们都看过了。代码没什么实际意义，就是拿过来玩的。]]></content>
      <categories>
        <category>小玩具</category>
      </categories>
      <tags>
        <tag>突发奇想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx(二)]]></title>
    <url>%2F2019%2F06%2F07%2Fnginx-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[nginx rewrite​ Nginx提供的全局变量或自己设置的变量，结合正则表达式和标志位实现url重写以及重定向。rewrite只能放在server{},location{},if{}中，并且只能对域名后边的除去传递的参数外的字符串起作用。Rewrite主要的功能就是实现URL的重写，Nginx的Rewrite规则采用Pcre，perl兼容正则表达式的语法规则匹配，如果需要Nginx的Rewrite功能，在编译Nginx之前，需要编译安装PCRE库。通过Rewrite规则，可以实现规范的URL、根据变量来做URL转向及选择配置。Rewrite全局变量​ nginx的rewrite规则就是使用正则匹配请求的url，然后根据定义的规则进行重写和改变，需ngx_http_rewrite_module模块来支持url重写功能，该模块是标准模块，默认已经安装。变量含义$args这个变量等于请求行中的参数，同$query_string$content length请求头中的Content-length字段。$content_type请求头中的Content-Type字段。$document_root当前请求在root指令中指定的值。$host请求主机头字段，否则为服务器名称。$http_user_agent客户端agent信息$http_cookie客户端cookie信息$limit_rate这个变量可以限制连接速率。$request_method客户端请求的动作，通常为GET或POST。$remote_addr客户端的IP地址。$remote_port客户端的端口。$remote_user已经经过Auth Basic Module验证的用户名。$request_filename当前请求的文件路径，由root或alias指令与URI请求生成。$schemeHTTP方法（如http，https）。$server_protocol请求使用的协议，通常是HTTP/1.0或HTTP/1.1。$server_addr服务器地址，在完成一次系统调用后可以确定这个值。$server_name服务器名称。$server_port请求到达服务器的端口号。$request_uri包含请求参数的原始URI，不包含主机名，如”/foo/bar.php?arg=baz”。$uri不带请求参数的当前URI，$uri不包含主机名，如”/foo/bar.html”。$document_uri与$uri相同。实例demo判断IP地址来源1234## 如果访问的ip地址为192.168.5.165,则返回403 if ($remote_addr = 192.168.5.166) &#123; return 403; &#125;限制浏览器访问1234## 不允许谷歌浏览器访问 如果是谷歌浏览器返回500 if ($http_user_agent ~ Chrome) &#123; return 500; &#125;]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx(一)]]></title>
    <url>%2F2019%2F06%2F03%2Fnginx-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[localtion的语法已=开头表示精确匹配如 A 中只匹配根目录结尾的请求，后面不能带任何字符串。^~ 开头表示uri以某个常规字符串开头，不是正则匹配~ 开头表示区分大小写的正则匹配;~* 开头表示不区分大小写的正则匹配/ 通用匹配, 如果没有其它匹配,任何请求都会匹配到几个案例：123456789server &#123; listen 80; server_name www.itmayiedu.com; #精确匹配,/后面不能带任何字符 location =/ &#123; proxy_pass http://127.0.0.1:8080; index index.html index.htm; &#125;&#125;负载均衡的几种算法轮询机制权重IP绑定faiilurltip在nginx1.9之前nginx指支持七层负载均衡，应用层的负载均衡（所谓七层，物理层、数据链路层、网络层、传输层、会话层、表示层、应用层、）在1.9之后支持了四层传输协议也就是网络层的负载均衡。本质上时支持那个层的协议。负载均衡的配置123456789101112131415#上游服务器 upstream backServer&#123; server 127.0.0.1:8080; server 127.0.0.1:8081; &#125; server &#123; listen 80; server_name www.itmayiedu.com; location / &#123; ### 指定上游服务器负载均衡服务器 proxy_pass http://backServer; index index.html index.htm; &#125; &#125;带权重的配置1234567891011121314upstream backServer&#123; server 127.0.0.1:8080 weight=1; server 127.0.0.1:8081 weight=2; &#125; server &#123; listen 80; server_name www.itmayiedu.com; location / &#123; ### 指定上游服务器负载均衡服务器 proxy_pass http://backServer; index index.html index.htm; &#125; &#125;Ip绑定每个请求按访问IP的哈希结果分配，使来自同一个IP的访客固定访问一台后端服务器，并且可以有效解决动态网页存在的session共享问题。俗称IP绑定。123456789101112131415upstream backServer&#123; server 127.0.0.1:8080 ; server 127.0.0.1:8081 ; ip_hash; &#125; server &#123; listen 80; server_name www.itmayiedu.com; location / &#123; ### 指定上游服务器负载均衡服务器 proxy_pass http://backServer; index index.html index.htm; &#125; &#125;故障转移当上游服务器(真实访问服务器),一旦出现故障或者是没有及时相应的话，应该直接轮训到下一台服务器，保证服务器的高可用。123456789101112131415server &#123; listen 80; server_name www.itmayiedu.com; location / &#123; ### 指定上游服务器负载均衡服务器 proxy_pass http://backServer; ###nginx与上游服务器(真实访问的服务器)超时时间 后端服务器连接的超时时间_发起握手等候响应超时时间 proxy_connect_timeout 1s; ###nginx发送给上游服务器(真实访问的服务器)超时时间 proxy_send_timeout 1s; ### nginx接受上游服务器(真实访问的服务器)超时时间 proxy_read_timeout 1s; index index.html index.htm; &#125; &#125;]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[StringRedisTemplate的使用]]></title>
    <url>%2F2019%2F05%2F31%2FStringRedisTemplate%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[工具类废话不多说，直接上代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997998999100010011002100310041005100610071008100910101011101210131014101510161017101810191020102110221023102410251026102710281029103010311032103310341035103610371038103910401041104210431044104510461047104810491050105110521053105410551056105710581059106010611062106310641065106610671068106910701071107210731074107510761077107810791080108110821083108410851086108710881089109010911092109310941095109610971098109911001101110211031104110511061107110811091110111111121113111411151116111711181119112011211122112311241125112611271128112911301131113211331134113511361137113811391140114111421143114411451146114711481149115011511152115311541155115611571158115911601161116211631164116511661167116811691170117111721173117411751176117711781179118011811182118311841185118611871188118911901191119211931194119511961197119811991200120112021203120412051206120712081209121012111212121312141215121612171218121912201221122212231224122512261227122812291230123112321233123412351236123712381239124012411242124312441245124612471248124912501251125212531254125512561257125812591260126112621263126412651266126712681269127012711272127312741275127612771278127912801281128212831284128512861287128812891290129112921293129412951296129712981299130013011302130313041305130613071308130913101311131213131314131513161317131813191320132113221323132413251326132713281329133013311332133313341335133613371338133913401341134213431344134513461347134813491350135113521353135413551356135713581359136013611362136313641365136613671368package com.ddos.utils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.redis.connection.DataType;import org.springframework.data.redis.core.Cursor;import org.springframework.data.redis.core.ScanOptions;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.data.redis.core.ZSetOperations.TypedTuple;import org.springframework.stereotype.Component;import java.util.Collection;import java.util.Date;import java.util.List;import java.util.Map;import java.util.Map.Entry;import java.util.Set;import java.util.concurrent.TimeUnit;/** * Redis工具类 * * @author WangFan * @date 2018-02-24 下午03:09:50 * @version 1.1 (GitHub文档: https://github.com/whvcse/RedisUtil ) */@Componentpublic class RedisUtil &#123; @Autowired private StringRedisTemplate redisTemplate; public void setRedisTemplate(StringRedisTemplate redisTemplate) &#123; this.redisTemplate = redisTemplate; &#125; public StringRedisTemplate getRedisTemplate() &#123; return this.redisTemplate; &#125; /** -------------------key相关操作--------------------- */ /** * 删除key * * @param key */ public void delete(String key) &#123; redisTemplate.delete(key); &#125; /** * 批量删除key * * @param keys */ public void delete(Collection&lt;String&gt; keys) &#123; redisTemplate.delete(keys); &#125; /** * 序列化key * * @param key * @return */ public byte[] dump(String key) &#123; return redisTemplate.dump(key); &#125; /** * 是否存在key * * @param key * @return */ public Boolean hasKey(String key) &#123; return redisTemplate.hasKey(key); &#125; /** * 设置过期时间 * * @param key * @param timeout * @param unit * @return */ public Boolean expire(String key, long timeout, TimeUnit unit) &#123; return redisTemplate.expire(key, timeout, unit); &#125; /** * 设置过期时间 * * @param key * @param date * @return */ public Boolean expireAt(String key, Date date) &#123; return redisTemplate.expireAt(key, date); &#125; /** * 查找匹配的key * * @param pattern * @return */ public Set&lt;String&gt; keys(String pattern) &#123; return redisTemplate.keys(pattern); &#125; /** * 将当前数据库的 key 移动到给定的数据库 db 当中 * * @param key * @param dbIndex * @return */ public Boolean move(String key, int dbIndex) &#123; return redisTemplate.move(key, dbIndex); &#125; /** * 移除 key 的过期时间，key 将持久保持 * * @param key * @return */ public Boolean persist(String key) &#123; return redisTemplate.persist(key); &#125; /** * 返回 key 的剩余的过期时间 * * @param key * @param unit * @return */ public Long getExpire(String key, TimeUnit unit) &#123; return redisTemplate.getExpire(key, unit); &#125; /** * 返回 key 的剩余的过期时间 * * @param key * @return */ public Long getExpire(String key) &#123; return redisTemplate.getExpire(key); &#125; /** * 从当前数据库中随机返回一个 key * * @return */ public String randomKey() &#123; return redisTemplate.randomKey(); &#125; /** * 修改 key 的名称 * * @param oldKey * @param newKey */ public void rename(String oldKey, String newKey) &#123; redisTemplate.rename(oldKey, newKey); &#125; /** * 仅当 newkey 不存在时，将 oldKey 改名为 newkey * * @param oldKey * @param newKey * @return */ public Boolean renameIfAbsent(String oldKey, String newKey) &#123; return redisTemplate.renameIfAbsent(oldKey, newKey); &#125; /** * 返回 key 所储存的值的类型 * * @param key * @return */ public DataType type(String key) &#123; return redisTemplate.type(key); &#125; /** -------------------string相关操作--------------------- */ /** * 设置指定 key 的值 * @param key * @param value */ public void set(String key, String value) &#123; redisTemplate.opsForValue().set(key, value); &#125; /** * 获取指定 key 的值 * @param key * @return */ public String get(String key) &#123; return redisTemplate.opsForValue().get(key); &#125; /** * 返回 key 中字符串值的子字符 * @param key * @param start * @param end * @return */ public String getRange(String key, long start, long end) &#123; return redisTemplate.opsForValue().get(key, start, end); &#125; /** * 将给定 key 的值设为 value ，并返回 key 的旧值(old value) * * @param key * @param value * @return */ public String getAndSet(String key, String value) &#123; return redisTemplate.opsForValue().getAndSet(key, value); &#125; /** * 对 key 所储存的字符串值，获取指定偏移量上的位(bit) * * @param key * @param offset * @return */ public Boolean getBit(String key, long offset) &#123; return redisTemplate.opsForValue().getBit(key, offset); &#125; /** * 批量获取 * * @param keys * @return */ public List&lt;String&gt; multiGet(Collection&lt;String&gt; keys) &#123; return redisTemplate.opsForValue().multiGet(keys); &#125; /** * 设置ASCII码, 字符串'a'的ASCII码是97, 转为二进制是'01100001', 此方法是将二进制第offset位值变为value * * @param key * @param postion * 位置 * @param value * 值,true为1, false为0 * @return */ public boolean setBit(String key, long offset, boolean value) &#123; return redisTemplate.opsForValue().setBit(key, offset, value); &#125; /** * 将值 value 关联到 key ，并将 key 的过期时间设为 timeout * * @param key * @param value * @param timeout * 过期时间 * @param unit * 时间单位, 天:TimeUnit.DAYS 小时:TimeUnit.HOURS 分钟:TimeUnit.MINUTES * 秒:TimeUnit.SECONDS 毫秒:TimeUnit.MILLISECONDS */ public void setEx(String key, String value, long timeout, TimeUnit unit) &#123; redisTemplate.opsForValue().set(key, value, timeout, unit); &#125; /** * 只有在 key 不存在时设置 key 的值 * * @param key * @param value * @return 之前已经存在返回false,不存在返回true */ public boolean setIfAbsent(String key, String value) &#123; return redisTemplate.opsForValue().setIfAbsent(key, value); &#125; /** * 用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始 * * @param key * @param value * @param offset * 从指定位置开始覆写 */ public void setRange(String key, String value, long offset) &#123; redisTemplate.opsForValue().set(key, value, offset); &#125; /** * 获取字符串的长度 * * @param key * @return */ public Long size(String key) &#123; return redisTemplate.opsForValue().size(key); &#125; /** * 批量添加 * * @param maps */ public void multiSet(Map&lt;String, String&gt; maps) &#123; redisTemplate.opsForValue().multiSet(maps); &#125; /** * 同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在 * * @param maps * @return 之前已经存在返回false,不存在返回true */ public boolean multiSetIfAbsent(Map&lt;String, String&gt; maps) &#123; return redisTemplate.opsForValue().multiSetIfAbsent(maps); &#125; /** * 增加(自增长), 负数则为自减 * * @param key * @param value * @return */ public Long incrBy(String key, long increment) &#123; return redisTemplate.opsForValue().increment(key, increment); &#125; /** * * @param key * @param value * @return */ public Double incrByFloat(String key, double increment) &#123; return redisTemplate.opsForValue().increment(key, increment); &#125; /** * 追加到末尾 * * @param key * @param value * @return */ public Integer append(String key, String value) &#123; return redisTemplate.opsForValue().append(key, value); &#125; /** -------------------hash相关操作------------------------- */ /** * 获取存储在哈希表中指定字段的值 * * @param key * @param field * @return */ public Object hGet(String key, String field) &#123; return redisTemplate.opsForHash().get(key, field); &#125; /** * 获取所有给定字段的值 * * @param key * @return */ public Map&lt;Object, Object&gt; hGetAll(String key) &#123; return redisTemplate.opsForHash().entries(key); &#125; /** * 获取所有给定字段的值 * * @param key * @param fields * @return */ public List&lt;Object&gt; hMultiGet(String key, Collection&lt;Object&gt; fields) &#123; return redisTemplate.opsForHash().multiGet(key, fields); &#125; public void hPut(String key, String hashKey, String value) &#123; redisTemplate.opsForHash().put(key, hashKey, value); &#125; public void hPutAll(String key, Map&lt;String, String&gt; maps) &#123; redisTemplate.opsForHash().putAll(key, maps); &#125; /** * 仅当hashKey不存在时才设置 * * @param key * @param hashKey * @param value * @return */ public Boolean hPutIfAbsent(String key, String hashKey, String value) &#123; return redisTemplate.opsForHash().putIfAbsent(key, hashKey, value); &#125; /** * 删除一个或多个哈希表字段 * * @param key * @param fields * @return */ public Long hDelete(String key, Object... fields) &#123; return redisTemplate.opsForHash().delete(key, fields); &#125; /** * 查看哈希表 key 中，指定的字段是否存在 * * @param key * @param field * @return */ public boolean hExists(String key, String field) &#123; return redisTemplate.opsForHash().hasKey(key, field); &#125; /** * 为哈希表 key 中的指定字段的整数值加上增量 increment * * @param key * @param field * @param increment * @return */ public Long hIncrBy(String key, Object field, long increment) &#123; return redisTemplate.opsForHash().increment(key, field, increment); &#125; /** * 为哈希表 key 中的指定字段的整数值加上增量 increment * * @param key * @param field * @param delta * @return */ public Double hIncrByFloat(String key, Object field, double delta) &#123; return redisTemplate.opsForHash().increment(key, field, delta); &#125; /** * 获取所有哈希表中的字段 * * @param key * @return */ public Set&lt;Object&gt; hKeys(String key) &#123; return redisTemplate.opsForHash().keys(key); &#125; /** * 获取哈希表中字段的数量 * * @param key * @return */ public Long hSize(String key) &#123; return redisTemplate.opsForHash().size(key); &#125; /** * 获取哈希表中所有值 * * @param key * @return */ public List&lt;Object&gt; hValues(String key) &#123; return redisTemplate.opsForHash().values(key); &#125; /** * 迭代哈希表中的键值对 * * @param key * @param options * @return */ public Cursor&lt;Entry&lt;Object, Object&gt;&gt; hScan(String key, ScanOptions options) &#123; return redisTemplate.opsForHash().scan(key, options); &#125; /** ------------------------list相关操作---------------------------- */ /** * 通过索引获取列表中的元素 * * @param key * @param index * @return */ public String lIndex(String key, long index) &#123; return redisTemplate.opsForList().index(key, index); &#125; /** * 获取列表指定范围内的元素 * * @param key * @param start * 开始位置, 0是开始位置 * @param end * 结束位置, -1返回所有 * @return */ public List&lt;String&gt; lRange(String key, long start, long end) &#123; return redisTemplate.opsForList().range(key, start, end); &#125; /** * 存储在list头部 * * @param key * @param value * @return */ public Long lLeftPush(String key, String value) &#123; return redisTemplate.opsForList().leftPush(key, value); &#125; /** * * @param key * @param value * @return */ public Long lLeftPushAll(String key, String... value) &#123; return redisTemplate.opsForList().leftPushAll(key, value); &#125; /** * * @param key * @param value * @return */ public Long lLeftPushAll(String key, Collection&lt;String&gt; value) &#123; return redisTemplate.opsForList().leftPushAll(key, value); &#125; /** * 当list存在的时候才加入 * * @param key * @param value * @return */ public Long lLeftPushIfPresent(String key, String value) &#123; return redisTemplate.opsForList().leftPushIfPresent(key, value); &#125; /** * 如果pivot存在,再pivot前面添加 * * @param key * @param pivot * @param value * @return */ public Long lLeftPush(String key, String pivot, String value) &#123; return redisTemplate.opsForList().leftPush(key, pivot, value); &#125; /** * * @param key * @param value * @return */ public Long lRightPush(String key, String value) &#123; return redisTemplate.opsForList().rightPush(key, value); &#125; /** * * @param key * @param value * @return */ public Long lRightPushAll(String key, String... value) &#123; return redisTemplate.opsForList().rightPushAll(key, value); &#125; /** * * @param key * @param value * @return */ public Long lRightPushAll(String key, Collection&lt;String&gt; value) &#123; return redisTemplate.opsForList().rightPushAll(key, value); &#125; /** * 为已存在的列表添加值 * * @param key * @param value * @return */ public Long lRightPushIfPresent(String key, String value) &#123; return redisTemplate.opsForList().rightPushIfPresent(key, value); &#125; /** * 在pivot元素的右边添加值 * * @param key * @param pivot * @param value * @return */ public Long lRightPush(String key, String pivot, String value) &#123; return redisTemplate.opsForList().rightPush(key, pivot, value); &#125; /** * 通过索引设置列表元素的值 * * @param key * @param index * 位置 * @param value */ public void lSet(String key, long index, String value) &#123; redisTemplate.opsForList().set(key, index, value); &#125; /** * 移出并获取列表的第一个元素 * * @param key * @return 删除的元素 */ public String lLeftPop(String key) &#123; return redisTemplate.opsForList().leftPop(key); &#125; /** * 移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止 * * @param key * @param timeout * 等待时间 * @param unit * 时间单位 * @return */ public String lBLeftPop(String key, long timeout, TimeUnit unit) &#123; return redisTemplate.opsForList().leftPop(key, timeout, unit); &#125; /** * 移除并获取列表最后一个元素 * * @param key * @return 删除的元素 */ public String lRightPop(String key) &#123; return redisTemplate.opsForList().rightPop(key); &#125; /** * 移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止 * * @param key * @param timeout * 等待时间 * @param unit * 时间单位 * @return */ public String lBRightPop(String key, long timeout, TimeUnit unit) &#123; return redisTemplate.opsForList().rightPop(key, timeout, unit); &#125; /** * 移除列表的最后一个元素，并将该元素添加到另一个列表并返回 * * @param sourceKey * @param destinationKey * @return */ public String lRightPopAndLeftPush(String sourceKey, String destinationKey) &#123; return redisTemplate.opsForList().rightPopAndLeftPush(sourceKey, destinationKey); &#125; /** * 从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止 * * @param sourceKey * @param destinationKey * @param timeout * @param unit * @return */ public String lBRightPopAndLeftPush(String sourceKey, String destinationKey, long timeout, TimeUnit unit) &#123; return redisTemplate.opsForList().rightPopAndLeftPush(sourceKey, destinationKey, timeout, unit); &#125; /** * 删除集合中值等于value得元素 * * @param key * @param index * index=0, 删除所有值等于value的元素; index&gt;0, 从头部开始删除第一个值等于value的元素; * index&lt;0, 从尾部开始删除第一个值等于value的元素; * @param value * @return */ public Long lRemove(String key, long index, String value) &#123; return redisTemplate.opsForList().remove(key, index, value); &#125; /** * 裁剪list * * @param key * @param start * @param end */ public void lTrim(String key, long start, long end) &#123; redisTemplate.opsForList().trim(key, start, end); &#125; /** * 获取列表长度 * * @param key * @return */ public Long lLen(String key) &#123; return redisTemplate.opsForList().size(key); &#125; /** --------------------set相关操作-------------------------- */ /** * set添加元素 * * @param key * @param values * @return */ public Long sAdd(String key, String... values) &#123; return redisTemplate.opsForSet().add(key, values); &#125; /** * set移除元素 * * @param key * @param values * @return */ public Long sRemove(String key, Object... values) &#123; return redisTemplate.opsForSet().remove(key, values); &#125; /** * 移除并返回集合的一个随机元素 * * @param key * @return */ public String sPop(String key) &#123; return redisTemplate.opsForSet().pop(key); &#125; /** * 将元素value从一个集合移到另一个集合 * * @param key * @param value * @param destKey * @return */ public Boolean sMove(String key, String value, String destKey) &#123; return redisTemplate.opsForSet().move(key, value, destKey); &#125; /** * 获取集合的大小 * * @param key * @return */ public Long sSize(String key) &#123; return redisTemplate.opsForSet().size(key); &#125; /** * 判断集合是否包含value * * @param key * @param value * @return */ public Boolean sIsMember(String key, Object value) &#123; return redisTemplate.opsForSet().isMember(key, value); &#125; /** * 获取两个集合的交集 * * @param key * @param otherKey * @return */ public Set&lt;String&gt; sIntersect(String key, String otherKey) &#123; return redisTemplate.opsForSet().intersect(key, otherKey); &#125; /** * 获取key集合与多个集合的交集 * * @param key * @param otherKeys * @return */ public Set&lt;String&gt; sIntersect(String key, Collection&lt;String&gt; otherKeys) &#123; return redisTemplate.opsForSet().intersect(key, otherKeys); &#125; /** * key集合与otherKey集合的交集存储到destKey集合中 * * @param key * @param otherKey * @param destKey * @return */ public Long sIntersectAndStore(String key, String otherKey, String destKey) &#123; return redisTemplate.opsForSet().intersectAndStore(key, otherKey, destKey); &#125; /** * key集合与多个集合的交集存储到destKey集合中 * * @param key * @param otherKeys * @param destKey * @return */ public Long sIntersectAndStore(String key, Collection&lt;String&gt; otherKeys, String destKey) &#123; return redisTemplate.opsForSet().intersectAndStore(key, otherKeys, destKey); &#125; /** * 获取两个集合的并集 * * @param key * @param otherKeys * @return */ public Set&lt;String&gt; sUnion(String key, String otherKeys) &#123; return redisTemplate.opsForSet().union(key, otherKeys); &#125; /** * 获取key集合与多个集合的并集 * * @param key * @param otherKeys * @return */ public Set&lt;String&gt; sUnion(String key, Collection&lt;String&gt; otherKeys) &#123; return redisTemplate.opsForSet().union(key, otherKeys); &#125; /** * key集合与otherKey集合的并集存储到destKey中 * * @param key * @param otherKey * @param destKey * @return */ public Long sUnionAndStore(String key, String otherKey, String destKey) &#123; return redisTemplate.opsForSet().unionAndStore(key, otherKey, destKey); &#125; /** * key集合与多个集合的并集存储到destKey中 * * @param key * @param otherKeys * @param destKey * @return */ public Long sUnionAndStore(String key, Collection&lt;String&gt; otherKeys, String destKey) &#123; return redisTemplate.opsForSet().unionAndStore(key, otherKeys, destKey); &#125; /** * 获取两个集合的差集 * * @param key * @param otherKey * @return */ public Set&lt;String&gt; sDifference(String key, String otherKey) &#123; return redisTemplate.opsForSet().difference(key, otherKey); &#125; /** * 获取key集合与多个集合的差集 * * @param key * @param otherKeys * @return */ public Set&lt;String&gt; sDifference(String key, Collection&lt;String&gt; otherKeys) &#123; return redisTemplate.opsForSet().difference(key, otherKeys); &#125; /** * key集合与otherKey集合的差集存储到destKey中 * * @param key * @param otherKey * @param destKey * @return */ public Long sDifference(String key, String otherKey, String destKey) &#123; return redisTemplate.opsForSet().differenceAndStore(key, otherKey, destKey); &#125; /** * key集合与多个集合的差集存储到destKey中 * * @param key * @param otherKeys * @param destKey * @return */ public Long sDifference(String key, Collection&lt;String&gt; otherKeys, String destKey) &#123; return redisTemplate.opsForSet().differenceAndStore(key, otherKeys, destKey); &#125; /** * 获取集合所有元素 * * @param key * @param otherKeys * @param destKey * @return */ public Set&lt;String&gt; setMembers(String key) &#123; return redisTemplate.opsForSet().members(key); &#125; /** * 随机获取集合中的一个元素 * * @param key * @return */ public String sRandomMember(String key) &#123; return redisTemplate.opsForSet().randomMember(key); &#125; /** * 随机获取集合中count个元素 * * @param key * @param count * @return */ public List&lt;String&gt; sRandomMembers(String key, long count) &#123; return redisTemplate.opsForSet().randomMembers(key, count); &#125; /** * 随机获取集合中count个元素并且去除重复的 * * @param key * @param count * @return */ public Set&lt;String&gt; sDistinctRandomMembers(String key, long count) &#123; return redisTemplate.opsForSet().distinctRandomMembers(key, count); &#125; /** * * @param key * @param options * @return */ public Cursor&lt;String&gt; sScan(String key, ScanOptions options) &#123; return redisTemplate.opsForSet().scan(key, options); &#125; /**------------------zSet相关操作--------------------------------*/ /** * 添加元素,有序集合是按照元素的score值由小到大排列 * * @param key * @param value * @param score * @return */ public Boolean zAdd(String key, String value, double score) &#123; return redisTemplate.opsForZSet().add(key, value, score); &#125; /** * * @param key * @param values * @return */ public Long zAdd(String key, Set&lt;TypedTuple&lt;String&gt;&gt; values) &#123; return redisTemplate.opsForZSet().add(key, values); &#125; /** * * @param key * @param values * @return */ public Long zRemove(String key, Object... values) &#123; return redisTemplate.opsForZSet().remove(key, values); &#125; /** * 增加元素的score值，并返回增加后的值 * * @param key * @param value * @param delta * @return */ public Double zIncrementScore(String key, String value, double delta) &#123; return redisTemplate.opsForZSet().incrementScore(key, value, delta); &#125; /** * 返回元素在集合的排名,有序集合是按照元素的score值由小到大排列 * * @param key * @param value * @return 0表示第一位 */ public Long zRank(String key, Object value) &#123; return redisTemplate.opsForZSet().rank(key, value); &#125; /** * 返回元素在集合的排名,按元素的score值由大到小排列 * * @param key * @param value * @return */ public Long zReverseRank(String key, Object value) &#123; return redisTemplate.opsForZSet().reverseRank(key, value); &#125; /** * 获取集合的元素, 从小到大排序 * * @param key * @param start * 开始位置 * @param end * 结束位置, -1查询所有 * @return */ public Set&lt;String&gt; zRange(String key, long start, long end) &#123; return redisTemplate.opsForZSet().range(key, start, end); &#125; /** * 获取集合元素, 并且把score值也获取 * * @param key * @param start * @param end * @return */ public Set&lt;TypedTuple&lt;String&gt;&gt; zRangeWithScores(String key, long start, long end) &#123; return redisTemplate.opsForZSet().rangeWithScores(key, start, end); &#125; /** * 根据Score值查询集合元素 * * @param key * @param min * 最小值 * @param max * 最大值 * @return */ public Set&lt;String&gt; zRangeByScore(String key, double min, double max) &#123; return redisTemplate.opsForZSet().rangeByScore(key, min, max); &#125; /** * 根据Score值查询集合元素, 从小到大排序 * * @param key * @param min * 最小值 * @param max * 最大值 * @return */ public Set&lt;TypedTuple&lt;String&gt;&gt; zRangeByScoreWithScores(String key, double min, double max) &#123; return redisTemplate.opsForZSet().rangeByScoreWithScores(key, min, max); &#125; /** * * @param key * @param min * @param max * @param start * @param end * @return */ public Set&lt;TypedTuple&lt;String&gt;&gt; zRangeByScoreWithScores(String key, double min, double max, long start, long end) &#123; return redisTemplate.opsForZSet().rangeByScoreWithScores(key, min, max, start, end); &#125; /** * 获取集合的元素, 从大到小排序 * * @param key * @param start * @param end * @return */ public Set&lt;String&gt; zReverseRange(String key, long start, long end) &#123; return redisTemplate.opsForZSet().reverseRange(key, start, end); &#125; /** * 获取集合的元素, 从大到小排序, 并返回score值 * * @param key * @param start * @param end * @return */ public Set&lt;TypedTuple&lt;String&gt;&gt; zReverseRangeWithScores(String key, long start, long end) &#123; return redisTemplate.opsForZSet().reverseRangeWithScores(key, start, end); &#125; /** * 根据Score值查询集合元素, 从大到小排序 * * @param key * @param min * @param max * @return */ public Set&lt;String&gt; zReverseRangeByScore(String key, double min, double max) &#123; return redisTemplate.opsForZSet().reverseRangeByScore(key, min, max); &#125; /** * 根据Score值查询集合元素, 从大到小排序 * * @param key * @param min * @param max * @return */ public Set&lt;TypedTuple&lt;String&gt;&gt; zReverseRangeByScoreWithScores( String key, double min, double max) &#123; return redisTemplate.opsForZSet().reverseRangeByScoreWithScores(key, min, max); &#125; /** * * @param key * @param min * @param max * @param start * @param end * @return */ public Set&lt;String&gt; zReverseRangeByScore(String key, double min, double max, long start, long end) &#123; return redisTemplate.opsForZSet().reverseRangeByScore(key, min, max, start, end); &#125; /** * 根据score值获取集合元素数量 * * @param key * @param min * @param max * @return */ public Long zCount(String key, double min, double max) &#123; return redisTemplate.opsForZSet().count(key, min, max); &#125; /** * 获取集合大小 * * @param key * @return */ public Long zSize(String key) &#123; return redisTemplate.opsForZSet().size(key); &#125; /** * 获取集合大小 * * @param key * @return */ public Long zZCard(String key) &#123; return redisTemplate.opsForZSet().zCard(key); &#125; /** * 获取集合中value元素的score值 * * @param key * @param value * @return */ public Double zScore(String key, Object value) &#123; return redisTemplate.opsForZSet().score(key, value); &#125; /** * 移除指定索引位置的成员 * * @param key * @param start * @param end * @return */ public Long zRemoveRange(String key, long start, long end) &#123; return redisTemplate.opsForZSet().removeRange(key, start, end); &#125; /** * 根据指定的score值的范围来移除成员 * * @param key * @param min * @param max * @return */ public Long zRemoveRangeByScore(String key, double min, double max) &#123; return redisTemplate.opsForZSet().removeRangeByScore(key, min, max); &#125; /** * 获取key和otherKey的并集并存储在destKey中 * * @param key * @param otherKey * @param destKey * @return */ public Long zUnionAndStore(String key, String otherKey, String destKey) &#123; return redisTemplate.opsForZSet().unionAndStore(key, otherKey, destKey); &#125; /** * * @param key * @param otherKeys * @param destKey * @return */ public Long zUnionAndStore(String key, Collection&lt;String&gt; otherKeys, String destKey) &#123; return redisTemplate.opsForZSet() .unionAndStore(key, otherKeys, destKey); &#125; /** * 交集 * * @param key * @param otherKey * @param destKey * @return */ public Long zIntersectAndStore(String key, String otherKey, String destKey) &#123; return redisTemplate.opsForZSet().intersectAndStore(key, otherKey, destKey); &#125; /** * 交集 * * @param key * @param otherKeys * @param destKey * @return */ public Long zIntersectAndStore(String key, Collection&lt;String&gt; otherKeys, String destKey) &#123; return redisTemplate.opsForZSet().intersectAndStore(key, otherKeys, destKey); &#125; /** * * @param key * @param options * @return */ public Cursor&lt;TypedTuple&lt;String&gt;&gt; zScan(String key, ScanOptions options) &#123; return redisTemplate.opsForZSet().scan(key, options); &#125;&#125;依赖12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;version&gt;1.5.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;类方法说明一、keys相关命令NO方法描述1void delete(String key)key存在时删除key2void delete(Collection keys)批量删除key3byte[] dump(String key)序列化key，返回被序列化的值4Boolean hasKey(String key)检查key是否存在5Boolean expire(String key, long timeout, TimeUnit unit)设置过期时间6Boolean expireAt(String key, Date date)设置过期时间7Setkeys(String pattern)查找所有符合给定模式(pattern)的key8Boolean move(String key, int dbIndex)将当前数据库的key移动到给定的数据库db当中9Boolean persist(String key)移除key的过期时间，key将持久保持10Long getExpire(String key, TimeUnit unit)返回key的剩余的过期时间11Long getExpire(String key)返回key的剩余的过期时间12String randomKey()从当前数据库中随机返回一个key13void rename(String oldKey, String newKey)修改key的名称14Boolean renameIfAbsent(String oldKey, String newKey)仅当newkey不存在时，将oldKey改名为 newkey15DataType type(String key)返回key所储存的值的类型TimeUnit是时间单位，可选值有：&emsp;天:TimeUnit.DAYS、小时:TimeUnit.HOURS、分钟:TimeUnit.MINUTES、秒:TimeUnit.SECONDS、毫秒:TimeUnit.MILLISECONDS。二、String数据类型操作NO方法描述1String get(String key)获取指定key的值2String getRange(String key, long start, long end)返回key中字符串值的子字符3String getAndSet(String key, String value)将key的值设为value，并返回key旧值4Boolean getBit(String key, long offset)对key所储存的值，获取指定位置上的bit5List multiGet(Collection keys)批量获取添加相关6void set(String key, String value)设置指定key的值7boolean setBit(String key, long offset, boolean value)设置指定位置上的ASCII码8void setEx(String key,String value,long timeout,TimeUnit unit)将值value关联到key，并设置key过期时间9boolean setIfAbsent(String key, String value)只有在 key 不存在时设置 key 的值10void setRange(String key, String value, long offset)用value覆写key的值，从偏移量offset开始11void multiSet(Map&lt;String,String&gt; maps)批量添加12boolean multiSetIfAbsent(Map&lt;String,String&gt; maps)批量添加，仅当所有key都不存在其他方法13Integer append(String key, String value)追加到末尾14Long incrBy(String key, long increment)增加(自增长), 负数则为自减15Double incrByFloat(String key, double increment)增加(自增长), 负数则为自减16Long size(String key)获取字符串的长度关于上面xxBit方法的使用：&emsp;例如字符’a’的ASCII码是97，转为二进制是’01100001’，setBit方法就是把第offset位置上变成0或者1，true是1，false是0。三、Hash相关的操作NO方法描述1Object hGet(String key, String field)获取存储在哈希表中指定字段的值2Map hGetAll(String key)获取所有给定字段的值3List hMultiGet(String key, Collection fields)获取所有给定字段的值添加相关4void hPut(String key, String hashKey, String value)添加字段5void hPutAll(String key, Map maps)添加多个字段6Boolean hPutIfAbsent(String key,String hashKey,String value)仅当hashKey不存在时才设置其他方法7Long hDelete(String key, Object… fields)删除一个或多个哈希表字段8boolean hExists(String key, String field)查看哈希表key中指定的字段是否存在9Long hIncrBy(String key, Object field, long increment)为哈希表key中指定字段的值增加increment10Double hIncrByFloat(String key, Object field, double delta)为哈希表key中指定字段的值增加increment11Set hKeys(String key)获取所有哈希表中的字段12Long hSize(String key)获取哈希表中字段的数量13List hValues(String key)获取哈希表中所有值14Cursor hScan(String key, ScanOptions options)迭代哈希表中的键值对四、List相关的操作NO方法描述1String lIndex(String key, long index)通过索引获取列表中的元素2List lRange(String key, long start, long end)获取列表指定范围内的元素添加相关3Long lLeftPush(String key, String value)存储在list头部4Long lLeftPushAll(String key, String… value)存储在list头部5Long lLeftPushAll(String key, Collection value)存储在list头部6Long lLeftPushIfPresent(String key, String value)当list存在的时候才加入7lLeftPush(String key, String pivot, String value)如果pivot存在,再pivot前面添加8Long lRightPush(String key, String value)存储在list尾部9Long lRightPushAll(String key, String… value)存储在list尾部10Long lRightPushAll(String key, Collection value)存储在list尾部11Long lRightPushIfPresent(String key, String value)当list存在的时候才加入12lRightPush(String key, String pivot, String value)在pivot元素的右边添加值13void lSet(String key, long index, String value)通过索引设置列表元素的值删除相关14String lLeftPop(String key)移出并获取列表的第一个元素15String lBLeftPop(String key,long timeout,TimeUnit unit)移出并获取第一个元素,没有则阻塞直到超时或有为止16String lRightPop(String key)移除并获取列表最后一个元素17String lBRightPop(String key,long timeout,TimeUnit unit)移出并获取最后个元素,没有则阻塞直到超时或有为止18String lRightPopAndLeftPush(String sKey,String dKey)移除最后一个元素并加到另一个列表并返回19String lBRightPopAndLeftPush(sKey,dKey,timeout,unit)移除最后个元素并加到另个列表并返回,阻塞超时或有20Long lRemove(String key, long index, String value)删除集合中值等于value得元素21void lTrim(String key, long start, long end)裁剪list其他方法22Long lLen(String key)获取列表长度五、Set相关的操作NO方法描述1SetsMembers(String key)获取集合所有元素2Long sSize(String key)获取集合大小3Boolean sIsMember(String key, Object value)判断集合是否包含value4String sRandomMember(String key)随机获取集合中的一个元素5ListsRandomMembers(String key, long count)随机获取集合count个元素6SetsDistinctRandomMembers(String key, long count)随机获取count个元素并去除重复的7CursorsScan(String key, ScanOptions options)使用迭代器获取元素8SetsIntersect(String key, String otherKey)获取两个集合的交集9SetsIntersect(String key, CollectionotherKeys)获取key集合与多个集合的交集10Long sIntersectAndStore(String key, String oKey, String dKey)key集合与oKey的交集存储到dKey中11Long sIntersectAndStore(String key,CollectionoKeys,String dKey)key与多个集合的交集存储到dKey中12SetsUnion(String key, String otherKeys)获取两个集合的并集13SetsUnion(String key, CollectionotherKeys)获取key集合与多个集合的并集14Long sUnionAndStore(String key, String otherKey, String destKey)key集合与oKey的并集存储到dKey中15Long sUnionAndStore(String key,CollectionoKeys,String dKey)key与多个集合的并集存储到dKey中16SetsDifference(String key, String otherKey)获取两个集合的差集17SetsDifference(String key, CollectionotherKeys)获取key集合与多个集合的差集18Long sDifference(String key, String otherKey, String destKey)key与oKey集合的差集存储到dKey中19Long sDifference(String key,CollectionotherKeys,String dKey)key与多个集合的差集存储到dKey中添加相关20Long sAdd(String key, String… values)添加删除相关21Long sRemove(String key, Object… values)移除22String sPop(String key)随机移除一个元素23Boolean sMove(String key, String value, String destKey)将key集合中value移到destKey中六、zset数据类型操作NO方法描述1SetzRange(String key, long start, long end)获取元素,小到大排序,s开始e结束位置2Set&lt;TypedTuple&gt; zRangeWithScores(String key, long start, long end)获取集合元素, 并且把score值也获取3SetzRangeByScore(String key, double min, double max)根据score范围查询元素,从小到大排序4Set&lt;TypedTuple&gt; zRangeByScoreWithScores(key,double min,double max)根据score范围查询元素,并返回score5SetzRangeByScoreWithScores(key,double min,max,long start,end)根据score查询元素,s开始e结束位置6SetzReverseRange(String key, long start, long end)获取集合元素, 从大到小排序7Set&lt;TypedTuple&gt; zReverseRangeWithScores(key, long start, long end)获取元素,从大到小排序,并返回score8SetzReverseRangeByScore(String key, double min, double max)根据score范围查询元素,从大到小排序9SetzReverseRangeByScoreWithScores(key,double min,double max)根据score查询,大到小排序返回score10SetzReverseRangeByScore(key, double min, max, long start, end)根据score查询,大到小,s开始e结束11Long zRank(String key, Object value)返回元素在集合的排名,score由小到大12Long zReverseRank(String key, Object value)返回元素在集合的排名,score由大到小13Long zCount(String key, double min, double max)根据score值范围获取集合元素的数量14Long zSize(String key)获取集合大小15Long zZCard(String key)获取集合大小16Double zScore(String key, Object value)获取集合中value元素的score值17Long zUnionAndStore(String key, String otherKey, String destKey)获取key和oKey的并集并存储在dKey中18Long zUnionAndStore(String key,CollectionotherKeys,String dKey)获取key和多个集合并集并存在dKey中19Long zIntersectAndStore(String key, String otherKey, String destKey)获取key和oKey交集并存在destKey中20Long zIntersectAndStore(String key,CollectionoKeys,String dKey)获取key和多个集合交集并存在dKey中21Cursor&lt;TypedTuple&gt; zScan(String key, ScanOptions options)使用迭代器获取添加相关22Boolean zAdd(String key, String value, double score)添加元素,zSet按score由小到大排列23Long zAdd(String key, Set&lt;TypedTuple&gt; values)批量添加,TypedTuple使用见下面介绍删除相关24Long zRemove(String key, Object… values)移除25Double zIncrementScore(String key, String value, double delta)增加元素的score值,并返回增加后的值26Long zRemoveRange(String key, long start, long end)移除指定索引位置的成员27Long zRemoveRangeByScore(String key, double min, double max)根据指定的score值的范围来移除成员批量添加时TypedTuple的使用：TypedTupletypedTuple = new DefaultTypedTuple(value,score)知识补充一、Redis知识补充&emsp;Redis 可以存储键与5种不同数据结构类型之间的映射，这5种数据结构类型分别为：String（字符串）、List（列表）、Set（集合）、Hash（散列）和 zSet（有序集合）。1.String（字符串）结构存储的值：&emsp;&emsp;可以是字符串、整数或者浮点数。结构的读写能力：&emsp;&emsp;对整个字符串或者字符串的其中一部分执行操作，对象和浮点数执行自增(increment)或者自减(decrement)。2. List（列表）结构存储的值：&emsp;&emsp;一个链表，链表上的每个节点都包含了一个字符串。结构的读写能力：&emsp;&emsp;从链表的两端推入或者弹出元素，根据偏移量(offset)对链表进行修剪(trim)，读取单个或者多个元素，根据值来查找或者移除元素。3. Set（集合）结构存储的值：&emsp;&emsp;包含字符串的无序收集器(unOrderedCollection)，并且被包含的每个字符串都是独一无二的、各不相同。结构的读写能力：&emsp;&emsp;添加、获取、移除单个元素，检查一个元素是否存在于某个集合中，计算交集、并集、差集，从集合里面随机获取元素。4. Hash（散列）结构存储的值：&emsp;&emsp;包含键值对的无序散列表。结构的读写能力：&emsp;&emsp;添加、获取、移除单个键值对，获取所有键值对。5. zSet（有序集合）结构存储的值：&emsp;&emsp;字符串成员(member)与浮点数分值(score)之间的有序映射，元素的排列顺序由分值(score)的大小决定。结构的读写能力：&emsp;&emsp;添加、获取、删除单个元素，根据分值(score)范围(range)或者成员来获取元素。二、RedisTemplate和StringRedisTemplate&emsp;&emsp;二者主要区别是他们使用的序列化类不一样，RedisTemplate使用的是JdkSerializationRedisSerializer，StringRedisTemplate使用的是StringRedisSerializer，两者的数据是不共通的。1. RedisTemplate：&emsp;&emsp;RedisTemplate使用的是JDK的序列化策略，向Redis存入数据会将数据先序列化成字节数组然后在存入Redis数据库，这个时候打开Redis查看的时候，你会看到你的数据不是以可读的形式展现的，而是以字节数组显示，类似下面：\xAC\xED\x00\x05t\x05sr\x00。&emsp;&emsp;所以使用RedisTemplate可以把一个Java对象直接存储在Redis里面，但是存进去的数据是不易直观读的，不通用的，建议不要直接存一个Object对象，可以变成Hash来存储，也可以转成json格式的数据来存储，在实际应用中也是很多都采用json格式来存储的。2. StringRedisTemplate:&emsp;&emsp;StringRedisTemplate默认采用的是String的序列化策略，保存的key和value都是采用此策略序列化保存的，StringRedisTemplate是继承RedisTemplate的，这种对redis的操方式更优雅，任何Redis连接工具，都可以读出直观的数据，便于数据的维护。三、Redis与Spring的集成1.集成配置12345678910111213141516171819202122&lt;bean id="poolConfig" class="redis.clients.jedis.JedisPoolConfig"&gt; &lt;property name="maxIdle" value="300" /&gt; &lt;property name="maxTotal" value="600" /&gt; &lt;property name="maxWaitMillis" value="1000" /&gt; &lt;property name="testOnBorrow" value="true" /&gt;&lt;/bean&gt;&lt;bean id="jedisConnectionFactory" class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory"&gt; &lt;property name="hostName" value="127.0.0.1" /&gt; &lt;property name="password" value="" /&gt; &lt;property name="port" value="6379" /&gt; &lt;property name="poolConfig" ref="poolConfig" /&gt;&lt;/bean&gt;&lt;bean id="redisTemplate" class="org.springframework.data.redis.core.StringRedisTemplate"&gt; &lt;property name="connectionFactory" ref="jedisConnectionFactory" /&gt;&lt;/bean&gt;&lt;!-- RedisUtil注入RedisTemplate --&gt;&lt;bean id="redisUtil" class="com.xxx.utils.RedisUtil"&gt; &lt;property name="redisTemplate" ref="redisTemplate" /&gt;&lt;/bean&gt;2.使用RedisUtil工具类方法如下：12@Autowiredprivate RedisUtil redisUtil;四、SpringBoot中如何使用修改你的RedisUtil代码：1234567@Componentpublic class RedisUtil &#123; @Autowired private StringRedisTemplate redisTemplate; ......&#125;使用@Autowired自动注入redisTemplate。]]></content>
      <categories>
        <category>工具</category>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>工具类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用redis来防止恶意请求]]></title>
    <url>%2F2019%2F05%2F31%2F%E4%BD%BF%E7%94%A8redis%E6%9D%A5%E9%98%B2%E6%AD%A2%E6%81%B6%E6%84%8F%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[奔入正题redis 的一系列等等的，就不在这说了，以后完善笔记了再细细总结，公司的一个需求，想避免爬虫来爬网站。效果还没有试（自测是没问题），先来记录一哈。过程中使用的事springboot来搭建项目的，主要是方便，省去了那么多繁琐的配置。还是惯例，先是依赖12345678910111213141516171819202122232425262728&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.38&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.1.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;version&gt;1.5.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;1.5.7.RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;配置文件打心底我比较喜欢properties文件的。123456789101112131415#Redis#spring.redis.host=127.0.0.1redis.host=127.0.0.1## Redis服务器连接端口redis.port=6379## 连接超时时间（毫秒）redis.timeout=3000## Redis服务器连接密码（默认为空）redis.password=## 连接池中的最大连接数redis.poolMaxTotal=10## 连接池中的最大空闲连接redis.poolMaxIdle=10## 连接池最大阻塞等待时间（使用负值表示没有限制）redis.poolMaxWait=3000redis的一个工具，用的是gitee的 https://gitee.com/whvse/RedisUtil 这个工具，还阔以就是设置key的时候不能顺带着把过期时间也给设置了，算美中不足的吧！（也可以在工具目录找到，有详细的说明）先来微微的配置一下:1234567891011121314@Configurationpublic class WebConfigurer implements WebMvcConfigurer &#123; // 会重写一大堆方法，这就需要这一个 @Autowired public DdosIntercepors Dintercepors; // 后面的拦截的配置，注入到这个里面才生效的 public void addInterceptors(InterceptorRegistry registry) &#123; // 拦截所有，过滤注册方法与登陆方法 registry.addInterceptor(Dintercepors).addPathPatterns("/**").excludePathPatterns("/login", "/register"); &#125; // 拦截静态资源的方法 public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; &#125;&#125;下面这个才是真正的拦截配置：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@Componentpublic class DdosIntercepors implements HandlerInterceptor &#123; @Autowired RedisUtil redisUtil; public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; String ip = GetAddr.getIpAddress(request); if(redisUtil.sIsMember("ddos",ip))&#123; // 是否包含value returnJson(response,"请求太快，小心我美食九连，揉你猫猫皮"); //另一个同事测试的时候开玩笑的 return false; &#125; if(redisUtil.hasKey(ip))&#123; // 判断IP是否存在redis中 int index = Integer.parseInt(redisUtil.get(ip))+1; redisUtil.setRange(ip,index+"",0); // 更新一下当前ip访问的次数,这个方法不会覆盖过去时间 &#125;else&#123; String start="1"; redisUtil.setEx(ip,start,60, TimeUnit.SECONDS); // 每一个进来的ip都存入到redis，并设置过期时间 &#125; // 进行判断 int count = Integer.parseInt(redisUtil.get(ip)); if(count&gt;=10)&#123; redisUtil.sAdd("ddos",ip); redisUtil.expire("ddos",60,TimeUnit.SECONDS); &#125; System.out.println("velete"); return true; &#125; // 被拦截后给一个友好的提示（确实很友好） private void returnJson(HttpServletResponse response, String json) throws Exception&#123; PrintWriter writer = null; response.setCharacterEncoding("UTF-8"); response.setContentType("text/html; charset=utf-8"); try &#123; writer = response.getWriter(); writer.print(json); &#125; catch (IOException e) &#123; System.out.println("error"); &#125; finally &#123; if (writer != null) writer.close(); &#125; &#125; public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; &#125; public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; &#125;&#125;controller层1234567891011@RestControllerpublic class UserController &#123; @RequestMapping("/getuser") public List&lt;String&gt; getUser() &#123; List&lt;String&gt; listUser = new ArrayList&lt;String&gt;(); listUser.add("zhangsan"); listUser.add("lisi"); listUser.add("yushengjun"); return listUser; &#125;&#125;拦截的效果补充说明redis的key设置过期时间后，如果你重新设置了key的值以后，过期时间会被覆盖就不存在了，但是list与set的添加元素的操作是不会的，使用时如果想更新值还不想失效时间被覆盖，建议使用 SETRANGE key [value] 来进行值的更新12set key "3" // 设置key为“3”setrange key 0 "4" // 从第零位开始覆盖，我这里的更新数字是递增的，所以设置闷着头为 0 就可以了脑子瓦特了，让值自增不好吗？值自增也是不会对过期时间有什么操纵的。]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>拦截器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识Nginx]]></title>
    <url>%2F2019%2F05%2F28%2F%E5%88%9D%E8%AF%86Nginx%2F</url>
    <content type="text"><![CDATA[应用场景http服务器，使用nginx做静态服务器、图片服务器虚拟主机配置，将一台服务器拆分成多个网站部署反向代理，可以隐藏真实的 ip 访问地址配建接口网关（解决跨域问题）实现网站的动静分离防止DDos，防盗链配置缓存配置文件结构说明仅仅有server，后面再进行补充123456789101112131415161718192021# 内部创建服务器、监听端口server &#123; #server 监听的端口号 listen 80; #服务器name 配置域名 server_name solo.ning.com; #匹配所有url地址 location / &#123; # 监听拦截后 跳转根目录 资源目录文件 html文件 root html # 默认首页 index.html index index.html index.htm; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125;Nginx虚拟主机配置1、基于域名的虚拟主机，通过域名来区分虚拟主机——应用：外部网站2、基于端口的虚拟主机，通过端口来区分虚拟主机——应用：公司内部网站，外部网站的管理后台3、基于ip的虚拟主机，几乎不用。基于虚拟主机配置域名在hosts文件中添加 bbs.ning.com、www.ning.com 都映射到127.0.0.1上（下面默认，更改的话，会有说明）1234567891011121314151617 server &#123; listen 80; server_name bbs.ning.com; location / &#123; root data/bbs; # 在根目录中创建，index的内容就一&lt;h1&gt;BBS&lt;/h1&gt; index index.html index.htm; &#125; &#125; server &#123; listen 80; server_name www.ning.com; location / &#123; root data/www; # 在根目录中创建，index的内容就一&lt;h1&gt;www&lt;/h1&gt; index index.html index.htm; &#125;&#125;效果分别为基于端口的虚拟主机1234567891011121314151617server &#123; listen 8080; server_name bbs.ning.com; location / &#123; root data/bbs; # 在根目录中创建，index的内容就一&lt;h1&gt;BBS&lt;/h1&gt; index index.html index.htm; &#125; &#125; server &#123; listen 8081; server_name bbs.ning.com; #此处重复没问题 location / &#123; root data/www; # 在根目录中创建，index的内容就一&lt;h1&gt;www&lt;/h1&gt; index index.html index.htm; &#125;&#125;效果：反向代理的配置12345678910111213141516 ### 当客户端访问nginx 的时候，拦截域名访问为www.itmayiedu.com,监听的端口号为80,匹配所有url地址### 最终查找/data/www目录文件地址 server &#123;## server 监听的端口号 listen 80; ###服务name 配置域名,配置域名 server_name www.itmayiedu.com; # #charset koi8-r; #access_log logs/host.access.log main; ###location 匹配所有url地址 location / &#123; ###nginx 反向代理转发的真实ip地址 proxy_pass http://127.0.0.1:8080; index index.html index.htm; &#125; &#125;访问 www.itmayiedu.com 就给转到 http://127.0.0.1:8080 上。在浏览器上输入www.itmayiedu.com，其实也是有端口的，端口就是80，默认端口，只是省略了而已。]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>反向代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swagger的使用]]></title>
    <url>%2F2019%2F05%2F27%2Fswagger%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[传统文档的痛点对API文档进行更新的时候，需要通知前端开发人员，导致文档更新交流不及时；API接口返回信息不明确大公司中肯定会有专门文档服务器对接口文档进行更新。缺乏在线接口测试，通常需要使用相应的API测试工具，比如postman、SoapUI等接口文档太多，不便于管理Swagger具有以下优点功能丰富：支持多种注解，自动生成接口文档界面，支持在界面测试API接口功能；及时更新：开发过程中花一点写注释的时间，就可以及时的更新API文档，省心省力；整合简单：通过添加 pom 依赖和简单配置，内嵌于应用中就可同时发布API接口文档界面，不需要部署独立服务。使用springboot的集成后面会又springCloud的和zuul整合进行文档的管理依赖文件12345678910111213141516171819202122232425&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;!-- SpringBoot整合Web组件 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--SpringBoot swagger2 --&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.8.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--SpringBoot swagger2 -UI --&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.8.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;文件的配置类（java形式的）1234567891011121314151617181920@Configuration@EnableSwagger2public class SwaggerConfig &#123; @Bean public Docket api() &#123; return new Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo()).select() // 自行修改为自己的包路径 .apis(RequestHandlerSelectors.basePackage("com.king.swagerr.controller")).paths(PathSelectors.any()) .build(); &#125; private ApiInfo apiInfo() &#123; return new ApiInfoBuilder().title("api文档").description("restfun 风格接口") // 服务条款网址 // .termsOfServiceUrl("http://blog.csdn.net/forezp") .version("1.0") // .contact(new Contact("帅呆了", "url", "email")) .build(); &#125;&#125;接口类12345678910111213141516@RestController@RequestMapping("api")@Api("swaggerDemoController相关的api")public class SwaggerDemoController &#123; private static final Logger logger = LoggerFactory.getLogger(SwaggerDemoController.class); @ApiOperation(value = "根据id查询学生信息", notes = "查询数据库中某个的学生信息") @ApiImplicitParam(name = "id", value = "学生ID", paramType = "path", required = true, dataType = "Integer") @RequestMapping(value = "/&#123;id&#125;", method = RequestMethod.GET) // 必须声明请求方法，负责会生成好多个无用说明 public String getStudent(@PathVariable int id) &#123; logger.info("开始查询某个学生信息"); return "success"; &#125;&#125;访问地址 http://localhost:8080//swagger-ui.html#/zuul网关整合SwaggerzuulServer 网关的配置，其他的配置忽略了12345678zuul: routes: api-a: path: /api-member/** service-id: service-member api-b: path: /api-order/** service-id: service-order依赖文件,统一都用这一个12345678910&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.5.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.5.0&lt;/version&gt;&lt;/dependency&gt;zuulServer的Swagger的配置：1234567891011121314151617181920@Configuration@EnableSwagger2public class SwaggerConfig &#123; @Bean public Docket createRestApi() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()); &#125; private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title("分布式购物系统") .description("购物系统接口文档说明") .termsOfServiceUrl("http://localhost:8081") .contact(new Contact("guoning", "", "1260408088@qq.com")) .version("1.0") .build(); &#125;&#125;orderServer与userServer配置相同：1234567891011121314151617181920212223@Configuration@EnableSwagger2public class SwaggerConfig &#123; @Bean public Docket createRestApi() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.basePackage("com.order.controller")) // 扫描包 .paths(PathSelectors.any()) .build(); &#125; private ApiInfo apiInfo() &#123; // 下面的信息，自行更改 return new ApiInfoBuilder() .title("购物系统-订单模块") .description("购物系统订单模块接口文档说明") .termsOfServiceUrl("http://localhost:8083") .contact(new Contact("guoning", "", "1260408088@qq.com")) .version("1.0") .build(); &#125;&#125;controller中的配置,12345678910111213141516@RestController@RequestMapping("api")@Api("swaggerDemoController相关的api")public class SwaggerDemoController &#123; private static final Logger logger = LoggerFactory.getLogger(SwaggerDemoController.class); @ApiOperation(value = "根据id查询学生信息", notes = "查询数据库中某个的学生信息") // 描述 @ApiImplicitParam(name = "id", value = "学生ID", paramType = "path",required = true, dataType = "Integer") // 参数描述 @RequestMapping(value = "/&#123;id&#125;", method = RequestMethod.GET) // 必须声明请求方法，负责会生成好多个无用说明 public String getStudent(@PathVariable int id) &#123; logger.info("开始查询某个学生信息"); return "success"; &#125;&#125;就到这了，其中有参考了 https://www.jianshu.com/p/af4ff19afa04 ，因为课程视频中不太详细。]]></content>
      <categories>
        <category>swagger</category>
      </categories>
      <tags>
        <tag>接口文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建网关集群]]></title>
    <url>%2F2019%2F05%2F27%2F%E6%90%AD%E5%BB%BA%E7%BD%91%E5%85%B3%E9%9B%86%E7%BE%A4%2F</url>
    <content type="text"><![CDATA[准备工作​ 打开 C:\Windows\System32\drivers\etc 下的hosts文件，在文件末尾加上12# 后面的地址自定，随意127.0.0.1 solo.ning.com找到你的 nginx 的配置文件，微微的更改一下，1234567891011121314#### 上游服务器 集群 默认轮训机制，需要自己加上 upstream backServer&#123; server 127.0.0.1:81 weight=10; server 127.0.0.1:82 weight=10; &#125;### 配置文件中存在，需要微微的更改一下 server &#123; listen 80; server_name solo.ning.com; location / &#123; ### 指定上游服务器负载均衡服务器 proxy_pass http://backServer/; index index.html index.htm; &#125;开启zuul的网关​ 不辞劳苦的再来一遍吧，方便观看，来回的几个文件翻着总是不太方便配置文件12345678910111213141516171819202122232425262728293031323334353637383940###服务注册地址eureka: client: serviceUrl: defaultZone: http://localhost:8100/eureka/###api网关端口号 server: port: 82###网关名称 spring: application: name: service-zuul cloud: config: ####读取后缀 profile: dev ####读取config-server注册地址 discovery: service-id: config-server enabled: true zuul: routes: ###定义转发服务规则 api-a: ### 当客户端发送请求 127.0.0.1:80/api-member开头的 都会转发到会员服务 path: /api-member/** ###服务别名 zuul网关默认整合ribbon 自动实现负载均衡轮训效果 serviceId: app-itmayiedu-member api-b: ### 当客户端发送请求 127.0.0.1:80/api-order开头的 都会转发到订单服务 path: /api-order/** ##订单服务别名 serviceId: app-itmayiedu-order api-c: ### 当客户端发送请求 127.0.0.1:80/api-pay开头的 都会转发到支付服务 path: /api-pay/** ##订单服务别名 serviceId: app-itmayiedu-pay###默认服务读取eureka注册服务列表 默认间隔30秒网关拦截类1234567891011121314151617181920212223242526272829303132333435363738394041424344@Componentpublic class TokenFilter extends ZuulFilter &#123; @Value("$&#123;server.port&#125;") private String port; // 编写过滤器拦截业务逻辑代码 public Object run() throws ZuulException &#123; // 案例：拦截所有的服务接口，判断服务接口上是否有传递userToken参数 // 1.获取上下文 RequestContext currentContext = RequestContext.getCurrentContext(); // 2.获取 Request HttpServletRequest request = currentContext.getRequest(); // 3.获取token 的时候 从请求头中获取 String userToken = request.getParameter("token"); if (StringUtils.isEmpty(userToken)) &#123; // 不会继续执行... 不会去调用服务接口，网关服务直接响应给客户端 currentContext.setSendZuulResponse(false); currentContext.setResponseBody("userToken is null"); currentContext.setResponseStatusCode(401); return null; // 返回一个错误提示 &#125; // 正常执行调用其他服务接口... System.out.println("网关的接口:"+port); return null; &#125; public boolean shouldFilter() &#123; return true; &#125; // 过滤器执行顺序,当一个请求在同一个阶段的时候存在多个过滤器的时候，多个过滤器执行顺序 public int filterOrder() &#123; return 0; &#125; // 过滤类型 pre 表示在请求之前进行执行 @Override public String filterType() &#123; return "pre"; &#125; // 网关过滤器如何编写&#125;启动类：123456789@SpringBootApplication@EnableEurekaClient@EnableZuulProxypublic class AppGateWay &#123; // @EnableZuulProxy 开启网关代理 public static void main(String[] args) &#123; SpringApplication.run(AppGateWay.class, args); &#125;&#125;启动两个网关，端口分别为 81、82，不会启动的传送门springCloud入门。启动后访问 http://solo.ning.com/api-member/?token=1231 效果如下：启动的两个网关服务，以此打印出端口号如下：前面的 nginx 配置文件是不用加权重就可以进行轮训的，因为谷歌浏览器的原因，换个火狐或者其他的浏览器就可以了！这个问题不大。]]></content>
      <categories>
        <category>springcloud</category>
      </categories>
      <tags>
        <tag>集群</tag>
        <tag>网关</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springcloud动态网关]]></title>
    <url>%2F2019%2F05%2F27%2Fspringcloud%E5%8A%A8%E6%80%81%E7%BD%91%E5%85%B3%2F</url>
    <content type="text"><![CDATA[分布式配置​ 学以致用，之前学的分布式配置，这会有了用武之地了，将 zuul 的网关的配置放到码云上，方便管理，添加或者减少配置以后，不需要重启服务器就可以实现配置更新。之前的zuul的使用 springCloud入门，分布式配置说明springCloud分布式配置中心。一些配置就不在此处赘述了。（配置的没问题，就是没出现效果，急需的别往下看了）首先，在码云上项目中的config文件夹中创建一个 service-zuul-dev.yml 文件,文件内容如下：1234567891011### 配置网关反向代理 zuul: routes: api-a: ### 以 /api-member/访问转发到会员服务 path: /api-member/** serviceId: app-itmayiedu-member api-b: ### 以 /api-order/访问转发到订单服务 path: /api-order/** serviceId: app-itmayiedu-order然后在网关的项目中加上依赖文件：12345678910&lt;!-- actuator监控中心 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- springcloud config 2.0 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-client&lt;/artifactId&gt;&lt;/dependency&gt;网关项目的配置文件如下：1234567891011121314151617181920212223242526272829###服务注册地址eureka: client: serviceUrl: defaultZone: http://localhost:8100/eureka/###api网关端口号 server: port: 8881###网关名称 spring: application: name: service-zuul #这个名称和码云上文件的前缀相同 cloud: config: ####读取后缀 profile: dev ####读取config-server注册地址 discovery: service-id: config-server # 这是配置服务的项目ID如果不存在， enabled: true ###默认服务读取eureka注册服务列表 默认间隔30秒###开启所有监控中心接口management: endpoints: web: exposure: include: "*"需要在启动类中加上这个方法,这样才鞥读取到码云上的配置，和手动更新配置文件123456// zuul配置能够使用config实现实时更新 @RefreshScope @ConfigurationProperties("zuul") public ZuulProperties zuulProperties() &#123; return new ZuulProperties(); &#125;配置文件更新以后，方便生效。需要用 postman 来访问 http://127.0.0.1:8881/actuator/refresh效果：这是一篇失败的博文，最后的结果让人头秃，我找了一个上午没找到原因在哪，后来试了别人的源码，开始还好好的，演示截图的时候出问题了！而且找不到]]></content>
      <categories>
        <category>springcloud</category>
      </categories>
      <tags>
        <tag>配置</tag>
        <tag>springcloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springCloud分布式配置中心]]></title>
    <url>%2F2019%2F05%2F24%2FspringCloud%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%2F</url>
    <content type="text"><![CDATA[1.分布式配置中心的作用当一个系统中的配置文件发生改变的时候，我们需要重新启动该服务，才能使得新的配置文件生效，spring cloud config可以实现微服务中的所有系统的配置文件的统一管理，而且还可以实现当配置文件发生变化的时候，系统会自动更新获取新的配置。2.开始搭建​ 环境选择的是马云，呸呸呸“码云”（gitee）这一些列的注册什么的操作就不跳过了，反正中文的比github要方便的很多。码云上项目创建完毕后，先创建一个config的文件夹，然后再这个添加一个文件，文件名就有讲究了我这用的是server-config-dev.properties server-config是前缀，这玩意一会有用的 dev 表示开发环境，真实开发中会有很多的配置文件 会有pro 等等的。配置文件里的内容就比较简陋了，重在说明问题……1age=24补充一下：在码云创建的项目默认不是公开的，创建的时候注意一下，选择公开省去一些麻烦。3.配置中心​ 首先你需要一个注册中心，不知道怎么配的，传送门在这 springCloud入门。ok 这一步跳过4.添加一个服务端依赖文件：1234567891011121314151617181920212223242526272829303132333435363738394041&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;!-- 管理依赖 --&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Finchley.M7&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;dependencies&gt; &lt;!--spring-cloud 整合 config-server --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- SpringBoot整合eureka客户端 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- 注意： 这里必须要添加， 否者各种依赖有问题 --&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/libs-milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt;配置文件：1234567891011121314151617181920212223242526###服务注册到eureka地址eureka: client: service-url: defaultZone: http://localhost:8888/eurekaspring: application: ####注册中心应用名称 name: config-server cloud: config: server: git: ###git环境地址 uri: https://gitee.com/kingpony/config.git ####搜索目录 search-paths: - config # 码云上的项目你选择私有的话，需要加上 #username: #password: ####读取分支 label: master####端口号server: port: 8889启动主类：1234567@SpringBootApplication@EnableConfigServer // 开启分布式配置中心服务器端public class ServerApp &#123; public static void main(String[] args) &#123; SpringApplication.run(ServerApp.class, args); &#125;&#125;此时将项目运行起来，然后浏览器输入 localhost:8889/server-config-dev.properties 你就能看到配置文件的全貌，如果你多放几个配置文件也是可以的换个名字读就行了5添加一个客户端依赖123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;!-- 管理依赖 --&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Finchley.M7&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- SpringBoot整合Web组件 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- SpringBoot整合eureka客户端 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 开启手动刷新配置文件的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- 注意： 这里必须要添加， 否者各种依赖有问题 --&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/libs-milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt;配置文件： bootstrap.yml12345678910111213141516171819202122232425spring: application: ####注册中心应用名称,要和码云上所读取的那个配置文件的文件名前缀相同，不然读取不到的****** name: server-config cloud: config: ####读取后缀 profile: dev ####读取config-server注册地址 discovery: service-id: config-server enabled: true##### eureka服务注册地址eureka: client: service-url: defaultZone: http://localhost:8888/eurekaserver: port: 8881### 开启断点监控，不然刷新路径报错，起不到更新的作用management: endpoints: web: exposure: include: "*"启动类：(忽略下面无关配置，与方法…..)123456789101112131415@SpringBootApplication@RestControllerpublic class ClientApp &#123; public static void main(String[] args) &#123; SpringApplication.run(ClientApp.class, args); &#125; @Value("$&#123;age&#125;") String age; @RequestMapping(value = "/getUserName") public String getUserName () &#123; return age; &#125;&#125;controller1234567891011@RestController@RefreshScope // 手动刷新注解public class AgeController &#123; @Value("$&#123;age&#125;") private String age; @RequestMapping("/getAge") public String getAge()&#123; return age; &#125;&#125;访问 localhost:8881/getAge 效果如下6.手动刷新配置文件配置文件更改后还要启动客户端进行重新读取的话，这分布式配置中心的意义也就没有了，配置更新后，有两种方式可以进行刷新的1.手动刷新​ 以上代码中有说明的，具体步骤1.首先需要给客户端添加一个依赖12345&lt;!-- actuator监控中心 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;2.客户端配置文件添加以下文件123456### 开启断点监控，不然刷新路径报错，没用management: endpoints: web: exposure: include: "*"3.加上注解在接口类上添加，具体看上面1@RefreshScope一顿操作以后，现在码云上将 age=24 改为 age=34然后直接接着访问 localhost:8881/getAge结果没变化，不是浏览器的缓存的原因！你需要先访问一下这个地址刷新一下才可以http://127.0.0.1:8881/actuator/refresh postman的post方式访问，浏览器貌似没用的然后就是阔以了2.实时刷新没学会，先搁置，之后再更新]]></content>
      <categories>
        <category>springcloud</category>
      </categories>
      <tags>
        <tag>rpc</tag>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ribbon负载均衡实现]]></title>
    <url>%2F2019%2F05%2F24%2Fribbon%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[1.负载均衡原理（轮训）客户端请求的总次数对服务器集群列表数目进行求余运算当前请求总数为1，服务器列表的集群为2，1%2=1。所以当前访问下标为 List [1] 的服务器当前请求总数为2，服务器列表的集群为2，2%2=0。所以当前访问下标为 List [0] 的服务器当前请求总数为3，服务器列表的集群为2，2%2=0。所以当前访问下标为 List [1] 的服务器说明总数是从最开始访问开始累加的。2.带权重负载均衡解析轮训的方式在实际开发之中并不实际，因为不可能每一台服务器的性能都是相同的，所以带权重的更为实际一些求得最大公约数与最大权重值，每满足一次返回服务器后，减去最小权重值然后接着循环！直到将服务器列表循环完毕一次。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129public class WeightRoundRobin &#123; /**上次选择的服务器*/ private int currentIndex = -1; /**当前调度的权值*/ private int currentWeight = 0; /**最大权重*/ private int maxWeight; /**权重的最大公约数*/ private int gcdWeight; /**服务器数*/ private int serverCount; private List&lt;Server&gt; servers = new ArrayList&lt;Server&gt;(); /* * 得到两值的最大公约数 */ public int greaterCommonDivisor(int a, int b)&#123; if(a % b == 0)&#123; return b; &#125;else&#123; return greaterCommonDivisor(b,a % b); &#125; &#125; /* * 得到list中所有权重的最大公约数，实际上是两两取最大公约数d，然后得到的d * 与下一个权重取最大公约数，直至遍历完 */ public int greatestCommonDivisor(List&lt;Server&gt; servers)&#123; int divisor = 0; for(int index = 0, len = servers.size(); index &lt; len - 1; index++)&#123; if(index ==0)&#123; divisor = greaterCommonDivisor( servers.get(index).getWeight(), servers.get(index + 1).getWeight()); &#125;else&#123; divisor = greaterCommonDivisor(divisor, servers.get(index).getWeight()); &#125; &#125; return divisor; &#125; /* * 得到list中的最大的权重 */ public int greatestWeight(List&lt;Server&gt; servers)&#123; int weight = 0; for(Server server : servers)&#123; if(weight &lt; server.getWeight())&#123; weight = server.getWeight(); &#125; &#125; return weight; &#125; /** * 算法流程： * 假设有一组服务器 S = &#123;S0, S1, …, Sn-1&#125; * 有相应的权重，变量currentIndex表示上次选择的服务器 * 权值currentWeight初始化为0，currentIndex初始化为-1 ，当第一次的时候返回 权值取最大的那个服务器， * 通过权重的不断递减 寻找 适合的服务器返回 */ public Server getServer()&#123; while(true)&#123; currentIndex = (currentIndex + 1) % serverCount; if(currentIndex == 0)&#123; currentWeight = currentWeight - gcdWeight; if(currentWeight &lt;= 0)&#123; currentWeight = maxWeight; if(currentWeight == 0)&#123; return null; &#125; &#125; &#125; if(servers.get(currentIndex).getWeight() &gt;= currentWeight)&#123; return servers.get(currentIndex); &#125; &#125; &#125; public void init()&#123; servers.add(new Server("192.168.191.1", 1)); servers.add(new Server("192.168.191.2", 2)); servers.add(new Server("192.168.191.4", 4)); servers.add(new Server("192.168.191.8", 8)); maxWeight = greatestWeight(servers); gcdWeight = greatestCommonDivisor(servers); serverCount = servers.size(); &#125; public static void main(String args[])&#123; WeightRoundRobin weightRoundRobin = new WeightRoundRobin(); weightRoundRobin.init(); for(int i = 0; i &lt; 15; i++)&#123; Server server = weightRoundRobin.getServer(); System.out.println("server " + server.getIp() + " weight=" + server.getWeight()); &#125; &#125; &#125; class Server&#123; private String ip; private int weight; public Server(String ip, int weight) &#123; this.ip = ip; this.weight = weight; &#125; public String getIp() &#123; return ip; &#125; public void setIp(String ip) &#123; this.ip = ip; &#125; public int getWeight() &#123; return weight; &#125; public void setWeight(int weight) &#123; this.weight = weight; &#125; &#125;3.手写ribbon的负载均衡在服务的消费端写一个controller,原理就是轮训调用(使用了DiscoveryClient)12345678910111213141516171819202122232425262728@RestControllerpublic class ExtController &#123; @Autowired DiscoveryClient discoveryClient; @Autowired RestTemplate restTemplate; private int count = 1; @RequestMapping("getblance") public String getBance() &#123; ServiceInstance instance = getInstance(); String url = instance.getUri().toString() + "getuser"; String result = restTemplate.getForObject(url, String.class); return result; &#125; public ServiceInstance getInstance() &#123; List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances("service-member"); if (instances == null || instances.size() &lt;= 0) &#123; return null; &#125; int totalsize = instances.size(); int serverindex = count % totalsize; count++; ServiceInstance serviceInstance = instances.get(serverindex); return serviceInstance; &#125;&#125;写这个例子的时候，需要讲本地在配置的 @LoadBalanced 给注释掉]]></content>
      <categories>
        <category>springcloud</category>
      </categories>
      <tags>
        <tag>rpc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springCloud入门]]></title>
    <url>%2F2019%2F05%2F24%2FspringCloud%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[1.Springcloud的模块rest、feign 客户端调用工具ribbon 负载均衡zuul 接口网关euraka 服务注册中心Hystrix 熔断器2.注册中心的使用直接上代码，不逼逼。简单的演示一下服务的注册与使用服务提供者依赖文件：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.2.RELEASE&lt;/version&gt; &lt;relativePath /&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;dependencyManagement&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Dalston.RC1&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;build&gt;&lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt;&lt;/plugins&gt;&lt;/build&gt;&lt;repositories&gt;&lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt;&lt;/repository&gt;&lt;/repositories&gt;配置文件：123456789eureka: client: serviceUrl: defaultZone: http://localhost:8888/eureka/server: port: 8762 # 本程序的端口spring: application: name: service-member # 本程序在注册中心的名称,提供给消费者使用突然想起来顺序是不是有问题，注册中心被我给吃了！启动类：(偷懒了，启动类要与package平级，这样可以省去写包扫描的注解)123456789@SpringBootApplication@EnableEurekaClient // 注册中心客户端public class UserApp &#123; public static void main(String[] args) &#123; SpringApplication.run(UserApp.class, args); &#125;&#125;写一个假的controller略表意思1234567891011121314@RestControllerpublic class UserController &#123; @Value("$&#123;server.port&#125;") // 直接可以读取配置文件的内容，后序做负载均衡需要用上 private String port; @RequestMapping("/getuser") public List&lt;String&gt; getUser() &#123; List&lt;String&gt; listUser = new ArrayList&lt;String&gt;(); listUser.add("zhangsan"); listUser.add("lisi"); listUser.add("yushengjun"); listUser.add(port); return listUser; &#125;&#125;赶紧把注册中心给补上…..注册中心依赖文件:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.2.RELEASE&lt;/version&gt; &lt;relativePath /&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--eureka server --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- spring boot test --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Dalston.RC1&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt;配置文件：12345678910server: port: 8888eureka: instance: hostname: localhost client: registerWithEureka: false fetchRegistry: false serviceUrl: defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ # eureka注册中心的地址注册中心的主类：1234567@SpringBootApplication@EnableEurekaServer public class Launcher &#123; public static void main(String[] args) &#123; SpringApplication.run(Launcher.class, args); &#125;&#125;服务消费者依赖文件：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.2.RELEASE&lt;/version&gt; &lt;relativePath /&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Dalston.RC1&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt;配置文件：123456789eureka: client: serviceUrl: defaultZone: http://localhost:8888/eureka/server: port: 8764spring: application: name: service-order启动主类：1234567891011121314@SpringBootApplication@EnableEurekaClientpublic class OrderApp &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderApp.class, args); &#125; @Bean @LoadBalanced // 使用rest方式的时候，进行负载均衡时使用 (开启ribbon) RestTemplate restTemplate() &#123; return new RestTemplate(); &#125;&#125;虚假的controller：123456789101112@RestControllerpublic class OrderController &#123; @Autowired private MemberService memberService; @RequestMapping("/getOrderUserAll") public List&lt;String&gt; getOrderUserAll() &#123; System.out.println("订单服务开始调用会员服务"); return memberService.getOrderByUserList(); &#125;&#125;虚假的service：12345678@Servicepublic class MemberService &#123; @Autowired RestTemplate restTemplate; public List&lt;String&gt; getOrderByUserList() &#123; return restTemplate.getForObject("http://service-member/getuser", List.class); &#125;&#125;运行状态先启动注册中心，再启动消费者与提供者，负责会出错的….注册中心运行后的状态：两个服务，服务名称对应各自的配置文件中的名称。先访问服务的提供者，直接通过地址访问 localhost:8762/getuser然后通过消费者内部调用服务的方式，进行访问 http://localhost:8764/getOrderUserAll此处因为开启了负载均衡，访问的时候会一替一下的（轮训的算法）404，解决方案1.再开启一个服务的提供者，再idea下开启需要先讲配置文件中的端口改一下，然后如图勾选上并行运行就阔以了！2.或者去掉负载均衡的注解，安心的做个咸鱼~3.Feign上面介绍了的rest方式调用服务外，还存在着这一种调用的方式（已经整合了ribbon，自带负载均衡）废话少说，依赖文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.2.RELEASE&lt;/version&gt; &lt;relativePath /&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Dalston.RC1&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt;配置文件：12345678910111213141516171819202122eureka: client: serviceUrl: defaultZone: http://localhost:8888/eureka/server: port: 8765 tomcat: max-threads: 50spring: application: name: service-order-feign# 开启熔断，后面说#feign: # hystrix:# enabled: true#hystrix:# command: # default: # execution: # isolation:# thread: # timeoutInMilliseconds: 4000主类123456789@SpringBootApplication@EnableEurekaClient @EnableFeignClients // 开启feign的客户端public class Fegincon &#123; public static void main(String[] args) &#123; SpringApplication.run(Fegincon.class, args); &#125;&#125;service接口 (Feign 采用的是基于接口的注解)12345@FeignClient(value = "service-member")public interface MemberFeign &#123; @RequestMapping("/getuser") public List&lt;String&gt; getOrderByUserList();&#125;一个假的controller12345678910111213@RestControllerpublic class FeignMemberController &#123; @Autowired private MemberFeign memberFeign; @RequestMapping("/getFeignOrderByUserList") public List&lt;String&gt; getFeignOrderByUserList() &#123; return memberFeign.getOrderByUserList(); &#125; @RequestMapping("/getOrderFeign") public String getOrderFeign() &#123; return "getOrderFeign"; &#125;&#125;效果如图：（比较智能，没有404，知道我没有多开启项目，没有报404）4.zuul网关顾名思义，编不下去了……自己查去吧&lt;www.baidu.com&gt;依赖文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Edgware.SR1&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;配置文件1234567891011121314151617eureka: client: serviceUrl: defaultZone: http://localhost:8888/eureka/server: port: 8769spring: application: name: service-zuulzuul: routes: api-a: path: /api-member/** # 映射那么一下，和nginx的赶脚一样 service-id: service-member api-b: path: /api-order/** service-id: service-order启动主类12345678910@EnableZuulProxy // 开启网关代理@EnableEurekaClient@SpringBootApplicationpublic class ZuulApp &#123; public static void main(String[] args) &#123; SpringApplication.run(ZuulApp.class, args); &#125;&#125;此处演示的是一个过滤器，必须让请求携带一些参数负责会给报错过滤器代码如下：1234567891011121314151617181920212223242526272829303132333435363738@Componentpublic class MyFilter extends ZuulFilter &#123; private static Logger log = LoggerFactory.getLogger(MyFilter.class); @Override public String filterType() &#123; return "pre"; &#125; @Override public int filterOrder() &#123; return 0; &#125; public boolean shouldFilter() &#123; return true; &#125; public Object run() &#123; RequestContext ctx = RequestContext.getCurrentContext(); HttpServletRequest request = ctx.getRequest(); log.info(String.format("%s &gt;&gt;&gt; %s", request.getMethod(), request.getRequestURL().toString())); Object accessToken = request.getParameter("token"); if (accessToken != null) &#123; return null; // 拦截与否都会返回null &#125; log.warn("token is empty"); ctx.setSendZuulResponse(false); ctx.setResponseStatusCode(401); try &#123; ctx.getResponse().getWriter().write("token is empty"); &#125; catch (Exception e) &#123; &#125; return null; &#125;&#125;效果未带token参数带了token参数不加“api-member”也是可以访问的，但是没有过滤token的功能获得客户端信息的接口DiscoveryClient 可以获得服务中的详细信息，端口、url、名称等…..123456789@Autowiredprivate DiscoveryClient discoveryClient;@RequestMapping("/getClient") public void getClent()&#123; List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances("service-order"); for (ServiceInstance server:instances) &#123; System.out.println(server.getUri()); &#125; &#125;输出如下：]]></content>
      <categories>
        <category>springcloud</category>
      </categories>
      <tags>
        <tag>rpc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hystrix]]></title>
    <url>%2F2019%2F05%2F23%2FHystrix%2F</url>
    <content type="text"><![CDATA[1.服务器雪崩在高并发的情况下，所有的服务器线程都在处理高并发下的请求，倒置其他请求无法处理。A服务请求B服务，tomcat默认并发是50个，20000个请求一起过来时，B服务都在处理A服务的请求，其他请求（直接访问B服务的请求）都在等待状态！2.几个概念服务降级在高并发情况下，防止用户一直等待，使用服务降级方式(直接返回一个友好的提示给客户端，调用fallBack方法）服务熔断熔断机制目的为了保护服务，在高并发的情况下，如果请求达到一定极限(可以自己设置阔值)如果流量超出了设置阈值，让后直接拒绝访问，保护当前服务。使用服务降级方式返回一个友好提示，服务熔断和服务降级一起使用。服务隔离因为默认情况下，只有一个线程池会维护所有的服务接口，如果大量的请求访问同一个接口，达到tomcat 线程池默认极限，可能会导致其他服务无法访问。解决服务雪崩效应:使用服务隔离机制(线程池方式和信号量)，使用线程池方式实現隔离的原理: 相当于每个接口(服务)都有自己独立的线程池，因为每个线程池互不影响，这样的话就可以解决服务雪崩效应。线程池隔离:每个服务接口，都有自己独立的线程池，每个线程池互不影响。信号量隔离:使用一个原子计数器（或信号量）来记录当前有多少个线程在运行，当请求进来时先判断计数器的数值，若超过设置的最大线程个数则拒绝该请求，若不超过则通行，这时候计数器+1，请求返 回成功后计数器-1。此处应该有demo配置文件：1234567891011feign: hystrix:enabled: true #### hystrix禁止服务超时时间hystrix: command: default: execution: timeout: enabled: false依赖文件：12345&lt;!-- hystrix断路器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;/dependency&gt;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@RestControllerpublic class OrderServiceImpl extends BaseApiService implements IOrderService &#123; // 继承与接口不用细看，使用feigin整合 // 订单服务继承会员服务接口，用来实现feign客户端 减少重复接口代码 @Autowired private MemberServiceFeigin memberServiceFeigin; @RequestMapping("/orderToMember") public String orderToMember(String name) &#123; UserEntity user = memberServiceFeigin.getMember(name); return user == null ? "没有找到用户信息" : user.toString(); &#125; // 没有解决服务雪崩效应 @RequestMapping("/orderToMemberUserInfo") public ResponseBase orderToMemberUserInfo() &#123; return memberServiceFeigin.getUserInfo(); &#125; // 解决服务雪崩效应 // fallbackMethod 方法的作用：服务降级执行 // @HystrixCommand 默认开启线程池隔离方式,服务降级,服务熔断 // 设置Hystrix服务超时时间 /** * @HystrixCommand&lt;br&gt; * 默认开启服务隔离方式 以线程池方式&lt;br&gt; * 默认开启服务降级执行方法orderToMemberUserInfoHystrixFallback&lt;br&gt; * 默认开启服务熔断机制&lt;br&gt; * * @return */ @HystrixCommand(fallbackMethod = "orderToMemberUserInfoHystrixFallback") @RequestMapping("/orderToMemberUserInfoHystrix") public ResponseBase orderToMemberUserInfoHystrix() &#123; System.out.println("orderToMemberUserInfoHystrix:" + "线程池名称:" + Thread.currentThread().getName()); return memberServiceFeigin.getUserInfo(); &#125; public ResponseBase orderToMemberUserInfoHystrixFallback() &#123; return setResultSuccess("返回一个友好的提示：服务降级,服务器忙，请稍后重试!"); &#125; // 订单服务接口 @RequestMapping("/orderInfo") public ResponseBase orderInfo() &#123; System.out.println("orderInfo:" + "线程池名称:" + Thread.currentThread().getName()); return setResultSuccess(); &#125; // Hystrix 有两种方式配置保护服务 通过注解和接口形式&#125;reset方式的调用：123456789101112131415@Servicepublic class MemberService &#123; @Autowired RestTemplate restTemplate; @HystrixCommand(fallbackMethod = "orderError") public List&lt;String&gt; getOrderByUserList() &#123; return restTemplate.getForObject("http://service-member/getuser", List.class); &#125; public List&lt;String&gt; orderError() &#123; List&lt;String&gt; listUser = new ArrayList&lt;String&gt;(); listUser.add("not orderUser list"); return listUser; &#125;&#125;配置文件中添加：12345678###超时时间,不配置默认是一秒，实际开发之中需要进行配置hystrix: command: default: execution: isolation: thread: timeoutInMilliseconds: 4000主类中需要添加：1@EnableHystrix // 开启断路器feigin调用方式：配置文件：12345678910feign: hystrix: enabled: true # 开启断路器#hystrix:# command: # default: # execution: # isolation:# thread: # timeoutInMilliseconds: 4000service12345@FeignClient(value = "service-member",fallback= MemberFeignService.class)public interface MemberFeign &#123; @RequestMapping("/getuser") public List&lt;String&gt; getOrderByUserList();&#125;serviceImpl也就是服务降级调用的类123456789@Componentpublic class MemberFeignService implements MemberFeign &#123; @Override public List&lt;String&gt; getOrderByUserList() &#123; List&lt;String&gt; listUser = new ArrayList&lt;String&gt;(); listUser.add("not orderUser list"); return listUser; &#125;&#125;controller:123456789101112131415@RestControllerpublic class FeignMemberController &#123; @Autowired private MemberFeign memberFeign; @RequestMapping("/getFeignOrderByUserList") public List&lt;String&gt; getFeignOrderByUserList() &#123; return memberFeign.getOrderByUserList(); &#125; @RequestMapping("/getOrderFeign") public String getOrderFeign() &#123; return "getOrderFeign"; &#125;&#125;]]></content>
      <categories>
        <category>springcloud</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>rpc</tag>
      </tags>
  </entry>
</search>
