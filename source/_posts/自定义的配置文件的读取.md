---
title: 自定义的配置文件的读取
date: 2020-03-16 15:09:19
categories: 
- 工具
- 配置文件
tags: [配置文件,工具]
---

​		自定义的配置文件读取，其实就是如何自己读取配置文件罢了，之间没有自己读过都是靠着框架来读取的，最近看到了就稍微的补充一下。

首先配置文件的形式是properties的格式，考虑到会有多个线程访问这个配置文件，所以使用双重校验锁的单例模式来获取配置文件

``` java
public class PropertyHolderLazy {

	private static Properties prop = null;

	public static Properties getProps() throws Exception {
		if (prop == null) {
			synchronized (PropertyHolderLazy.class) {
				if (prop == null) {
					prop = new Properties();
                    // getResourceAsStream的目录因该为src的目录
prop.load(PropertyHolderLazy.class.getClassLoader().getResourceAsStream("collect.properties"));
				}
			}
		}
		return prop;
	}

}
```

``` java
// 获取配置参数
Properties props = PropertyHolderLazy.getProps();
props.getProperty("LOG_LEGAL_PREFIX"); // 建议使用一个变量的类，来进行获取
```

部分的配置文件：

``` properties
LOG_SOURCE_DIR=d:/logs/accesslog/
LOG_TOUPLOAD_DIR=d:/logs/toupload/
LOG_BACKUP_BASE_DIR=d:/logs/backup/
LOG_BACKUP_TIMEOUT=24
LOG_LEGAL_PREFIX=access.log.
```

​	上面这种是配置文件的全部的读取，下面这种是部分读取到类中，作为一个对象类的属性参数来使用的。不过这次的文件格式是yml格式的。

​	如下，这是配置参数中的部分的内容

``` yaml
ly:
  jwt:
    pubKeyPath: /Users/bystander/id_rsa.pub # 公钥地址
    cookieName: LY_TOKEN # cookie的名称
  filter:
    allowPaths:
    - /api/auth
    - /api/search
    - /api/user/register
    - /api/user/check
    - /api/user/code
    - /api/item
```

``` java
@ConfigurationProperties(prefix = "ly.jwt")
@Data
@Slf4j // lombok中的注解，等同 rivate final Logger logger = LoggerFactory.getLogger(当前类名.class);
// 写上后可直接使用log.info();等等日志打印的方式
public class JwtProperties {
    private String pubKeyPath;
    private PublicKey publicKey; // 此属性不在配置文件中，不存在默认不读取，
    private String cookieName;

    @PostConstruct ①
    public void init() {
        try {
            //获取公钥
            publicKey = RsaUtils.getPublicKey(pubKeyPath);
        } catch (Exception e) {
            log.error("初始化公钥失败", e);
            throw new RuntimeException();
        }

    }
}
```

同类型配置字段，读取为数组，还是上面的配置文件

``` java
@Data
@ConfigurationProperties(prefix = "ly.filter")
public class FilterProperties {
    private List<String> allowPaths;
}
```

1. @ConfigurationProperties注解较@Value注解支持复杂类型封装注解。
2. @ConfigurationProperties能够批量注入配置文件的属性。@Value只能一个个指定
3. @ConfigurationProperties支持松散绑定。@ConfigurationProperties(prefix = "person")，只需要指定一个前缀，就能绑定有这个前缀的所有属性值。

注① 

``` c
@PostConstruct是java5的时候引入的注解，指的是在项目启动的时候执行这个方法，也可以理解为在spring容器启动的时候执行，可作为一些数据的常规化加载，比如数据字典之类的。
被@PostConstruct修饰的方法会在服务器加载Servle的时候运行，并且只会被服务器执行一次。PostConstruct在构造函数之后执行
	加载顺序为：
服务器加载Servlet -> servlet 构造函数的加载 -> postConstruct ->init（init是在service 中的初始化方法. 创建service 时发生的事件.） ->Service->destory->predestory->服务器卸载serlvet
那么问题：spring中Constructor、@Autowired、@PostConstruct的顺序
Constructor >> @Autowired >> @PostConstruct
```



 