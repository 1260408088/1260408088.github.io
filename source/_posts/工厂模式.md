---
title: 工厂模式
date: 2019-07-25 10:10:12
categories: [设计模式]
tags: [设计模式,工厂]
---

# 工厂模式的好处

​		工厂模式是我们最常用的实例化对象模式了，是用工厂方法代替new操作的一种模式。利用工厂模式可以降低程序的耦合性，为后期的维护修改提供了很大的便利。将选择实现类、创建对象统一管理和控制。从而将调用者跟我们的实现类解耦。

<!--more-->

# 简单工厂

先定义一个Car的接口

``` java
public interface Car {
    public void run();
}
```

Audi

``` java
public class Audi implements Car{
    @Override
    public void run() {
        System.out.println("我是高端豪华品牌");
    }
}
```

Lexus 

``` java
public class Lexus implements Car{
    @Override
    public void run() {
        System.out.println("我也是高端豪华品牌");
    }
}
```

Factory

``` java
public class Factory {
    public static Car creatCar(String car) {
        if ("".equals(car) && null == car) {
            return null;
        }
        Car Fcar = null;
        switch (car) {
            case "lexus":
                Fcar = new Lexus();
                break;
            case "audi":
                Fcar = new Audi();
                break;
        }
        return Fcar;
    }
}
```

Client

``` java
public class Client {
    public static void main(String[] args) {
        Car lexus = Factory.creatCar("lexus");
        Car audi = Factory.creatCar("audi");
        lexus.run();
        audi.run();
    }
}
```

我们在生成工厂的时候可以加一些业务代码，如日志、判断业务等，这时候可以直接在switch case中加上去就行了。

``` java
public class Factory {

    static Car lexusProduct(){
        System.out.println("生产雷克萨斯");
        return new Lexus();
    }

    static Car audiProduct(){
        System.out.println("生产奥迪");
        return new Audi();
    }

    public static Car creatCar(String car) {
        if ("".equals(car) && null == car) {
            return null;
        }
        Car Fcar = null;
        switch (car) {
            case "lexus":
                Fcar = lexusProduct();
                break;
            case "audi":
                Fcar = audiProduct();
                break;
        }
        return Fcar;
    }
}
```

优点：我们可以对创建的对象进行一些 “加工” ，而且客户端并不知道，因为工厂隐藏了这些细节。如果，没有工厂的话，那我们是不是就得自己在客户端上写这些代码，这就好比本来可以在工厂里生产的东西，拿来自己手工制作，不仅麻烦以后还不好维护。

缺点：如果需要在方法里写很多与对象创建有关的业务代码，而且需要的创建的对象很多的话，我们要在这个简单工厂类里编写很多个方法，每个方法里都得写很多相应的业务代码，而每次增加子类或者删除子类对象的创建都需要打开这简单工厂类来进行修改。这会导致这个简单工厂类很庞大臃肿、耦合性高，而且增加、删除某个子类对象的创建都需要打开简单工厂类来进行修改代码也违反了开-闭原则。（开闭原则是Java世界里最基础的设计原则， 它指导我们如何建立一个稳定的、 灵活的系统， 先来看开闭原则的定义：一个软件实体如类、 模块和函数应该对扩展开放， 对修改关闭）

# 工厂方法模式

Car接口与Factory接口

``` java
public interface Car {
    public void run();
}

public interface Factory {
    public Car creatCar();
}
```

生产的不同的不同类型的车

``` java
public class Lexus implements Car {
    @Override
    public void run() {
        System.out.println("lexus");
    }
}

public class Audi implements Car {
    @Override
    public void run() {
        System.out.println("Audi");
    }
}
```

不同类型的车对应的不同的工厂

``` java
public class AudiFactory implements Factory{
    @Override
    public Car creatCar() {
        return new Audi();
    }
}

public class LexusFactory implements Factory{
    @Override
    public Car creatCar() {
        return new Lexus();
    }
}
```

client

``` java
public class Client {
    public static void main(String[] args) {
        Car audi = new AudiFactory().creatCar();
        Car lexus = new LexusFactory().creatCar();
        audi.run();
        lexus.run();
    }
}
```

优点：工厂方法把简单工厂的内部逻辑判断转移到了客户端代码来进行。添加功能，本来是改工厂类的，而现在是修改客户端。而且各个不同功能的实例对象的创建代码，也没有耦合在同一个工厂类里，这也是工厂方法模式对简单工厂模式解耦的一个体现。工厂方法模式克服了简单工厂会违背开-闭原则的缺点，又保持了封装对象创建过程的优点。

缺点：但工厂方法模式的缺点是每增加一个产品类，就需要增加一个对应的工厂类，增加了额外的开发量。

# 抽象工厂模式

使用数据的例子来说明，觉得这个例子很是不错，[就拿来主义了](https://blog.csdn.net/u012156116/article/details/80857255)

实体类

``` java
public class User {

    private int uid;
    private String uname;

    public int getUid() {
        return uid;
    }

    public void setUid(int uid) {
        this.uid = uid;
    }

    public String getUname() {
        return uname;
    }

    public void setUname(String uname) {
        this.uname = uname;
    }

}
```

User接口

``` java
public interface IUser {
    public void insert(User user);
    public User getUser(int uid);
}
```

工厂接口

``` java
public interface SqlFactory {
    public IUser createUser();     //用于访问User表的对象
}
```

MysqlUser

``` java
public class MysqlUser implements IUser{
    public void insert(User user){
        System.out.println("在mysql中的user表中插入一条元素");
    }

    public User getUser(int id){
        System.out.println("在mysql中的user表得到id为"+id+"的一条数据");
        return null;
    }
}
```

OracleUser

``` java
public class OracleUser implements IUser{
    @Override
    public void insert(User user) {
        System.out.println("在oracle中的user表中插入一条元素");
    }

    @Override
    public User getUser(int uid) {
        System.out.println("在oracle中的user表得到id为"+uid+"的一条数据");
        return null;
    }
}
```

MysqlFactory

``` java
public class MysqlFactory implements sqlFactory{
    @Override
    public IUser createUser() {
        return new mysqlUser();  //访问mysql中User表的对象
    }
}
```

OrcleFactory

``` java
public class OracleFactory implements sqlFactory{
    @Override
    public IUser createUser() {
        return new oracleUser();   //访问oracle中User表的对象
    }
}
```

Client

``` java
public class Client {
    public static void main(String[] args) {
        sqlFactory factory = new mysqlFactory();
        IUser userOperator = factory.createUser();
        userOperator.getUser(1);
        userOperator.insert(new User());
    }
}
```

效果：

![](1.PNG)

比如可以，扩展一下，添加一个login的记录。

Login类

``` java
public class Login {
    private int id;
    private Date date;

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public Date getDate() {
        return date;
    }

    public void setDate(Date date) {
        this.date = date;
    }
}
```

Login功能接口

``` java
public interface ILogin {
    public void insert(Login login);
    public Login getLogin(int id);
}
```

MysqlLogin

``` java
public class MysqlLogin implements ILogin{
    public void insert(Login login) {
        System.out.println("对 MySQL 里的 Login 表插入了一条数据");
    }

    public Login getLogin(int id) {
        System.out.println("通过 uid 在 MySQL 里的 Login 表得到了一条数据");
        return null;
    }
}
```

OracleLogin

``` java
public class OracleLogin implements ILogin{
    public void insert(Login login) {
        System.out.println("对 Oracle 里的 Login 表插入了一条数据");
    }

    public Login getLogin(int id) {
        System.out.println("通过 uid 在 Oracle 里的 Login 表得到了一条数据");
        return null;
    }
}
```

效果：

![](2.PNG)

优点：

1. 抽象工厂模式最大的好处是易于交换产品系列，由于具体工厂类，例如 IFactory factory=new OracleFactory(); 在一个应用中只需要在初始化的时候出现一次，这就使得改变一个应用的具体工厂变得非常容易，它只需要改变具体工厂即可使用不同的产品配置。不管是任何人的设计都无法去完全防止需求的更改，或者项目的维护，那么我们的理想便是让改动变得最小、最容易，例如我现在要更改以上代码的数据库访问时，只需要更改具体的工厂即可。

2. 抽象工厂模式的另一个好处就是它让具体的创建实例过程与客户端分离，客户端是通过它们的抽象接口操作实例，产品实现类的具体类名也被具体的工厂实现类分离，不会出现在客户端代码中。就像我们上面的例子，客户端只认识IUser和ILogin，至于它是MySQl里的表还是Oracle里的表就不知道了。

缺点：

1. 如果你的需求来自增加功能，比如增加Login表，就有点太烦了。首先需要增加 ILogin，mysqlLogin,oracleLogin。 然后我们还要去修改工厂类： sqlFactory， mysqlFactory， oracleFactory 才可以实现，需要修改三个类，实在是有点麻烦。

2. 还有就是，客户端程序肯定不止一个，每次都需要声明sqlFactory factory=new MysqlFactory()， 如果有100个调用数据库的类，就需要更改100次sqlFactory factory=new oracleFactory()。







