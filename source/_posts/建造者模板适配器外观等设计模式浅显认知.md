---
title: 建造者模板适配器外观等设计模式浅显认知
date: 2019-10-30 20:32:40
categories: [设计模式]
tags: [建造者,模板,适配,外观]
---

# 建造者模式

这里以游戏开发中人物的构造过程为例。在游戏中创建一个形象时，需要对每个部位进行创建。简化而言，需要创建头部，身体和四肢。

**先来个person**

``` java
public class Person {
    private String head;
    private String body;
    private String foot;

    public String getHead() {
        return head;
    }

    public void setHead(String head) {
        this.head = head;
    }

    public String getBody() {
        return body;
    }

    public void setBody(String body) {
        this.body = body;
    }

    public String getFoot() {
        return foot;
    }

    public void setFoot(String foot) {
        this.foot = foot;
    }
}
```

<!--more-->

​	对应建造各个部位的接口（建造的部位，你可以比作游戏中某些部位的加强，护膝、头盔、胸甲之类的，最后还要负责组装起来）

``` java
public interface Builder {

    void builderHead();

    void builderBody();

    void builderFoot();

    Person BuilderPersion(); //组装

}
```

接口的实现，理解为对应部位装备的加强

``` java
public class ConcreteBuilder implements Builder{

    private Person person;

    public ConcreteBuilder(){
        person= new Person();
    }

    @Override
    public void builderHead() {
        person.setHead("建造者头部分");
    }

    @Override
    public void builderBody() {
        person.setBody("建造者身体");
    }

    @Override
    public void builderFoot() {
        person.setFoot("建造者尾部");
    }

    @Override
    public Person BuilderPersion() {
        return person;
    }
}
```

最后的使用：**调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建**

``` java
public class PersonDirector {
    public Person constructPerson(Builder pb) {
        pb.builderHead();
        pb.builderBody();
        pb.builderFoot();
        return pb.BuilderPersion();
    }

    public static void main(String[] args) {
        PersonDirector pb = new PersonDirector();
        Person person = pb.constructPerson(new ConcreteBuilder());
        System.out.println(person.getHead());
        System.out.println(person.getBody());
        System.out.println(person.getFoot());
    }

}
```

print:

``` java
建造者头部分
建造者身体
建造者尾部

```

# 模板方法模式

核心思想：处理某个流程的代码已经都具备，但是其中某个节点的代码暂时不能确定。因此，我们采用工厂方法模式，将这个节点的代码实现转移给子类完成，换句话就是，处理步骤在父类中定义好，具体的实现延迟到子类中定义。说人话就是：**就是将一些相同操作的代码，封装成一个算法的骨架。核心的部分留在子类中操作，在父类中只把那些骨架做好**

银行业务为例子:

``` java
// 模板方法
public abstract class BankTemplateMethod {

    // 1.取号排队
    public void takeNumber() {
        System.out.println("取号排队。。");
    }

    // 2.每个子类不同的业务实现，由各自子类实现.
    abstract void transact();

    // 3.评价
    public void evaluate() {
        System.out.println("反馈评价..");
    }

    public void process() {
        takeNumber();
        transact();
        evaluate();
    }
    
}
```

存钱：

``` java
public class SaveMoney extends BankTemplateMethod{
    @Override
    void transact() {
        System.out.println("我要存款");
    }
}
```

取钱：

``` java
public class DrawMoney extends BankTemplateMethod{
    @Override
    void transact() {
        System.out.println("我要取款");
    }
}
```

clent:

``` java
public class Client {
    public static void main(String[] args) {
        BankTemplateMethod bankTemplate=new DrawMoney();
        bankTemplate.process();
        BankTemplateMethod saveMoney = new SaveMoney();
        saveMoney.process();
    }
}
```

print

``` java
取号排队。。
我要取款
反馈评价..
取号排队。。
我要存款
反馈评价..
```

# 外观模式

​		外观模式（Facade Pattern）门面模式，隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。

demo：

``` java
// 邮件发送
public interface EamilSmsService {
	  public void sendSms();	
}
public class EamilSmsServiceImpl implements   EamilSmsService{
	public void sendSms() {
		System.out.println("发送邮件消息");
	}
}
```

``` java
// 微信消息推送
public interface WeiXinSmsService {
  public void sendSms();	
}
public class EamilSmsServiceImpl implements   EamilSmsService{

	@Override
	public void sendSms() {
		System.out.println("发送邮件消息");
	}
}

```

``` java
// 阿里短信消息
public interface AliSmsService {
	public void sendSms();
}
public class AliSmsServiceImpl implements AliSmsService {
	@Override
	public void sendSms() {
     System.out.println("支付宝发送消息...");
	}
}

```

``` java
// 门面类
public class Computer {
	AliSmsService aliSmsService;
	EamilSmsService eamilSmsService;
	WeiXinSmsService weiXinSmsService;
	public Computer() {
		aliSmsService = new AliSmsServiceImpl();
		eamilSmsService = new EamilSmsServiceImpl();
		weiXinSmsService = new WeiXinSmsServiceImpl();
	}
	public void sendMsg() {
		aliSmsService.sendSms();
		eamilSmsService.sendSms();
		weiXinSmsService.sendSms();

	}
}

```

``` java
public class Client {
	public static void main(String[] args) {
		new Computer().sendMsg();
	}
}

```

这不就是Java的封装吗？

# 适配器模式

在设计模式中，适配器模式（英语：adapter pattern）有时候也称包装样式或者包装(wrapper)。将一个类的接口转接成用户所期待的。一个适配使得因接口不兼容而不能在一起工作的类工作在一起，做法是将类自己的接口包裹在一个已存在的类中。

demo：

``` java
//日本110V 电源接口
public interface JP110VInterface {

	public void connect();

}

```

``` java
public class JP110VInterfaceImpl implements JP110VInterface {

	@Override
	public void connect() {
       System.out.println("日本110V,接通电源,开始工作..");
	}

}

```

``` java
public interface CN220VInterface {
	public void connect();
}
```

``` java
public class CN220VInterfaceImpl implements CN220VInterface {

	@Override
	public void connect() {
	 System.out.println("中国220V,接通电源,开始工作");
		
	}

}

```

定义一个电饭煲

``` java
public class ElectricCooker {

	private JP110VInterface jp110VInterface;//日本电饭煲
	ElectricCooker(JP110VInterface jp110VInterface){
		 this.jp110VInterface=jp110VInterface;
	}
	
	public void cook(){
		jp110VInterface.connect();
		System.out.println("开始做饭了..");
	}

}

```

电源适配器：

``` java
public class PowerAdaptor implements JP110VInterface {
	private CN220VInterface cn220VInterface;

	public PowerAdaptor(CN220VInterface cn220VInterface) {
		this.cn220VInterface = cn220VInterface;
	}

	@Override
	public void connect() {
		cn220VInterface.connect();
	}

}
```

``` java
public class AdaptorTest {

	public static void main(String[] args) {
		CN220VInterface cn220VInterface = new CN220VInterfaceImpl();
		PowerAdaptor powerAdaptor = new PowerAdaptor(cn220VInterface);
		// 电饭煲
		ElectricCooker cooker = new ElectricCooker(powerAdaptor);
		cooker.cook();//使用了适配器,在220V的环境可以工作了。
	}

}

```

