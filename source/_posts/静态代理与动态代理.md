---
title: 静态代理与动态代理
date: 2019-10-28 19:12:10
categories: 设计模式
tags: [静态代理,动态代理]
---

# 何为代理模式

​		代理控制对象的访问,可以详细访问某个对象的方法，在这个方法调用处理，或调用后处理。既(AOP微实现) 
AOP核心技术面向切面编程。

# 静态代理与动态代理

## 静态代理

先写一个接口

``` java
public interface IUserDao {
    void save();
}
```

接口的实现

``` java
public class IUserDaoImpl implements IUserDao{
    @Override
    public void save() {
        System.out.println("保存输出数据.........");
    }
}
```

进行调用

``` java
public class Proxy implements IUserDao{
    private IUserDao target;

    public Proxy(IUserDao iuserDao) {
        this.target = iuserDao;
    }

    public void save() {
        System.out.println("开启事物...");
        target.save();
        System.out.println("关闭事物...");
    }

    public static void main(String[] args) {
        IUserDao user=new IUserDaoImpl();
        Proxy proxy=new Proxy(user);
        proxy.save();
    }
}
```

内容输出

``` java
开启事物...
保存输出数据.........
关闭事物...
```

静态代理模式用起来，太过繁琐。在内容多了以后代码会略显臃肿，静态代理也较为少用。

## 动态代理

### JDK动态代理

​	是根据类加载器和接口创建代理类（此代理类是接口的实现类，所以必须使用接口面向接口生成代理，位于java.lang.reflect包下）<span style="color:red">说白了就是使用了反射</span>。***dk动态代理，必须是面向接口，目标业务类必须实现接口**

​	简单的一个demo来说明问题，还就静态代理的接口与实现。

``` java
public class InvocationHandlerImpl implements InvocationHandler {
    private Object target;// 这其实业务实现类对象，用来调用具体的业务方法
    // 通过构造函数传入目标对象
    public InvocationHandlerImpl(Object target) {
        this.target = target;
    }

    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        Object result = null;
        System.out.println("调用开始处理");
        result = method.invoke(target, args);
        System.out.println("调用结束处理");
        return result;
    }

    public static void main(String[] args) throws NoSuchMethodException, SecurityException, InstantiationException,
            IllegalAccessException, IllegalArgumentException, InvocationTargetException {
        // 被代理对象
        IUserDao userDao = new IUserDaoImpl();
        InvocationHandlerImpl invocationHandlerImpl = new InvocationHandlerImpl(userDao);
        ClassLoader loader = userDao.getClass().getClassLoader();
        Class<?>[] interfaces = userDao.getClass().getInterfaces();
        // 主要装载器、一组接口及调用处理动态代理实例
        IUserDao newProxyInstance = (IUserDao) Proxy.newProxyInstance(loader, interfaces, invocationHandlerImpl);
        newProxyInstance.save();
    }
}
```

输出

``` java
调用开始处理
保存输出数据.........
调用结束处理
```

### CGLIB动态代理

​	cglib[CodeGeneration Library]实现动态代理，并不要求委托类必须实现接口，底层采用asm字节码生成框架生成代理类的字节码。

引入一下依赖

``` xml
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-lang3</artifactId>
    <version>3.7</version>
</dependency>
<dependency>
    <groupId>cglib</groupId>
    <artifactId>cglib</artifactId>
    <version>3.1</version>
</dependency>
```

动态代理的demo

``` java
public class CglibProxy implements MethodInterceptor {
	private Object targetObject;
	// 这里的目标类型为Object，则可以接受任意一种参数作为被代理类，实现了动态代理
	public Object getInstance(Object target) {
		// 设置需要创建子类的类
		this.targetObject = target;
		Enhancer enhancer = new Enhancer();
		enhancer.setSuperclass(target.getClass());
		enhancer.setCallback(this);
		return enhancer.create();
	}

	public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
		System.out.println("开启事物");
		Object result = proxy.invoke(targetObject, args);
		System.out.println("关闭事物");
		// 返回代理对象
		return result;
	}
	public static void main(String[] args) {
		CglibProxy cglibProxy = new CglibProxy();
		UserDao userDao = (UserDao) cglibProxy.getInstance(new UserDao());
		userDao.save();
	}
}
```

### CGLIB动态代理与JDK动态区别

java动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。而cglib动态代理是利用asm开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。在Spring中

1. 如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP 
2. 如果目标对象实现了接口，可以强制使用CGLIB实现AOP 
3. 如果目标对象没有实现了接口，必须采用CGLIB库，spring会自动在JDK动态代理和CGLIB之间转换

 JDK动态代理只能对实现了接口的类生成代理，而不能针对类 。
 CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法 。
 因为是继承，所以该类或方法最好不要声明成final ，final可以阻止继承和多态。

