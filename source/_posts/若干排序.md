---
title: 若干排序
date: 2019-09-09 22:44:06
categories: [数据结构]
tags: [数据结构,算法]
---

# 冒泡排序

本质上是两两进行比较，较大向后移动，故名思意为冒泡排序。

``` java
for (int i = 1; i <num.length ; i++) {
    for(int j=0;j<num.length-1;j++){
        if (num[j] > num[j + 1]) {
            int temp = num[j];
            num[j] = num[j + 1];
            num[j + 1] = temp;
        }
    }
}
```

冒泡排序的**最坏时间复杂度**为O(N2)。
因此，冒泡排序的**平均时间复杂度**为O(N2)。
总结起来，其实就是一句话：当数据越接近正序时，冒泡排序性能越好。

冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。

所以相同元素的前后顺序并没有改变，所以冒泡排序是一种**稳定排序算法**。

## 优化

即使数组是有序的也需要比较**n-1**次，这就不太合理了，微微的优化一下，有序后就可以直接跳出了，不用再循环了。

``` java
boolean flag=false;
for (int i = 1; i <num.length ; i++) {
    for(int j=0;j<num.length-1;j++){
        if (num[j] > num[j + 1]) {
            int temp = num[j];
            num[j] = num[j + 1];
            num[j + 1] = temp;
            flag=true;
        }
    }
    if(!flag){
        brreak;
    }
}
```

# 快速排序

​		找一个flag，通常为要比对数组中的第一个数，最为标尺。让两个游标（i，j）j从后向前，i从前到后遍历，遍历到下标为j的比flag小的数后停下来，然后i再从前到后遍历，找到下标为i比flag大的然后停下来，交换j与i之间的值。直到i与j重合后，将当前i与j重合的数与flag互换。然后以flag为数组中心，分成两段重复上面的操作。（递归）

![](2.PNG)

![](3.PNG)

![](4.PNG)

![](5.PNG)

![](6.PNG)

![](7.PNG)

![](8.PNG)

![](9.PNG)

图片出自《啊哈算法》，很幽默风趣的一本算法数。**推荐推荐推荐**，图片说明的也很是清楚。

![](1.PNG)

``` java
public class Quickly {
    public static void quickSort(int[] arr,int low,int high){
        int i,j,temp,t;
        if(low>high){
            return;
        }
        i=low;
        j=high;
        //temp就是基准位
        temp = arr[low];

        while (i<j) {
            //先看右边，依次往左递减
            while (temp<=arr[j]&&i<j) {
                j--;
            }
            //再看左边，依次往右递增
            while (temp>=arr[i]&&i<j) {
                i++;
            }
            //如果满足条件则交换
            if (i<j) {
                t = arr[j];
                arr[j] = arr[i];
                arr[i] = t;
            }

        }
        //最后将基准为与i和j相等位置的数字交换
        arr[low] = arr[i];
        arr[i] = temp;
        //递归调用左半数组
        quickSort(arr, low, j-1);
        //递归调用右半数组
        quickSort(arr, j+1, high);
    }

    public static void main(String[] args){
        int[] arr = {1,3,5,7,8};
        quickSort(arr, 0, arr.length-1);
        for (int i = 0; i < arr.length; i++) {
            System.out.println(arr[i]);
        }
    }
}

```



​	快速排序的效率很高的，通常情况下（平均）的时间复杂度为O(nlog2^n)，最坏为O(N^2)，但是快速排序不太稳定，不能用于对象的比较。（相同的值，排序后顺序会打乱）

# 选择排序

​		首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。重复，直到所有元素均排序完毕

![](https://www.runoob.com/wp-content/uploads/2019/03/selectionSort.gif)

``` java
public static void main(String[] args) {
        int[] arr = {1, 3, 5, 7, 8};
        for (int i = 0; i < arr.length - 1; i++) {
            int min = i;
            for (int j = i + 1; j < arr.length; j++) {
                if (arr[j] < arr[min]) {
                    min = j;
                }
            }
            if (i != min) {
                int temp = arr[i];
                arr[i] = arr[min];
                arr[min] = temp;
            }
        }
    }
```

​	任何情况下都是 O(n²) ，也是一个不稳定的排序。