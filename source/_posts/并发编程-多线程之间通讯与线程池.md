---
layout: 'n'
title: 并发编程-多线程之间通讯与线程池
date: 2019-06-17 09:46:17
categories: 并发编程
tags: [线程池,线程间通讯]
---

# wait与notify

## 抛出问题说明

 需求:第一个线程写入(input)用户，另一个线程取读取(out)用户.实现读一个，写一个操作。

<!--more-->

先来看看反面例子一

``` java
class Res {
    public String userName;
    public String sex;
}

class InputThread extends Thread {
    private Res res;

    public InputThread(Res res) {
        this.res = res;
    }

    @Override
    public void run() {
        int count = 0;
        while (true) {
                if (count == 0) {
                    res.userName = "小李";
                    res.sex = "男";
                } else {
                    res.userName = "小红";
                    res.sex = "女";
                }
                count = (count + 1) % 2;  // 结果为0 1 0 1循环往复
        }
    }
}

class OutThrad extends Thread {
    private Res res;

    public OutThrad(Res res) {
        this.res = res;
    }

    @Override
    public void run() {
        while (true) {
            // synchronized (res) {
                System.out.println(res.userName + "," + res.sex);
           // }
        }

    }
}

public class ThreadDemo {

    public static void main(String[] args) {
        Res res = new Res();
        InputThread inputThread = new InputThread(res);
        OutThrad outThrad = new OutThrad(res);
        inputThread.start();
        outThrad.start();
    }

}
```

输出：

![1](1.PNG)

男女错位了，造成了线程安全问题。还有synchronized 关键字可以解决线程安全的问题的，加上它。

``` java
class Res {
	public String userName;
	public String sex;
}

class InputThread extends Thread {
	private Res res;

	public InputThread(Res res) {
		this.res = res;
	}

	@Override
	public void run() {
		int count = 0;
		while (true) {
			 synchronized (res) {
			if (count == 0) {
				res.userName = "余胜军";
				res.sex = "男";
			} else {
				res.userName = "小红";
				res.sex = "女";
			}
			count = (count + 1) % 2;
		}

		}
	}
}

class OutThrad extends Thread {
	private Res res;

	public OutThrad(Res res) {
		this.res = res;
	}

	@Override
	public void run() {
		while (true) {
			synchronized (res) {
				System.out.println(res.userName + "," + res.sex);
			}
		}

	}
}

public class ThreadDemo01 {

	public static void main(String[] args) {
		Res res = new Res();
		InputThread inputThread = new InputThread(res);
		OutThrad outThrad = new OutThrad(res);
		inputThread.start();
		outThrad.start();
	}

}


```

直接出现了一大堆，和题意不符合！并不是生产一个消费一个的。

1. 因为涉及到对象锁,他们必须都放在synchronized中来使用. Wait、Notify一定要在synchronized里面进行使用。

2. Wait必须暂定当前正在执行的线程,并释放资源锁,让其他线程可以有机会运行

3. notify/notifyall: 唤醒因锁池中的线程,使之运行

<span style="color:red">注意:一定要在线程同步中使用,并且是同一个锁的资源</span>，加上wait与notify后，稍加改造。

``` java
class Res {
    public String userSex;
    public String userName;
    //线程通讯标识
    public boolean flag = false;
}

class IntThrad extends Thread {
    private Res res;

    public IntThrad(Res res) {
        this.res = res;
    }

    @Override
    public void run() {
        int count = 0;
        while (true) {
            synchronized (res) {
                if (res.flag) {
                    try {
                        // 当前线程变为等待
                        res.wait();
                    } catch (Exception e) {

                    }
                }
                if (count == 0) {
                    res.userName = "小李";
                    res.userSex = "男";
                } else {
                    res.userName = "小紅";
                    res.userSex = "女";
                }
                count = (count + 1) % 2;
                res.flag = true;
                // 唤醒等待的线程
                res.notify();
            }

        }
    }
}

class OutThread extends Thread {
    private Res res;

    public OutThread(Res res) {
        this.res = res;
    }

    @Override
    public void run() {
        while (true) {
            synchronized (res) {
                if (!res.flag) {
                    try {
                        res.wait();
                    } catch (Exception e) {

                    }
                }
                System.out.println(res.userName + "--" + res.userSex);
                res.flag = false;
                res.notify();
            }
        }
    }
}

public class ThreaCommun {
    public static void main(String[] args) {
        Res res = new Res();
        IntThrad intThrad = new IntThrad(res);
        OutThread outThread = new OutThread(res);
        intThrad.start();
        outThread.start();
    }
}
```

![](2.PNG)

符合要求正好是生产一个消费一个，也没有线程的安全问题。

## wait与sleep的区别

- 对于sleep()方法，我们首先要知道该方法是属于Thread类中的。而wait()方法，则是属于Object类中的。

- sleep()方法导致了程序暂停执行指定的时间，让出cpu给其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。

- 在调用sleep()方法的过程中，线程不会释放对象锁。

- 而当调用wait()方法的时候，线程会释放锁锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备获取对象锁进入运行状态。

## 线程池

