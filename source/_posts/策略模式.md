---
title: 策略模式与观察者模式
categories: [设计模式]
date: 2019-11-11 19:50:45
tags: [策略模式]
---

# 策略模式

## 什么是策略模式

​		定义了一系列的算法，并将每一个算法封装起来，而且使它们还可以相互替换。策略模式让算法独立于使用它的客户而独立变化。

## 策略模式的运用

​	策略模式的用意是针对一组算法或逻辑，将每一个算法或逻辑封装到具有共同接口的独立的类中，从而使得它们之间可以相互替换。策略模式使得算法或逻辑可以在不影响到客户端的情况下发生变化。说到策略模式就不得不提及OCP(Open Closed Principle) 开闭原则，即对扩展开放，对修改关闭。策略模式的出现很好地诠释了开闭原则，有效地减少了分支语句。

**此代码通过模拟不同会员购物车打折力度不同分为三种策略，初级会员，中级会员，高级会员**

``` java
//策略模式 定义抽象方法 所有支持公共接口
abstract class Strategy {

	// 算法方法
	abstract void algorithmInterface();

}

class StrategyA extends Strategy {

	@Override
	void algorithmInterface() {
		System.out.println("算法A");

	}

}

class StrategyB extends Strategy {

	@Override
	void algorithmInterface() {
		System.out.println("算法B");

	}

}

class StrategyC extends Strategy {

	@Override
	void algorithmInterface() {
		System.out.println("算法C");

	}

}
// 使用上下文维护算法策略

class Context {

	Strategy strategy;

	public Context(Strategy strategy) {
		this.strategy = strategy;
	}

	public void algorithmInterface() {
		strategy.algorithmInterface();
	}

}

class ClientTestStrategy {
	public static void main(String[] args) {
		Context context;
		context = new Context(new StrategyA());
		context.algorithmInterface();
		context = new Context(new StrategyB());
		context.algorithmInterface();
		context = new Context(new StrategyC());
		context.algorithmInterface();

	}
}

```

# 观察者模式

​	最初是学习android的时候，做电子商城的下载的时候，需要在多个位置显示下载的进度，所以使用了这个观察者模式，这也可能是我最（实际）早接触的设计模式了。

``` java

public interface Observer {
    // 观察者方法
    void update(Subjecct subjecct);

}
```

``` java
public class Subjecct {
    //观察者的存储集合
    private List<Observer> list = new ArrayList<>();

    // 注册观察者方法
    public void registerObserver(Observer obs) {
        list.add(obs);
    }
    // 删除观察者方法
    public void removeObserver(Observer obs) {
        list.remove(obs);
        this.notifyAllObserver();
    }

    // 通知所有的观察者更新
    public void notifyAllObserver() {
        for (Observer observer : list) {
            observer.update(this);
        }
    }

}
```

``` java
public class WeatherObserver implements Observer{
    private String weatherState;
    private String name;
    private String activity;
    @Override
    public void update(Subjecct subjecct) {
        weatherState = ((WeatherSubject) subjecct).getState();
        System.out.println(name+":"+weatherState+",我准备去"+activity);
    }


    public void setName(String name) {
        this.name = name;
    }

    public void setActivity(String activity) {
        this.activity = activity;
    }

    public String getWeatherState() {
        return weatherState;
    }

    public String getName() {
        return name;
    }

    public String getActivity() {
        return activity;
    }
}
```

``` java
public class WeatherSubject extends Subjecct{
    //被观察对象的属性
    private String state;
    public String getState(){
        return state;
    }
    public void setState(String state){
        this.state=state;
        //主题对象(目标对象)值发生改变
        this.notifyAllObserver();
    }

}
```

``` java
public class Client {
    public static void main(String[] args) {
        // 创建目标
        WeatherSubject subjecct = new WeatherSubject();
        // 创建观察者
        WeatherObserver observerSu = new WeatherObserver();
        observerSu.setName("苏");
        observerSu.setActivity("图书馆");
        WeatherObserver observerYu = new WeatherObserver();
        observerYu.setName("吃瓜群众");
        observerYu.setActivity("爬山");
        // 注册观察者
        subjecct.registerObserver(observerSu);
        subjecct.registerObserver(observerYu);
        // 发布时间更新
        subjecct.setState("明天天气晴朗，24°，阵风3级");
        // 当确定不需要再接受广播事件的时候将其取消
        subjecct.removeObserver(observerSu);
    }
}
```

print:

``` java
苏:明天天气晴朗，24°，阵风3级,我准备去图书馆
吃瓜群众:明天天气晴朗，24°，阵风3级,我准备去爬山
```

