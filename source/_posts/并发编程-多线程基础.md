---
title: 并发编程-多线程基础
date: 2019-06-11 11:15:52
categories: 并发编程
tags: [多线程,并发]
---

# 进程与线程的区别

​	进程是所有线程的集合，每一个线程是进程中的一条执行路径。进程与线程包含与被包含的关系，一个进程里会有多个线程。

<!--more-->

# 创建线程的集中方式

## 继承Thread类

``` java
class Thread02 extends Thread{
    @Override
    public void run() {
        for (int i = 0; i < 10; i++) {
            try {
                Thread.sleep(300); // 设置延时交替执行，效果比较清楚
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("子线程："+i);
        }
    }
}

public class Thread01 {
    public static void main(String[] args) {
        Thread02 thread02 = new Thread02();
        thread02.start();
        for (int i = 0; i < 10; i++) {
            try {
                Thread.sleep(300);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("主线程："+i);
        }
    }
}
```



## 实现Runnable接口

``` java
class Thread04 implements Runnable {
    public void run() {
        for (int i = 0; i < 11; i++) {
            try {
                Thread.sleep(300);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("子线程：" + i);
        }
    }
}

public class Thread03 {
    public static void main(String[] args) {
        Thread04 thread04 = new Thread04();
        Thread thread = new Thread(thread04);
        thread.start();
        for (int i = 0; i < 11; i++) {
            try {
                Thread.sleep(300);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("主线程：" + i);
        }
    }
}
```



## 匿名内部类

``` java
public class Thread05 {
    public static void main(String[] args) {
        new Thread(()-> { // lambda表达式，新特性还是要找机会使用一下的，要不又忘了
            for(int i = 1 ; i<100 ; i++){
                System.out.println("It is a lambda function!");
            }
        });
    }
}
```



线程池与Callable、Future留待后面进行补充，此处先留白。接口和继承当然选择接口了，毕竟 java 不支持多继承。

# 线程分类

​	Java中有两种线程，一种是用户线程，另一种是守护线程。用户线程是指用户自定义创建的线程，主线程停止，用户线程不会停止。守护线程当进程不存在或主线程停止，守护线程也会被停止。使用 setDaemon(true) 方法设置为守护线程。

``` java
public class DaemonThread {
	public static void main(String[] args) {
		Thread thread = new Thread(new Runnable() {
			@Override
			public void run() {
				while (true) {
					try {
						Thread.sleep(100);
					} catch (Exception e) {
						// TODO: handle exception
					}
					System.out.println("我是子线程...");
				}
			}
		});
		thread.setDaemon(true);
		thread.start();
		for (int i = 0; i < 10; i++) {
			try {
				Thread.sleep(100);
			} catch (Exception e) {

			}
			System.out.println("我是主线程");
		}
		System.out.println("主线程执行完毕!");
	}
}
```

# 线程状态

## 新建状态

   当用new操作符创建一个线程时， 例如new Thread(r)，线程还没有开始运行，此时线程处在新建状态。 当一个线程处于新生状态时，程序还没有开始运行线程中的代码

## 就绪状态

​	 一个新创建的线程并不自动开始运行，要执行线程，必须调用线程的start()方法。当线程对象调用start()方法即启动了线程，start()方法创建线程运行的系统资源，并调度线程运行run()方法。当start()方法返回后，线程就处于就绪状态。

​     处于就绪状态的线程并不一定立即运行run()方法，线程还必须同其他线程竞争CPU时间，只有获得CPU时间才可以运行线程。因为在单CPU的计算机系统中，不可能同时运行多个线程，一个时刻仅有一个线程处于运行状态。因此此时可能有多个线程处于就绪状态。对多个处于就绪状态的线程是由[Java](http://lib.csdn.net/base/java)运行时系统的线程调度程序(*thread scheduler*)来调度的。

## 运行状态

​	当线程获得CPU时间后，它才进入运行状态，真正开始执行run()方法.

## 阻塞状态

​	线程运行过程中，可能由于各种原因进入阻塞状态:
​    	1.线程通过调用sleep方法进入睡眠状态；

   	 2.线程调用一个在I/O上被阻塞的操作，即该操作在输入输出操作完成之前不会返回到它的调用者；

  	  3.线程试图得到一个锁，而该锁正被其他线程持有；

   	 4.线程在等待某个触发条件； 

##  死亡状态

有两个原因会导致线程死亡：

1. run方法正常退出而自然死亡。
2. 一个未捕获的异常终止了run方法而使线程猝死。

为了确定线程在当前是否存活着（就是要么是可运行的，要么是被阻塞了），需要使用isAlive方法。如果是可运行或被阻塞，这个方法返回true； 如果线程仍旧是new状态且不是可运行的， 或者线程死亡了，则返回false.

# join()的使用

当在主线程当中执行到 t1.join() 方法时，就认为主线程应该把执行权让给t1。

``` java
 public static void main(String[] args) {
        Thread t1 = new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i < 10; i++) {
                    try {
                        Thread.sleep(10);
                    } catch (Exception e) {

                    }
                    System.out.println(Thread.currentThread().getName() + "i:" + i);
                }
            }
        });
        t1.start();
        // 当在主线程当中执行到t1.join()方法时，就认为主线程应该把执行权让给t1
        try {
            t1.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        for (int i = 0; i < 10; i++) {
            try {
                Thread.sleep(10);
            } catch (Exception e) {

            }
            System.out.println("main" + "i:" + i);
        }
    }
```

# 线程优先级

​	在JAVA线程中，通过一个int priority来控制优先级，范围为1-10，其中10最高，默认值为5。下面是源码（基于1.8）中关于priority的一些量和方法。

``` java
class PrioritytThread implements Runnable {
	public void run() {
		for (int i = 0; i < 100; i++) {
			System.out.println(Thread.currentThread().toString() + "---i:" + i);
		}
	}
}

public class ThreadDemo4 {
	public static void main(String[] args) {
		PrioritytThread prioritytThread = new PrioritytThread();
		Thread t1 = new Thread(prioritytThread);
		Thread t2 = new Thread(prioritytThread);
		t1.start();
		// 注意设置了优先级， 不代表每次都一定会被执行。 只是CPU调度会有限分配
		t1.setPriority(10);
		t2.start();	
	}
}
```

# Yield方法

Thread.yield()方法的作用：暂停当前正在执行的线程，并执行其他线程。（可能没有效果）yield()让当前正在运行的线程回到可运行状态，以允许具有相同优先级的其他线程获得运行的机会。因此，使用yield()的目的是让具有相同优先级的线程之间能够适当的轮换执行。但是，实际中无法保证yield()达到让步的目的，因为，让步的线程可能被线程调度程序再次选中。

结论：大多数情况下，yield()将导致线程从运行状态转到可运行状态，但有可能没有效果。

# 线程执行顺序

现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行 。本质上就是在T2里让T1.jion()，在 T3 里T2.join()。

``` java
public class JoinThreadDemo02 {
	public static void main(String[] args) {
		Thread t1 = new Thread(new Runnable() {
			public void run() {
				for (int i = 0; i < 20; i++) {
					System.out.println("t1,i:" + i);
				}
			}
		});
		Thread t2 = new Thread(new Runnable() {
			public void run() {
				try {
					t1.join();
				} catch (Exception e) {
					// TODO: handle exception
				}
				for (int i = 0; i < 20; i++) {
					System.out.println("t2,i:" + i);
				}
			}
		});
		Thread t3 = new Thread(new Runnable() {
			public void run() {
				try {
					t2.join();
				} catch (Exception e) {
					// TODO: handle exception
				}
				for (int i = 0; i < 20; i++) {
					System.out.println("t3,i:" + i);
				}
			}
		});
		t1.start();
		t2.start();
		t3.start();
	}
}
```

