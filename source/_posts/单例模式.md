---
title: 单例模式
date: 2019-07-23 11:11:17
categories: 设计模式
tags: [单例,设计模式]
---
# 应用场景

1. windows的任务管理器
2. 网站的计数器
3. 应用程序的日志
4. 数据库连接池，因为数据库连接是一种数据库资源。数据库软件系统中使用数据库连接池，主要是节省打开或者关闭数据库连接所引起的效率损耗，这种效率上的损耗还是非常昂贵的，因为何用单例模式来维护，就可以大大降低这种损耗。
5. 多线程的线程池的设计一般也是采用单例模式，这是由于线程池要方便对池中的线程进行控制。
6. 操作系统的文件系统，也是大的单例模式实现的具体例子，一个操作系统只能有一个文件系统。<!--more-->


# 优缺点

## 优点：

1. 在单例模式中，活动的单例只有一个实例，对单例类的所有实例化得到的都是相同的一个实例。这样就 防止其它对象对自己的实例化，确保所有的对象都访问一个实例 
2. 单例模式具有一定的伸缩性，类自己来控制实例化进程，类就在改变实例化进程上有相应的伸缩性。 
3. 提供了对唯一实例的受控访问。 
4. 由于在系统内存中只存在一个对象，因此可以 节约系统资源，当 需要频繁创建和销毁的对象时单例模式无疑可以提高系统的性能。 
5. 允许可变数目的实例。 
6. 避免对共享资源的多重占用。 

## 缺点： 

1. 不适用于变化的对象，如果同一类型的对象总是要在不同的用例场景发生变化，单例就会引起数据的错误，不能保存彼此的状态。 
2. 由于单利模式中没有抽象层，因此单例类的扩展有很大的困难。 
3. 单例类的职责过重，在一定程度上违背了“单一职责原则”。 
4. 滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；如果实例化的对象长时间不被利用，系统会认为是垃圾而被回收，这将导致对象状态的丢失。

# 饿汉式

``` java
public class SingletonDemo {
	// 类初始化时,会立即加载该对象，线程天生安全,调用效率高
	private static SingletonDemo singletonDemo = new SingletonDemo();

	private SingletonDemo() {
		System.out.println("SingletonDemo初始化");
	}

	public static SingletonDemo getInstance() {
		System.out.println("getInstance");
		return singletonDemo;
	}
}


```

# 懒汉式

``` java
public class SingletonDemo {
	//类初始化时，不会初始化该对象，真正需要使用的时候才会创建该对象。
	private static SingletonDemo singletonDemo;

	private SingletonDemo() {
   
	}
	public synchronized static SingletonDemo getInstance() { 
		if (singletonDemo == null) {
			singletonDemo = new SingletonDemo();
		}
		return singletonDemo;
	}
}


```

在实例化方法上加synchronzied，太影响运行效率，改为

``` java
public class SingletonDemo {
	private static SingletonDemo singletonDemo;

	private SingletonDemo() {
   
	}
	public synchronized static SingletonDemo getInstance() { 
		if (singletonDemo == null) {
            synchronized(SingletonDemo.class){  // 这样对相率有所提升(好像有点问题，忘了在哪学的，存疑？)
                singletonDemo = new SingletonDemo();   
            }
		}
		return singletonDemo;
	}
}
```

# 静态内部类

《Effective Java》中所推荐的方法

``` java
public class Singleton {  
    private static class SingletonHolder {  
        private static final Singleton uniqueInstance = new Singleton();  
    }  
    private Singleton (){
        
    }  
    public static final Singleton getInstance() {  
        return SingletonHolder.uniqueInstance; 
    }  
}
```

# 使用枚举来创建单例

​		枚举创建本质上就是一个单例，所以枚举可以达到单例的效果。枚举创建单例不仅可以防止反射来创建对象，还可以防止反序列化的方式创建对象。（枚举的使用，之后再开一篇，之前可能是环境的局限性，很少用到枚举的，需要恶补一下）

``` java
/使用枚举实现单例模式 优点:实现简单、枚举本身就是单例，由jvm从根本上提供保障!避免通过反射和反序列化的漏洞 缺点没有延迟加载
public class User {
	public static User getInstance() {
		return SingletonDemo.INSTANCE.getInstance();
	}

	private static enum SingletonDemo {
		INSTANCE;
		// 枚举元素为单例
		private User user;

		private SingletonDemo() {
			user = new User();
		}

		public User getInstance() {
			return user;
		}
	}
	public static void main(String[] args) {
		User u1 = User.getInstance();
		User u2 = User.getInstance();
		System.out.println(u1 == u2);
	}
}


```

# 双重监测锁

``` java
public class SingletonDemo {
	private volatile SingletonDemo singletonDemo; // 加 volatile 避免重排序问题

	private SingletonDemo() {

	}
	public SingletonDemo getInstance() {
		if (singletonDemo == null) {
			synchronized (SingletonDemo.class) {
				if (singletonDemo == null) {
					singletonDemo = new SingletonDemo(); // 多线程下可能会出现重排序的问题
				}
			}
		}
		return singletonDemo;
	}
}

```



